setPCFconfigState() {
  dirname=$(dirname $1)
  if [ -d $dirname ]; then 
    echo "$2" > $1
  fi
}

getPCFconfigState() {
  if [ -f "$1" ]; then 
    read x < $1
    echo $x
  else
    echo ""
  fi
}

installJumpHost() {
  if [ "${CLOUD_PROVIDER}" == "aws" ]; then
    messagePrint "Creating Jump-Server" "$JUMP_HOST"

    # --- CREATE NEW KEY IF PEM FILE IS MISSING ---
    if [ ! -s ~/.ssh/${JUMP_HOST}.pem ]; then
      messagePrint " - Missing pem file, deleting Key Pair" "pcfjump"
      aws ec2 --region=$AWS_REGION delete-key-pair --key-name pcfjump
    fi

    aws ec2 --region=$AWS_REGION describe-key-pairs --key-names pcfjump > /dev/null 2>&1
    if [ $? -ne 0 ]; then
      messagePrint " - Creating Key Pair" "pcfjump"
      aws ec2 --region=$AWS_REGION create-key-pair --key-name pcfjump \
              --query 'KeyMaterial' --output text > ~/.ssh/${JUMP_HOST}.pem 2>/dev/null
      chmod 600 ~/.ssh/${JUMP_HOST}.pem
      if [ $? -ne 0 ]; then
        echo "ERROR: Creating Key Pairs failed"
        echo "       => aws ec2 --region=$AWS_REGION create-key-pair --key-name pcfjump  \\"
        echo "                  --query 'KeyMaterial' --output text > ~/.ssh/${JUMP_HOST}.pem"; exit 1
      fi
    else
      messagePrint " - Verify Key Pair" "pcfjump"
    fi

    # --- CREATE VPC ---
    vpc=$(aws ec2 --region=$AWS_REGION describe-vpcs --filters Name=tag:type,Values="pcfjump" | jq -r '.Vpcs[].VpcId')
    if [ "${vpc}" == "" ]; then
      vpc=$(aws ec2 --region=$AWS_REGION create-vpc --cidr-block 10.0.0.0/16 | jq -r '.Vpc.VpcId')
      aws ec2 --region=$AWS_REGION create-tags --resources $vpc --tags Key=type,Value=pcfjump
      messagePrint " - Creating VPC: $vpc" "10.0.0.0/16"
    else
      messagePrint " - Verify VPC: $vpc" "10.0.0.0/16"
    fi

    i=1
    for zone in $(aws ec2 --region=$AWS_REGION describe-availability-zones | jq -r '.AvailabilityZones[].ZoneName'); do
      sid=$(aws ec2 --region=$AWS_REGION describe-subnets --filters Name=tag:type,Values="pcfjump" \
          Name=availability-zone,Values=$zone | jq -r '.Subnets[].SubnetId')
      if [ "${sid}" == "" ]; then
        sid=$(aws ec2 --region=$AWS_REGION create-subnet --vpc-id $vpc --availability-zone $zone \
                      --cidr-block 10.0.$i.0/24 2>/dev/null | jq -r '.Subnet.SubnetId')
        messagePrint " - Creating Subnet: $sid" "10.0.$i.0/16"
        if [ "${sid}" == "" ]; then
          echo "ERROR: Creating of default subnet in zone $zone failed"
          echo "       => aws ec2 --region=$AWS_REGION create-subnet --vpc-id $vpc \\"
          echo "                  --cidr-block 10.0.$i.0/24 --availability-zone $zone"; exit 1
        fi

        aws ec2 --region=$AWS_REGION create-tags --resources $sid --tags Key=type,Value=pcfjump > /dev/null 2>&1
        if [ $? -ne 0 ]; then
          echo "ERROR: Creating of Tags failed"
          echo "       => aws ec2 --region=$AWS_REGION create-tags --resources $sid --tags Key=type,Value=pcfjump"; exit 1
        fi
      else
        messagePrint " - Verify Subnet: $sid" "10.0.$i.0/16"
      fi

      let i=i+1
    done

    igw=$(aws ec2 --region=$AWS_REGION describe-internet-gateways --filters Name=tag:type,Values="pcfjump" | \
        jq -r ".InternetGateways[].InternetGatewayId")
    if [ "${igw}" == "" ]; then
      igw=$(aws ec2 --region=$AWS_REGION create-internet-gateway | jq -r '.InternetGateway.InternetGatewayId')
      messagePrint " - Creating Internet Gateway" "$igw"
      if [ "${sid}" == "" ]; then
        echo "ERROR: Creating of Internet Gateway failed"
        echo "       => aws ec2 --region=$AWS_REGION create-internet-gateway"; exit 1
      fi

      aws ec2 --region=$AWS_REGION create-tags --resources $igw --tags Key=type,Value=pcfjump > /dev/null 2>&1
      if [ $? -ne 0 ]; then
        echo "ERROR: Creating of Tags failed"
        echo "       => aws ec2 --region=$AWS_REGION create-tags --resources $sid --tags Key=type,Value=pcfjump"; exit 1
      fi
    else
      messagePrint " - Verify Internet Gateway" "$igw"
    fi

    att=$(aws ec2 --region=$AWS_REGION describe-internet-gateways --filters Name=tag:type,Values="pcfjump" | \
        jq -r ".InternetGateways[].Attachments[].VpcId")
    if [ "${att}" == "" ]; then
      aws ec2 --region=$AWS_REGION attach-internet-gateway --vpc-id $vpc --internet-gateway-id $igw > /dev/null 2>&1
      messagePrint " - Attaching Internet Gateway" "$vpc"
      if [ $? -ne 0 ]; then
        echo "ERROR: Attaching Internet Gateway to VPC: $vpc failed"
        echo "       => aws ec2 --region=$AWS_REGION attach-internet-gateway --vpc-id $vpc --internet-gateway-id $igw "; exit 1
      fi
    fi

    # --- CREATE ROUTING TABLE ---
    rtb=$(aws ec2 --region=$AWS_REGION describe-route-tables --filters Name=tag:type,Values="pcfjump" | \
        jq -r ".RouteTables[].RouteTableId")
    if [ "${rtb}" == "" ]; then
      rtb=$(aws ec2 --region=$AWS_REGION create-route-table --vpc-id $vpc| jq -r '.RouteTable.RouteTableId')
      messagePrint " - Creating Routing Table" "$igw"
      if [ "${sid}" == "" ]; then
        echo "ERROR: Creating of Routing Table failed"
        echo "       => aws ec2 --region=$AWS_REGION create-route-table"; exit 1
      fi

      aws ec2 --region=$AWS_REGION create-tags --resources $rtb --tags Key=type,Value=pcfjump > /dev/null 2>&1
      if [ $? -ne 0 ]; then
        echo "ERROR: Creating of Tags failed"
        echo "       => aws ec2 --region=$AWS_REGION create-tags --resources $rtb --tags Key=type,Value=pcfjump"; exit 1
      fi

      aws ec2 --region=$AWS_REGION create-route --route-table-id ärtb --destination-cidr-block 0.0.0.0/0 --gateway-id $igw
      #aws ec2 --region=$AWS_REGION describe-route-tables --route-table-id rtb-0483bed5665fd7eff

    else
      messagePrint " - Verify Internet Gateway" "$igw"
    fi

    for zone in $(aws ec2 --region=$AWS_REGION describe-availability-zones | jq -r '.AvailabilityZones[].ZoneName'); do
      sid=$(aws ec2 --region=$AWS_REGION describe-subnets --filters Name=tag:type,Values="pcfjump" \
          Name=availability-zone,Values=$zone | jq -r '.Subnets[].SubnetId')

      messagePrint " - Associate Routing Table $rtb" "Subnet $sid"
      aws ec2 --region=$AWS_REGION associate-route-table  --subnet-id $sid --route-table-id $rtb > /dev/null 2>&1
      aws ec2 --region=$AWS_REGION modify-subnet-attribute --subnet-id $sid --map-public-ip-on-launch > /dev/null 2>&1
    done

    # --- CREATE SECURITY GROUP ---
    gid=$(aws ec2 --region=$AWS_REGION  describe-security-groups \
                  --filters Name=vpc-id,Values=$vpc Name=group-name,Values=pcfjump-sg | jq -r ".SecurityGroups[].GroupId")
    if [ "${gid}" == "" -o "${gid}" == "null" ]; then
      gid=$(aws ec2 --region=$AWS_REGION create-security-group --group-name pcfjump-sg --vpc-id $vpc \
              --description "PCF Jump Server" 2>/dev/null | jq -r ".GroupId")
      messagePrint " - Creating Security Group (pcfjump-sg)" "$gid"
      if [ "${gid}" == "" ]; then
        echo "ERROR: Creating security Group failed"
        echo "       => aws ec2 --region=$AWS_REGION create-security-group --group-name pcfjump-sg \\"
        echo "                  --vpc-id $vpc --description \"PCF Jump Server\""; exit 1
      fi

      messagePrint " - Creating Security Group Ingress for ssh" "Port: tcp/22 Cidr: 0.0.0.0/0"
      aws ec2 --region=$AWS_REGION authorize-security-group-ingress --group-id $gid \
              --protocol tcp --port 22 --cidr 0.0.0.0/0 > /dev/null 2>&1
      if [ $? -ne 0 ]; then
        echo "ERROR: Creating security Group ingress failed"
        echo "       => aws ec2 --region=$AWS_REGION authorize-security-group-ingress --group-id $gid \\"
        echo "                  --protocol tcp --port 22 --cidr 0.0.0.0/0"; exit 1
      fi

    else
      messagePrint " - Verify Security Group (pcfjump-sg)" "$gid"
    fi

    aim=ami-0015c36f           # Amazon Linux  t2.nano
    aim=ami-0085d4f8878cddc81  # Ubunto Server t2.micro
    aim=ami-0085d4f8878cddc81  # Ubunto Server t2.medium
    ins=$(aws ec2 --region=$AWS_REGION describe-instances --filters "Name=instance-state-name,Values=pending,running,stopped" \
         Name=tag:type,Values="pcfjump" | jq -r ".Reservations[].Instances[].InstanceId" | head -1)
    if [ "${ins}" == "" ]; then
      messagePrint " - Create Instance" "pcfjump"
      aws ec2 --region=$AWS_REGION run-instances --image-id $aim --security-group-ids $gid \
             --instance-type t2.micro --key-name pcfjump --count 1 --subnet-id $sid --associate-public-ip-address \
             --tag-specifications 'ResourceType=instance,Tags=[{Key=type,Value=pcfjump}]'
      if [ $? -ne 0 ]; then
        echo "ERROR: Creating of Instance failed"
        echo "       => aws ec2 --region=$AWS_REGION run-instances --image-id $aim --security-groups pcfjump-sg \\"
        echo "                  --instance-type t2.nano --key-name pcfjump --subnet-id $sid \\"
        echo "                  --tag-specifications 'ResourceType=instance,Tags=[{Key=type,Value=pcfjump}]'"
        exit 1
      else
        sleep 300
      fi
    else
      stt=$(aws ec2 --region=$AWS_REGION describe-instances --instance-ids $ins | \
          jq -r ".Reservations[].Instances[].State.Name")
      messagePrint " - Verify Instance: $ins" "$stt"
      if [ "${stt}" == "stopped" ]; then
        messagePrint " - Starting Instance: $ins" ""
        aws ec2 --region=$AWS_REGION start-instances --instance-ids $ins > /dev/null 2>&1
        sleep 300
      fi
    fi

    ins=$(aws ec2 --region=$AWS_REGION describe-instances --filters "Name=instance-state-name,Values=pending,running,stopped" \
         Name=tag:type,Values="pcfjump" | jq -r ".Reservations[].Instances[].InstanceId" | head -1)
    stt=$(aws ec2 --region=$AWS_REGION describe-instances --instance-ids $ins | \
         jq -r ".Reservations[].Instances[].State.Name")
    dns=$(aws ec2 --region=$AWS_REGION describe-instances --instance-ids $ins | \
         jq -r ".Reservations[].Instances[].PublicDnsName")
    pip=$(aws ec2 --region=$AWS_REGION describe-instances --instance-ids $ins | \
         jq -r ".Reservations[].Instances[].PublicIpAddress")

    #ZONE_ID=$(aws route53 list-hosted-zones-by-name --dns-name ${ENV_NAME}.${DNS_DOMAIN} | jq -r '.HostedZones[0].Id')
    #ZONE_ID_STR=$(echo "${ZONE_ID}" | awk -F'/' '{ print $NF }')
    ZONE_ID=$(aws route53 list-hosted-zones-by-name --dns-name ${DNS_DOMAIN} | jq -r '.HostedZones[0].Id')
    ZONE_ID_STR=$(echo "${ZONE_ID}" | awk -F'/' '{ print $NF }')
    messagePrint " - DNS Zone (${DNS_DOMAIN}:" "zone managed by route53"
    messagePrint " - Updating Zone Record:" "$JUMP_HOST"

    # --- ROUTE53 TOKEN SPECIDIED ---
    if [ "${ROUTE53_TOKEN}" != "" ]; then

cat << EOF | sed -e "s/FQHN/$JUMP_HOST/g" -e "s/IPADDR/$pip/g" > /tmp/$$_zone_record
{
            "Comment": "CREATE/DELETE/UPSERT a record ",
            "Changes": [{
            "Action": "UPSERT",
                        "ResourceRecordSet": {
                                    "Name": "FQHN",
                                    "Type": "A",
                                    "TTL": 300,
                                 "ResourceRecords": [{ "Value": "IPADDR"}]
}}]
}
EOF
    fi

    echo "-----------------------------------------------------------------------------------------------------------"
    aws route53 change-resource-record-sets --hosted-zone-id "${ZONE_ID}" --change-batch file:///tmp/$$_zone_record
    echo "-----------------------------------------------------------------------------------------------------------"

  fi
}

cleanRoute53() {
  if [ "${ROUTE53_TOKEN}" != "" -a "${DNS_SUFFIX}" != "" ]; then 
    aws route53 list-hosted-zones-by-name --dns-name $DNS_SUFFIX --hosted-zone-id $ROUTE53_TOKEN > /dev/null 2>&1
    if [ $? -eq 0 ]; then
      TMPAWS=/tmp/$$_tmp_route54.json
      aws route53 list-hosted-zones-by-name --dns-name $ENV_NAME.$DNS_SUFFIX --hosted-zone-id $ROUTE53_TOKEN > $TMPAWS
      for zone in $(jq -r '.HostedZones[].Id' $TMPAWS); do
        messagePrint " - Deleting Route53 Zone:" "[$zone]" 
  
        aws route53 list-resource-record-sets --hosted-zone-id $zone | jq -c '.ResourceRecordSets[]' | \
        while read -r resourcerecordset; do
          read -r name type <<<$(echo $(jq -r '.Name,.Type' <<<"$resourcerecordset"))
  
           if [ $type != "NS" -a $type != "SOA" ]; then
              aws route53 change-resource-record-sets \
                --hosted-zone-id $zone \
                --change-batch '{"Changes":[{"Action":"DELETE","ResourceRecordSet":
                '"$resourcerecordset"'
              }]}' \
              --output text --query 'ChangeInfo.Id' >/dev/null 2>&1
           fi
        done
  
        aws route53 delete-hosted-zone --id $zone >/dev/null 2>&1
      done
    fi
  fi
}

cleanAWSenv() {
  # --- DELETE INSTANCES ---
  SECGRP=/tmp/$$_aws_routing_table.json
  aws --region $AWS_LOCATION ec2 describe-instances > $SECGRP
  tot=$(grep -c "InstanceId" $SECGRP); i=0; let tot=tot-1
echo xx1
cp $SECGRP /tmp/1
  while [ $i -le $tot ]; do
    gid=$(jq -r ".Reservations[$i].Instances[].InstanceId" 2>/dev/null $SECGRP)

    cnt=$(jq -r ".Reservations[$i].Instances[].Tags[].Value" 2>/dev/null $SECGRP | egrep -c "^${ENV_NAME}|p-bosh")
echo "xx1 =>  CNT:$cnt $GID:¨gid"
    if [ $cnt -gt 0 ]; then
      cnt=$(jq -r ".Reservations[$i].Instances[].State.Name" 2>/dev/null $SECGRP | egrep -c "terminated")
      if [ $cnt -eq 0 ]; then
        messagePrint " - Terminate Instance:" "$gid"
        aws --region $AWS_LOCATION ec2 terminate-instances --instance-ids $gid > /dev/null 2>&1
        if [ $? -ne 0 ]; then
          echo "ERROR: failled to Terminage Instance: $gid"
          echo "aws --region $AWS_LOCATION ec2 terminate-instances  --instance-ids $gid"
          exit 1
        fi

        sleep 60
      fi
    fi
    
    let i=i+1
  done
echo xx2

  # --- CLEANUP ---
  rm -f $SECGRP

  # --- IAM DELETE ROLES ---
  TMPAWS=/tmp/$$_aws.json
  aws --region $AWS_LOCATION iam list-instance-profiles > $TMPAWS
  tot=$(grep -c "InstanceProfileId" $TMPAWS); i=0; let tot=tot-1
  while [ $i -le $tot ]; do
echo xx21
    arn=$(jq -r ".InstanceProfiles[$i].InstanceProfileId" 2>/dev/null $TMPAWS)
    nam=$(jq -r ".InstanceProfiles[$i].InstanceProfileName" 2>/dev/null $TMPAWS)

    cnt=$(echo $nam | egrep -c "^${ENV_NAME}_")
    if [ $cnt -gt 0 ]; then
      messagePrint " - Delete IAM Instance Profile:" "$nam"
      for rol in $(jq -r ".InstanceProfiles[$i].Roles[].RoleName" 2>/dev/null $TMPAWS); do
        aws --region $AWS_LOCATION iam remove-role-from-instance-profile \
           --instance-profile-name $nam --role-name $rol 
      done

      aws --region $AWS_LOCATION iam delete-instance-profile --instance-profile-name $nam > /dev/null 2>&1
      if [ $? -ne 0 ]; then
        echo "ERROR: failled to delete IAM Instance Profile: $nam"
        echo "aws --region $AWS_LOCATION iam delete-instance-profile --instance-profile-name $nam"
        exit 1
      fi
    fi
    let i=i+1
  done
 
echo xx3
  # --- CLEANUP ---
  rm -f $TMPAWS

  # --- IAM DELETE ROLES ---
  TMPAWS=/tmp/$$_aws.json
  aws --region $AWS_LOCATION iam list-roles > $TMPAWS
  tot=$(grep -c "RoleName" $TMPAWS); i=0; let tot=tot-1
  while [ $i -le $tot ]; do
echo xx41
    arn=$(jq -r ".Roles[$i].RoleId" 2>/dev/null $TMPAWS)
    nam=$(jq -r ".Roles[$i].RoleName" 2>/dev/null $TMPAWS)

    cnt=$(echo $nam | egrep -c "^${ENV_NAME}_")
    if [ $cnt -gt 0 ]; then
      messagePrint " - Delete IAM Role:" "$nam"
      for pol in $(aws --region $AWS_LOCATION iam list-attached-role-policies --role-name $nam | \
          jq -r ".AttachedPolicies[].PolicyArn"); do

        aws --region $AWS_LOCATION iam detach-role-policy --role-name $nam --policy-arn $pol
      done

      aws --region $AWS_LOCATION iam delete-role --role-name $nam > /dev/null 2>&1
      if [ $? -ne 0 ]; then
        echo "ERROR: failled to delete IAM Role: $nam"
        echo "aws --region $AWS_LOCATION iam delete-role --role-name $nam"
        exit 1
      fi
    fi
    let i=i+1
  done
  
echo xx4
  # --- CLEANUP ---
  rm -f $TMPAWS

  # --- IAM DELETE USERS ---
  for arn in $(aws --region $AWS_LOCATION iam list-users | jq -r '.Users[].UserName' 2>/dev/null); do
    cnt=$(echo $arn | egrep -c "^${ENV_NAME}_")
    if [ $cnt -gt 0 ]; then
      messagePrint " - Cleaning up iam User:" "$arn"

      # --- DETACH POLICY ---
      for pol in $(aws --region $AWS_LOCATION iam list-attached-user-policies --user-name $arn | \
          jq -r ".AttachedPolicies[].PolicyArn"); do

        aws --region $AWS_LOCATION iam detach-user-policy --user-name $arn --policy-arn $pol
      done

      # --- DELETE POLICY ---
      for pol in $(aws --region $AWS_LOCATION iam list-attached-user-policies --user-name $arn | \
          jq -r ".AttachedPolicies[].PolicyName"); do

        aws --region $AWS_LOCATION iam delete-user-policy --user-name $arn --policy-name $pol
      done

      # --- DELETE ACCESS-KEYS ---
      for key in $(aws --region $AWS_LOCATION iam list-access-keys --user-name $arn | \
          jq -r ".AccessKeyMetadata[].AccessKeyId"); do

        aws --region $AWS_LOCATION iam delete-access-key --access-key-id $key --user-name $arn
      done

      aws --region $AWS_LOCATION iam delete-user --user-name $arn
      if [ $? -ne 0 ]; then
        echo "ERROR: failled to delete User"
        echo "aws --region $AWS_LOCATION iam delete-user --user-name $arn"
        exit 1
      fi
    fi
  done

echo xx5
#  # --- IAM DELETE POLICIES ---
#  for arn in $(aws --region $AWS_LOCATION iam list-policies | jq -r '.Policies[].Arn' 2>/dev/null); do
#echo "arn:$arn"
#echo "aws --region $AWS_LOCATION iam describe-policies --load-balancer-arns $arn"
#    nam=$(aws --region $AWS_LOCATION iam describe-policies --load-balancer-arns "$arn" | \
#        jq -r '.LoadBalancers[].LoadBalancerName')
#echo "nam:$nam"
#
#    cnt=$(echo $arn | egrep -c "^${ENV_NAME}_")
#    if [ $cnt -gt 0 ]; then
#echo "aws --region $AWS_LOCATION iam delete-policy --policy-arn $arn"
#      aws --region $AWS_LOCATION iam delete-policy --policy-arn $arn
#      messagePrint " - Cleaning up iam User:" "$arn"
#      if [ $? -ne 0 ]; then
#        echo "ERROR: failled to delete User"
#        echo "aws --region $AWS_LOCATION iam delete-user --user-name $arn"
#        exit 1
#      fi
#    fi
#  done


  # --- DELETE LOAD BALANCERS ---
  TMPAWS=/tmp/$$_aws.json
  for nam in $(aws --region $AWS_LOCATION elb describe-load-balancers | jq -r '.LoadBalancerDescriptions[].LoadBalancerName' 2>/dev/null); do
    cnt=$(aws --region $AWS_LOCATION elb describe-tags --load-balancer-name $nam | \
        jq -r '.TagDescriptions[].Tags[].Value' | grep -c "${ENV_NAME}")
    if [ $cnt -gt 0 ]; then
      aws --region $AWS_LOCATION elb delete-load-balancer --load-balancer-name $nam
      messagePrint " - Cleaning up elp LoadBalancers:" "$nam"
    fi
  done

  rm -f $TMPAWS
echo xx6

  # --- DELETE LOAD BALANCERS ---
  for arn in $(aws --region $AWS_LOCATION elbv2 describe-load-balancers | jq -r '.LoadBalancers[].LoadBalancerArn' 2>/dev/null); do
    nam=$(aws --region $AWS_LOCATION elbv2 describe-load-balancers --load-balancer-arns $arn | \
        jq -r '.LoadBalancers[].LoadBalancerName') 

    cnt=$(echo $nam | egrep -c "^${ENV_NAME}-")
    if [ $cnt -gt 0 ]; then 
      aws --region $AWS_LOCATION elbv2 delete-load-balancer --load-balancer-arn $arn
      messagePrint " - Cleaning up elpv2 LoadBalancers:" "$nam"
    fi
  done

echo xx7
  # --- DELETE TARGET GROUPS ---
  SECGRP=/tmp/$$_aws_tgp.json
  aws --region $AWS_LOCATION elbv2 describe-target-groups > $SECGRP
  tot=$(grep -c "TargetGroupArn" $SECGRP); i=0; let tot=tot-1
  while [ $i -le $tot ]; do
    sid=$(jq -r ".TargetGroups[$i].TargetGroupArn" 2>/dev/null $SECGRP)
    snm=$(jq -r ".TargetGroups[$i].TargetGroupName" 2>/dev/null $SECGRP)

    cnt=$(echo "$snm" | egrep -c "^${ENV_NAME}-")
    if [ $cnt -gt 0 ]; then
      messagePrint " - Delete Target Group:" "$sid"
      aws --region $AWS_LOCATION elbv2 delete-target-group --target-group-arn $sid > /dev/null 2>&1
      if [ $? -ne 0 ]; then
        echo "ERROR: failled to delete Target group"
        echo "aws --region $AWS_LOCATION elbv2 delete-target-group --target-group-arn $sid"
        exit 1
      fi
    fi
    let i=i+1
  done

  # --- CLEANUP ---
  rm -f $SECGRP
echo xx8

  for key in $(aws --region $AWS_LOCATION ec2 describe-key-pairs | jq -r '.KeyPairs[].KeyName' 2>/dev/null); do
    cnt=$(echo $key | egrep -c "^${ENV_NAME}-")
    if [ $cnt -gt 0 ]; then 
      messagePrint " - Deeleting KeyPair:" "$key"
      aws --region $AWS_LOCATION ec2 delete-key-pair --key-name $key >/dev/null 2>&1
      if [ $? -ne 0 ]; then
        aws --region $AWS_LOCATION ec2 delete-key-pair --key-name $key
        exit 1
      fi
    fi
  done

echo xx9
  # --- DELETE VPC's ---
  TMPVCP=/tmp/$$_aws_vpc.json
  aws --region $AWS_LOCATION ec2 describe-vpcs > $TMPVCP
  tot=$(grep -c "VpcId" $TMPVCP); i=0; let tot=tot-1
  while [ $i -le $tot ]; do
    vpc=$(jq -r ".Vpcs[$i].VpcId" 2>/dev/null $TMPVCP)
    cnt=$(jq -r ".Vpcs[$i].Tags[].Value" 2>/dev/null $TMPVCP | egrep -c "^${ENV_NAME}")
    if [ $cnt -eq 0 ]; then let i=i+1; continue; fi
echo xx91

    # --- DELETE SECURITY GROUPS BY ID ---
#    for id in $(aws --region $AWS_LOCATION ec2 describe-security-groups --filter "Name=vpc-id,Values=$vpc" | \
#                jq -r ".SecurityGroups[].GroupId" 2>/dev/null $TMPVAL); do
#
#      messagePrint " - Delete Security Group:" "$id"
#      aws --region $AWS_LOCATION ec2 delete-security-group --group-id $id > /dev/null 2>&1
#      if [ $? -ne 0 ]; then
#        echo "ERROR: failled to Security Group:: $id"
#        echo "aws --region $AWS_LOCATION ec2 delete-security-group --group-id $id"
#        exit 1
#      fi
#    done
#
#    for id in $(aws --region $AWS_LOCATION ec2 describe-security-groups --filter "Name=vpc-id,Values=$vpc" | \
#                jq -r ".SecurityGroups[].GroupName" 2>/dev/null $TMPVAL); do
#
#      messagePrint " - Delete Security Group:" "$id"
#      aws --region $AWS_LOCATION ec2 delete-security-group --group-name $id > /dev/null 2>&1
#      if [ $? -ne 0 ]; then
#        echo "ERROR: failled to Security Group:: $id"
#        echo "aws --region $AWS_LOCATION ec2 delete-security-group --group-name $id"
#        exit 1
#      fi
#    done

    # --- DELETE NAT GATEWAY ---
#    for id in $(aws --region $AWS_LOCATION ec2 describe-network-acls --filter "Name=vpc-id,Values=$vpc" | \
#                jq -r ".NetworkAcls[].NetworkAclId" 2>/dev/null $TMPVAL); do
#
#      messagePrint " - Delete Network ACL:" "$id"
#      aws --region $AWS_LOCATION ec2 delete-network-acl --network-acl-id $id > /dev/null 2>&1
#      if [ $? -ne 0 ]; then
#        echo "ERROR: failled to Network ACL: $id"
#        echo "aws --region $AWS_LOCATION ec2 delete-network-acl --network-acl-id $id"
#        #exit 1
#      fi
#    done

    # --- DELETE NAT GATEWAY ---
    for id in $(aws --region $AWS_LOCATION ec2 describe-nat-gateways --filter "Name=vpc-id,Values=$vpc" | \
                jq -r ".NatGateways[].NatGatewayId" 2>/dev/null $TMPVAL); do

      messagePrint " - Delete NAT Gateway:" "$id"
      aws --region $AWS_LOCATION ec2 delete-nat-gateway --nat-gateway-id $id > /dev/null 2>&1
      if [ $? -ne 0 ]; then
        echo "ERROR: failled to NAT Gateway: $id"
        echo "aws --region $AWS_LOCATION ec2 delete-nat-gateway --nat-gateway-id $id"
        #exit 1
      fi
    done

echo xx92
    sleep 10

    # --- DELETE NETWORK INTERFACVE ---
#    for id in $(aws --region $AWS_LOCATION ec2 describe-network-interfaces --filter "Name=vpc-id,Values=$vpc" | \
#                jq -r ".NetworkInterfaces[].NetworkInterfaceId" 2>/dev/null $TMPVAL); do
#
#      messagePrint " - Delete Network Interface:" "$id"
#      aws --region $AWS_LOCATION ec2 delete-network-interface --network-interface-id $id > /dev/null 2>&1
#      if [ $? -ne 0 ]; then
#        echo "ERROR: failled to Network Interface:: $id"
#        echo "aws --region $AWS_LOCATION ec2 delete-network-interface --network-interface-id $id"
#        exit 1
#      fi
#    done

    sleep 60

echo xx93
    # --- DELETE ADDRESSES ---
    SECGRP=/tmp/$$_aws_routing_table.json
    aws --region $AWS_LOCATION ec2 describe-addresses > $SECGRP
    tot=$(grep -c "PublicIp" $SECGRP); i=0; let tot=tot-1
    while [ $i -le $tot ]; do
      pid=$(jq -r ".Addresses[$i].PublicIp" 2>/dev/null $SECGRP)
      aid=$(jq -r ".Addresses[$i].AllocationId" 2>/dev/null $SECGRP)

      cnt=$(jq -r ".Addresses[$i].Tags[].Value" 2>/dev/null $SECGRP | egrep -c "^${ENV_NAME}")
      if [ $cnt -gt 0 ]; then
        messagePrint " - Release PublicIP:" "$pid"
        aws --region $AWS_LOCATION ec2 release-address --allocation-id $aid > /dev/null 2>&1; re1=$?
        aws --region $AWS_LOCATION ec2 release-address --public-ip $pid > /dev/null 2>&1; re2=$?
        if [ $re1 -ne 0 -a $re2 -ne 0 ]; then
          echo "ERROR: failed to release IP: $pid"
          echo "aws --region $AWS_LOCATION ec2 release-address --allocation-id $aid"
          echo "aws --region $AWS_LOCATION ec2 release-address --public-ip $pid"
          exit 1
        fi

        sleep 20
      fi

      let i=i+1
    done

echo xx94
    # --- CLEANUP ---
    rm -f $TMPAWS

    # --- DELETE LOAD BALANCERS ---
    for nam in $(aws --region $AWS_LOCATION elb describe-load-balancers | \
         jq -r '.LoadBalancerDescriptions[].LoadBalancerName' 2>/dev/null); do
      tvpc=$(aws --region $AWS_LOCATION elb describe-load-balancers --load-balancer-name $nam | \
          jq -r '.LoadBalancerDescriptions[].VPCId')
      if [ "$tvpc" == "${vpc}" ]; then
        aws --region $AWS_LOCATION elb delete-load-balancer --load-balancer-name $nam
        messagePrint " - Cleaning up elp LoadBalancers:" "$nam"
        sleep 30
      fi
    done

echo xx95
    # --- DELETE INTERNET GATEWAYS ---
    for id in $(aws --region $AWS_LOCATION ec2 describe-internet-gateways --filter "Name=attachment.vpc-id,Values=$vpc" | \
                jq -r ".InternetGateways[].InternetGatewayId" 2>/dev/null); do

      messagePrint " - Detach Internet Gateway:" "$id"
      aws --region $AWS_LOCATION ec2 detach-internet-gateway --internet-gateway-id $id --vpc-id $vpc > /dev/null 2>&1
      if [ $? -ne 0 ]; then
        echo "ERROR: failled to detach internet gateway: $id"
        echo "aws --region $AWS_LOCATION ec2 detach-internet-gateway --internet-gateway-id $id --vpc-id $vpc"
        exit 1
      fi

      messagePrint " - Delete Internet Gateway:" "$id"
      aws --region $AWS_LOCATION ec2 delete-internet-gateway --internet-gateway-id $id > /dev/null 2>&1
      if [ $? -ne 0 ]; then
        echo "ERROR: failled to delete internet gateway: $id"
        echo "aws --region $AWS_LOCATION ec2 delete-internet-gateway --internet-gateway-id $id"
        exit 1
      fi
    done
echo xx96

    # --- DELETE SUBNETS ---
    for id in $(aws --region $AWS_LOCATION ec2 describe-subnets --filter "Name=vpc-id,Values=$vpc" | \
                jq -r ".Subnets[].SubnetId" 2>/dev/null); do

      messagePrint " - Delete Subnet:" "$id"
      aws --region $AWS_LOCATION ec2 delete-subnet --subnet-id $id > /dev/null 2>&1
      if [ $? -ne 0 ]; then
        echo "ERROR: failled to deleting subnet: $id"
        echo "aws --region $AWS_LOCATION ec2 delete-subnet --subnet-id $id"
        exit 1
      fi
    done

echo xx97
    SECGRP=/tmp/$$_aws_security_groups.json
    aws --region $AWS_LOCATION ec2 describe-security-groups --filter "Name=vpc-id,Values=$vpc" > $SECGRP
    tot=$(grep -c "GroupName" $SECGRP); i=0; let tot=tot-1
    while [ $i -le $tot ]; do
      gnm=$(jq -r ".SecurityGroups[$i].GroupName" 2>/dev/null $SECGRP)
      gid=$(jq -r ".SecurityGroups[$i].GroupId" 2>/dev/null $SECGRP)

      cnt=$(jq -r ".SecurityGroups[$i].Tags[].Value" 2>/dev/null $SECGRP | egrep -c "^${ENV_NAME}")
      if [ $cnt -gt 0 ]; then
        messagePrint " - Delete Sevcurity Group:" "$gnm"
        aws --region $AWS_LOCATION ec2 delete-security-group --group-id $gid > /dev/null 2>&1
        if [ $? -ne 0 ]; then
          aws --region $AWS_LOCATION ec2 delete-security-group --group-name $gnm > /dev/null 2>&1
          if [ $? -ne 0 ]; then
            echo "ERROR: failled to delete security group"
            echo "aws --region $AWS_LOCATION ec2 delete-security-group --group-id $gid"
            echo "aws --region $AWS_LOCATION ec2 delete-security-group --group-name $gnm"
            exit 1
          fi
        fi
      fi
      let i=i+1
    done

    # --- DELETE ALL SCURITY GROUPS ATTACHED TO THIS VPC ---
    for gid in $(aws --region $AWS_LOCATION ec2 describe-security-groups | \
         jq -r '.SecurityGroups[].GroupId' 2>/dev/null); do
      sgnm=$(aws --region $AWS_LOCATION ec2 describe-security-groups --group-ids  $gid | \
          jq -r '.SecurityGroups[].GroupName')
      tvpc=$(aws --region $AWS_LOCATION ec2 describe-security-groups --group-ids  $gid | \
          jq -r '.SecurityGroups[].VpcId')
      if [ "$tvpc" == "${vpc}" -a "${sgnm}" != "default" ]; then
        messagePrint " - Cleaning up SecurityGroup:" "$gid"
        aws --region $AWS_LOCATION ec2 delete-security-group --group-id $gid > /dev/null 2>&1
        if [ $? -ne 0 ]; then
          echo "ERROR: failled to delete security group"
          echo "aws --region $AWS_LOCATION ec2 delete-security-group --group-id $gid"
          exit 1
        fi
      fi

      sleep 30
    done

    # --- CLEANUP ---
    rm -f $SECGRP

    # --- DELETE IP-ADDRESS ---
#    for id in $(aws --region $AWS_LOCATION ec2 describe-route-tables --filter "Name=vpc-id,Values=$vpc" | \
#                jq -r ".RouteTables[].RouteTableId" 2>/dev/null); do
#
#      messagePrint " - Delete Routing Table:" "$id"
#
#      aws --region $AWS_LOCATION ec2 delete-route-table --route-table-id $id> /dev/null 2>&1
#      if [ $? -ne 0 ]; then
#        echo "ERROR: failled to delete routing table: $id"
#        echo "aws --region $AWS_LOCATION ec2 delete-route-table --route-table-id $id"
#        #exit 1
#      fi
#    done

    # --- DELETE ROUTING TABLES ---
    for id in $(aws --region $AWS_LOCATION ec2 describe-route-tables --filter "Name=vpc-id,Values=$vpc" | \
                jq -r ".RouteTables[].RouteTableId" 2>/dev/null); do

      messagePrint " - 1Delete Routing Table:" "$id"
      aws --region $AWS_LOCATION ec2 delete-route-table --route-table-id $id> /dev/null 2>&1
      #if [ $? -ne 0 ]; then
      #  echo "ERROR: failled to delete routing table: $id"
      #  echo "aws --region $AWS_LOCATION ec2 delete-route-table --route-table-id $id"
      #  #exit 1
      #fi
    done

    # --- DELETE VPC ---
    messagePrint " - Delete VPC:" "$vpc"
    aws --region $AWS_LOCATION ec2 delete-vpc --vpc-id $vpc > /dev/null 2>&1
    if [ $? -ne 0 ]; then
      echo "ERROR: failled to delete VPC: $vpc"
      echo "aws --region $AWS_LOCATION ec2 delete-vpc --vpc-id $vpc"
      exit 1
    fi

    let i=i+1
  done

  # --- CLEANUP ---
  rm -f $TMPVCP
#xxxxxxxxxxxxxx END

  SECGRP=/tmp/$$_aws_routing_table.json
  aws --region $AWS_LOCATION ec2 describe-route-tables > $SECGRP
  tot=$(grep -c "RouteTableId" $SECGRP); i=0; let tot=tot-1
  while [ $i -le $tot ]; do
    gid=$(jq -r ".RouteTables[$i].RouteTableId" 2>/dev/null $SECGRP)

    cnt=$(jq -r ".RouteTables[$i].Tags[].Value" 2>/dev/null $SECGRP | egrep -c "^${ENV_NAME}")
    if [ $cnt -gt 0 ]; then
      messagePrint " - Delete Routing Table:" "$gid"
      aws --region $AWS_LOCATION ec2 delete-route-table --group-id $gid > /dev/null 2>&1
      if [ $? -ne 0 ]; then
        echo "ERROR: failled to delete Routing Table: $gid"
        echo "aws --region $AWS_LOCATION ec2 delete-route-table --route-table-id $gid"
        exit 1
      fi
    fi
    let i=i+1
  done

  # --- CLEANUP ---
  rm -f $SECGRP

  SECGRP=/tmp/$$_aws_nat_gateways.json
  aws --region $AWS_LOCATION ec2 describe-nat-gateways > $SECGRP
  tot=$(grep -c "GroupName" $SECGRP); i=0; let tot=tot-1
  while [ $i -le $tot ]; do
    gid=$(jq -r ".NatGateways[$i].NatGatewayId" 2>/dev/null $SECGRP)

    cnt=$(jq -r ".NatGateways[$i].Tags[].Value" 2>/dev/null $SECGRP | egrep -c "^${ENV_NAME}")
    if [ $cnt -gt 0 ]; then
      messagePrint " - Delete NAT Gateway:" "$gid"
      aws --region $AWS_LOCATION ec2 delete-nat-gateway --group-id $gid > /dev/null 2>&1
      if [ $? -ne 0 ]; then
        aws --region $AWS_LOCATION ec2 delete-nat-gateway --nat-gateway-id $gid > /dev/null 2>&1
        if [ $? -ne 0 ]; then
          echo "ERROR: failled to delete NAT Gateway: $gid"
          echo "aws --region $AWS_LOCATION ec2 delete-nat-gateway --group-id $gid"
          exit 1
        fi
      fi
    fi
    let i=i+1
  done

  # --- CLEANUP ---
  rm -f $SECGRP

  SECGRP=/tmp/$$_aws_security_groups.json
  aws --region $AWS_LOCATION ec2 describe-security-groups > $SECGRP
  tot=$(grep -c "GroupName" $SECGRP); i=0; let tot=tot-1
  while [ $i -le $tot ]; do
    gnm=$(jq -r ".SecurityGroups[$i].GroupName" 2>/dev/null $SECGRP)
    gid=$(jq -r ".SecurityGroups[$i].GroupId" 2>/dev/null $SECGRP)
#gugu

    cnt=$(jq -r ".SecurityGroups[$i].Tags[].Value" 2>/dev/null $SECGRP | egrep -c "^${ENV_NAME}")
    if [ $cnt -gt 0 ]; then 
      messagePrint " - Delete Sevcurity Group:" "$gnm"
      aws --region $AWS_LOCATION ec2 delete-security-group --group-id $gid > /dev/null 2>&1
      if [ $? -ne 0 ]; then 
        aws --region $AWS_LOCATION ec2 delete-security-group --group-name $gnm > /dev/null 2>&1
        if [ $? -ne 0 ]; then 
          echo "ERROR: failled to delete security group"
          echo "aws --region $AWS_LOCATION ec2 delete-security-group --group-id $gid"
          echo "aws --region $AWS_LOCATION ec2 delete-security-group --group-name $gnm"
          exit 1
        fi
      fi
    fi
    let i=i+1
  done

  # --- CLEANUP ---
  rm -f $SECGRP

  SECGRP=/tmp/$$_aws_subnets.json
  aws --region $AWS_LOCATION ec2 describe-subnets > $SECGRP
  tot=$(grep -c "SubnetId" $SECGRP); i=0; let tot=tot-1
  while [ $i -le $tot ]; do
    sid=$(jq -r ".Subnets[$i].SubnetId" 2>/dev/null $SECGRP)

    cnt=$(jq -r ".Subnets[$i].Tags[].Value" 2>/dev/null $SECGRP | egrep -c "^${ENV_NAME}")
    if [ $cnt -gt 0 ]; then
      messagePrint " - Delete Subnet:" "$sid"
      aws --region $AWS_LOCATION ec2 delete-subnet --subnet-id $sid > /dev/null 2>&1
      if [ $? -ne 0 ]; then
        echo "ERROR: failled to delete security group"
        echo "aws --region $AWS_LOCATION ec2 delete-subnet --subnet-id $sid"
        exit 1
      fi
    fi
    let i=i+1
  done

  # --- CLEANUP ---
  rm -f $SECGRP

  # --- DELETE ADDRESSES ---
  SECGRP=/tmp/$$_aws_routing_table.json
  aws --region $AWS_LOCATION ec2 describe-addresses > $SECGRP
  tot=$(grep -c "PublicIp" $SECGRP); i=0; let tot=tot-1
  while [ $i -le $tot ]; do
    pid=$(jq -r ".Addresses[$i].PublicIp" 2>/dev/null $SECGRP)
    aid=$(jq -r ".Addresses[$i].AllocationId" 2>/dev/null $SECGRP)

    cnt=$(jq -r ".Addresses[$i].Tags[].Value" 2>/dev/null $SECGRP | egrep -c "^${ENV_NAME}")
    if [ $cnt -gt 0 ]; then
      messagePrint " - Release PublicIP:" "$pid"
      aws --region $AWS_LOCATION ec2 release-address --allocation-id $aid > /dev/null 2>&1; re1=$?
      aws --region $AWS_LOCATION ec2 release-address --public-ip $pid > /dev/null 2>&1; re2=$?
      if [ $re1 -ne 0 -a $re2 -ne 0 ]; then
        echo "ERROR: failed to release IP: $pid"
        echo "aws --region $AWS_LOCATION ec2 release-address --allocation-id $aid"
        echo "aws --region $AWS_LOCATION ec2 release-address --public-ip $pid"
        exit 1
      fi

      sleep 20
    fi
   
    let i=i+1
  done

  # --- CLEANUP ---
  rm -f $TMPAWS

  # --- IAM DELETE POLICIES ---
  TMPAWS=/tmp/$$_aws.json
  aws --region $AWS_LOCATION iam list-policies > $TMPAWS
  tot=$(grep -c "PolicyName" $TMPAWS); i=0; let tot=tot-1
  while [ $i -le $tot ]; do
    arn=$(jq -r ".Policies[$i].Arn" 2>/dev/null $TMPAWS)
    nam=$(jq -r ".Policies[$i].PolicyName" 2>/dev/null $TMPAWS)

    cnt=$(echo $nam | egrep -c "^${ENV_NAME}_")
    if [ $cnt -gt 0 ]; then
      messagePrint " - Delete IAM Policy:" "$nam"

      aws --region $AWS_LOCATION iam delete-policy --policy-arn $arn > /dev/null 2>&1
      if [ $? -ne 0 ]; then
        echo "ERROR: failled to delete IAM Policy: $nam"
        echo "aws --region $AWS_LOCATION iam delete-policy --policy-arn $arn"
        exit 1
      fi
    fi
    let i=i+1
  done

  # --- CLEANUP ---
  rm -f $SECGRP
}

cleanGCPenv() {
  # --- DELETE IMAGES ---
  for n in $(gcloud compute images list 2>/dev/null | \
        egrep "^$ENV_NAME" | awk '{ print $1 }'); do

    messagePrint " - Cleaning up GCP Image:" "$n"
    gcloud compute images delete ${n} -q > /dev/null 2>&1
    if [ $? -ne 0 ]; then
      gcloud compute images delete ${n} -q
      exit 1
    fi
  done

  # --- DELETE INSTANCES ---
  for n in $(gcloud compute instances list --filter="zone:($GCP_REGION)" 2>/dev/null | \
        grep -v "NAME" | awk '{ printf("%s:%s\n",$1,$2)}'); do

    nam=$(echo $n | awk -F: '{ print $1 }')
    zon=$(echo $n | awk -F: '{ print $2 }')
    messagePrint " - Cleaning up GCP Instance:" "$n"
    gcloud compute instances delete ${nam} --zone ${zon} -q > /dev/null 2>&1
    if [ $? -ne 0 ]; then 
      gcloud compute instances delete ${nam} --zone ${zon} -q
      exit 1
    fi
  done

  # --- DELETE MANAGED ZONES ---
  for zone in $(gcloud dns managed-zones list 2>/dev/null | \
      egrep "^$ENV_NAME" | awk '{ print $1 }'); do

    rm -f /tmp/$$_tmp; touch /tmp/$$_tmp
    gcloud dns record-sets import --delete-all-existing -z $zone /tmp/$$_tmp >/dev/null 2>&1
    gcloud dns managed-zones delete $zone >/dev/null 2>&1
  done

  for n in $(gcloud compute networks subnets list --filter="region:($GCP_REGION)" 2>/dev/null | \
    egrep "^$ENV_NAME" | awk '{ print $1 }'); do

    messagePrint " - Cleaning up GCP Subnet:" "$n"
    gcloud compute networks subnets delete $n --region=$GCP_REGION -q 2>/dev/null
    if [ $? -ne 0 ]; then 
      gcloud compute networks subnets delete $n --region=$GCP_REGION -q
      exit 1
    fi
  done

  # --- DELETE FIREWALL RULES ---
  #for n in $(gcloud compute firewall-rules list --filter="region:($GCP_REGION)" 2>/dev/null | \
  for n in $(gcloud compute firewall-rules list 2>/dev/null | \
      egrep "^$ENV_NAME" 2>/dev/null | awk '{ print $1 }'); do

    messagePrint " - Cleaning up GCP firewall-tules:" "$n"
    gcloud compute firewall-rules delete $n -q 2>/dev/null
    if [ $? -ne 0 ]; then 
      gcloud compute firewall-rules delete $n -q
      exit 1
    fi
  done

  for net in $(gcloud compute networks list 2>/dev/null | \
      egrep "^$ENV_NAME" 2>/dev/null | awk '{ print $1 }'); do

    messagePrint " - Cleaning up GCP Network:" "$net"
    gcloud compute networks delete $net -q 2>/dev/null
    if [ $? -ne 0 ]; then 
      gcloud compute networks delete $net -q
      exit 1
    fi
  done

  for n in $(gcloud iam service-accounts list 2>/dev/null | \
      grep -v "EMAIL" | egrep "^$ENV_NAME" | awk '{ print $(NF-1) }'); do

    messagePrint " - Cleaning up GCP Service Account:" "$n"
    gcloud iam service-accounts delete $n -q 2>/dev/null
  done

  for n in $(gcloud compute backend-services list --filter="region:($GCP_REGION)" 2>/dev/null | \
       egrep "^$ENV_NAME" | awk '{ print $1 }'); do

    messagePrint " - Cleaning up GCP backend-services:" "$n"
    gcloud compute forwarding-rules delete $n -q 2>/dev/null
  done

  for n in $(gcloud compute forwarding-rules list --filter="region:($GCP_REGION)" 2>/dev/null | \
       egrep "^$ENV_NAME" | awk '{ print $1 }'); do

    messagePrint " - Cleaning up GCP forwarding-rules:" "$n"
    gcloud compute forwarding-rules delete $n -q --region $GCP_REGION 2>/dev/null
  done

  for n in $(gcloud compute addresses list --filter="region:($GCP_REGION)" 2>/dev/null | \
       egrep "^$ENV_NAME" | awk '{ print $1 }'); do

    messagePrint " - Cleaning up GCP Addresses:" "$n"
    gcloud compute addresses delete $n -q --region $GCP_REGION 2>/dev/null
  done

  for n in $(gcloud compute health-checks list --filter="region:($GCP_REGION)" 2>/dev/null | \
      egrep "^$ENV_NAME" | awk '{ print $1 }'); do

    messagePrint " - Cleaning up GCP health-checks:" "$n"
    gcloud compute health-checks delete $n -q --region $GCP_REGION 2>/dev/null
  done

  for n in $(gcloud compute url-maps list --filter="region:($GCP_REGION)" 2>/dev/null | \
      egrep "^$ENV_NAME" | awk '{ print $1 }'); do

    messagePrint " - Cleaning up GCP url-maps:" "$n"
    gcloud compute url-maps delete $n -q --region $GCP_REGION 2>/dev/null
  done

  for n in $(gcloud compute target-pools list --filter="region:($GCP_REGION)" 2>/dev/null | \
      egrep "^$ENV_NAME" | awk '{ print $1 }'); do

    messagePrint " - Cleaning up GCP target-pools:" "$n"
    gcloud compute target-pools delete $n -q --region $GCP_REGION 2>/dev/null
  done

  #gcloud compute backend-services list --filter="region:($GCP_REGION)"
  #gcloud compute target-tcp-proxies list
  #gcloud compute target-http-proxies list
}

checkOpsMantools() {
  # --- CHECK FOR OM UTILITY ---
  OM=$(which om)
  if [ "${OM}" == "" ]; then
    echo ""
    echo "ERROR: please install the om utility from https://github.com/pivotal-cf/om"; exit 0
  else
    # --- TEST FOR WORKING OM UTILITY ---
    OM_VERSION=$($OM version 2>/dev/null); ret=$?
    if [ ${ret} -ne 0 -o "${OM_VERSION}" == "" ]; then
      echo ""
      echo "ERROR: The om utility $(which om) does not seam to be correct"
      echo "       please install the om utility from https://github.com/pivotal-cf/om"; exit 0
    else
      messagePrint "checking for the om utility" "Installed - ${OM_VERSION}"
    fi
  fi

  # --- CHECK FOR JQ UTILITY ---
  JQ=$(which jq)
  if [ "${JQ}" == "" ]; then
    echo ""
    echo "ERROR: please install the jq utility from https://stedolan.github.io/jq/download"; exit 0
  else
    # --- TEST FOR WORKING JQ UTILITY ---
    JQ_VERSION=$(JQ -V 2>/dev/null); ret=$?
    if [ "$($JQ -V | egrep -c '^jq-')" -eq 1 -a "$(echo '{"foo": 42}' | jq .foo)" != "42" ]; then
      echo ""
      echo "ERROR: the jq utility $(which jq) does not seam to be correct"
      echo "       please install the om utility from https://stedolan.github.io/jq/download/"; exit 0
    else
      messagePrint "checking for the jq utility" "Installed - ${JQ_VERSION}"
    fi
  fi

  # --- CHECK FOR TERRAFORMS ---
  TF=$(which terraform)
  if [ "${TF}" == "" ]; then
    echo ""
    echo "ERROR: please install the terraform from https://www.terraform.io/downloads.html"; exit 0
  else
    # --- TEST FOR WORKING JQ UTILITY ---
    TF_VERSION=$($TF -v 2>/dev/null | head -1 | awk '{ print $2 }'); ret=$?
    if [ ${ret} -ne 0 -o "${TF_VERSION}" == "" ]; then
      echo ""
      echo "ERROR: the terraform $(which terraform) does not seam to be correct"
      echo "       please install terraform from https://www.terraform.io/downloads.html"; exit 0
    else
      messagePrint "checking for the terraform " "Installed - ${TF_VERSION}"
    fi
  fi
}

checkCloudCLI() {
  if [ "${cloud}" == "GCP" -o "${TF_DEPLOYMENT}" == "gcp" ]; then
    # --- CHECK FOR AWS CLI ---
    GCLOUD=$(which gcloud)
    if [ "${GCLOUD}" != "" ]; then
      $GCLOUD --version >/dev/null 2>&1; ret=$?
      if [ ${ret} -eq 0 ]; then
        GCLOUD_VERSION=$($GCLOUD --version 2>/dev/null | grep "Google Cloud SDK" | awk '{ print $NF}')
        GCP_CLI_ENABLED=1
        messagePrint "checking for gcloud CLI utility" "installed - ${GCLOUD_VERSION}"
      else
        echo ""
        echo "ERROR: The gcloud utility does not seam to be correct"
        echo "       please install gcloud from https://cloud.google.com/sdk/install"; exit 1
      fi
    else
      messagePrint "checking for gcloud CLI utility" "not installed"
      echo ""
      echo "ERROR: gcloud utility is not installed. please install terraform from"
      echo "       https://cloud.google.com/sdk/install"; exit 1
    fi
  fi

  if [ "${cloud}" == "AWS" -o "${TF_DEPLOYMENT}" == "aws" ]; then
    # --- CHECK FOR AWS CLI ---
    AWSCLI=$(which aws)
    if [ "${AWSCLI}" != "" ]; then
      $AWSCLI --version >/dev/null 2>&1; ret=$?
      if [ ${ret} -eq 0 ]; then
        AWS_VERSION=$($AWSCLI --version 2>/dev/null | awk -F'/' '{ print $2 }' | awk '{ print $1}')
        AWS_CLI_ENABLED=1
        messagePrint "checking for AWS CLI utility" "installed - ${AWS_VERSION}"
      else
        echo ""
        echo "ERROR: the AWS cli utility does not seam to be correct, please reinstall it from:"
        echo "       https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html"; exit 1
      fi
    else
      messagePrint "checking for AWS CLI utility" "not installed"
      echo "ERROR: the AWS cli utility is not installed, please install it from:"
      echo "       https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html"; exit 1
    fi
  fi

  if [ "${cloud}" == "Azure" -o "${TF_DEPLOYMENT}" == "azure" ]; then
    # --- CHECK FOR AWS CLI ---
    AZCLI=$(which az)
    if [ "${AZCLI}" != "" ]; then
      $AZCLI -v >/dev/null 2>&1; ret=$?
      if [ ${ret} -eq 0 ]; then
        AZ_VERSION=$($AZCLI -v 2>/dev/null | egrep "^azure-cli" | awk '{ print $2 }'); ret=$?
        AZURE_CLI_ENABLED=1
        messagePrint "checking for $cloud CLI utility" "installed - ${AZ_VERSION}"
      else
        echo ""
        echo "ERROR: the $cloud CLI $(which az) does not seam to be correct"
        echo "       please install it from https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest"; exit 1
      fi
    else
      messagePrint "checking for $cloud CLI utility" "no installed"
    fi
  fi
}

wait_loop() {
  TIME=$1
  MESSAGE="$2"
  echo -e "$2 \c"

  n=1
  while [ $n -le $TIME ]; do
    str=$(printf "[%03d/%03d]" $n $TIME)
    echo -e ". $str\c"
    sleep 1
    echo -e "\b\b\b\b\b\b\b\b\b\b\c       "
    let n=n+1
  done

  echo -e "\n"
}

messagePrint() {
  msg="$1"
  stt="$2"
  cnt=$(echo "${msg}" | wc -c | sed 's/ //g')

  str=""
  while [ $cnt -lt 58 ]; do
    str="${str}."
    let cnt=cnt+1
  done
  echo "${msg} ${str}: ${stt}"
}

