BITMASK_JMP=0x01
BITMASK_OPS=0x02
BITMASK_PXS=0x04
BITMASK_K8S=0x08

setPCFconfigState() {
  dirname=$(dirname $1)
  if [ -d $dirname ]; then 
    echo "$2" > $1
  fi
}

getPCFconfigState() {
  if [ -f "$1" ]; then 
    read x < $1
    echo $x
  else
    echo ""
  fi
}

demo_usage() {
  echo "USAGE: $0 [options]"
  echo "             Demo Settings"
  echo "                       --run-interactive          - Run Demo in Interactive Mode"
  echo "                       --run-unattended           - Run Demo in Unattended Mode"
  echo "                       --dry-run                  - List Available deployments"
}

verifyEnvVariables() {
a=1
}

debugInfos() {
  MASK=$1

  sshEnvironment

  echo ""
  echo "######################################################################################################"
  echo "############################################ DEBUG INFOS #############################################"
  echo "######################################################################################################"
  TMP_OPSMAN="$(pwd)/opsman.pem"
  API_HOST_NAME=api.pks.${PCF_DEPLOYMENT_ENV_NAME}.${AWS_HOSTED_DNS_DOMAIN}

  if [ $(($MASK & $BITMASK_JMP)) -gt 0 ]; then 
    echo "ACCESSING THE JUMP-HOST"
    echo "=> $SSH_COMMAND"
    echo ""
  fi

  if [ $(($MASK & $BITMASK_OPS)) -gt 0 ]; then 
    echo "ACCESSING THE OPS-MANAGER (VIA JUMP-HOST) "
    echo "=> ssh -qi $TMP_OPSMAN ubuntu@${OPS_MANAGER_DNS} "
    echo "=> . /tmp/debug.sh"
    echo ""
  fi

  if [ $(($MASK & $BITMASK_PXS)) -gt 0 ]; then 
    echo "LOGIN TO PKS"
    echo "=> pks login -u ${PCF_TILE_PKS_ADMIN_USER} -p ${PCF_TILE_PKS_ADMIN_PASS} -a ${API_HOST_NAME} --skip-ssl-validation"
    echo ""
  fi

  if [ $(($MASK & $BITMASK_K8S)) -gt 0 ]; then 
    for cvar in PCF_TILE_PKS_CLUSTER_CL1_PLAN PCF_TILE_PKS_CLUSTER_CL2_PLAN PCF_TILE_PKS_CLUSTER_CL3_PLAN; do
      [ "$cvar" == "PCF_TILE_PKS_CLUSTER_CL1_PLAN" ] && cluster=cl1
      [ "$cvar" == "PCF_TILE_PKS_CLUSTER_CL2_PLAN" ] && cluster=cl2
      [ "$cvar" == "PCF_TILE_PKS_CLUSTER_CL3_PLAN" ] && cluster=cl3

      eval plan=\$$cvar

      if [ "${plan}" != "" ]; then 
        pks get-credentials $cluster > /dev/null 2>&1
        userid=$(kubectl config view -o jsonpath="{.contexts[?(@.name == \"$cluster\")].context.user}")
        token=$(kubectl describe secret $(kubectl get secret | grep $userid | awk '{print $1}') | \
              grep "token:" | awk '{ print $2 }')

        echo "KUBERNETES CLUSTER ($cluster) ACCESS CREDENTIALS"
        echo "=> pks get-credentials $cluster"
        echo "=> kubectl config use-context $cluster                    # Set kubernetes context to $cluster"
        echo "=> kubectl proxy                                     # To start Kubernetes Dashboard"
        echo "DASHBOARD ACCESS TOKEN (http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy)"
        echo "$token"
      fi
    done
  fi

  echo ""
}

createENVfile() {
  dep="$1"
  envFile="$2"

  rm -f $env
  . ${PCFPATH}/deployments/$dep

  cat ${PCFPATH}/deployments/$dep | sed -e '/^$/d' -e '/^#/d' -e 's/#.*$//g' > $envFile

  echo "PCF_DEPLOYMENT_DEBUG=$PCF_DEPLOYMENT_DEBUG"                              >> $envFile
  echo "AWS_HOSTED_ZONE_ID=$AWS_HOSTED_ZONE_ID"                                  >> $envFile
  echo "AWS_HOSTED_DNS_DOMAIN=$AWS_HOSTED_DNS_DOMAIN"                            >> $envFile
  echo "PCF_PIVNET_TOKEN=$PCF_PIVNET_TOKEN"                                      >> $envFile

  echo "PCF_TILE_PKS_ADMIN_USER=$PCF_TILE_PKS_ADMIN_USER"                        >> $envFile
  echo "PCF_TILE_PKS_ADMIN_PASS=$PCF_TILE_PKS_ADMIN_PASS"                        >> $envFile
  echo "PCF_TILE_PKS_ADMIN_EMAIL=$PCF_TILE_PKS_ADMIN_EMAIL"                      >> $envFile
  echo "PCF_TILE_PAS_ADMIN_USER=$PCF_TILE_PAS_ADMIN_USER"                        >> $envFile
  echo "PCF_TILE_PAS_ADMIN_PASS=$PCF_TILE_PAS_ADMIN_PASS"                        >> $envFile
  echo "PCF_TILE_PAS_ADMIN_EMAIL=$PCF_TILE_PAS_ADMIN_EMAIL"                      >> $envFile

  if [ "${PCF_DEPLOYMENT_CLOUD}" == "GCP" ]; then
    #echo "GCP_SERVICE_ACCOUNT=/tmp/$(basename $GCP_SERVICE_ACCOUNT)"             >> $envFile
    echo "GCP_REGION=\"$GCP_REGION\""                                            >> $envFile
    echo "GCP_PROJECT=\"$GCP_PROJECT\""                                          >> $envFile

    echo "PCF_TERRAFORMS_TEMPLATE_BUNDLE=\"$PCF_TERRAFORMS_TEMPLATE_BUNDLE\""    >> $envFile
    echo "PCF_TERRAFORMS_TEMPLATE_NAME=\"$PCF_TERRAFORMS_TEMPLATE_NAME\""        >> $envFile
    echo "PCF_TERRAFORMS_TEMPLATE_VERSION=\"$PCF_TERRAFORMS_TEMPLATE_VERSION\""  >> $envFile

    if [ "${PCF_TILE_PKS_DEPLOY}" == "true" ]; then 
      if [ "${GCP_PKS_TLS_CERTIFICATE}" != "" -a "${GCP_PKS_TLS_FULLCHAIN}" != "" -a \
           "${GCP_PKS_TLS_PRIVATE_KEY}" != "" ]; then

        echo "TLS_CERTIFICATE=\"$GCP_PKS_TLS_CERTIFICATE\""              >> $envFile
        echo "TLS_FULLCHAIN=\"$GCP_PKS_TLS_FULLCHAIN\""                  >> $envFile
        echo "TLS_PRIVATE_KEY=\"$GCP_PKS_TLS_PRIVATE_KEY\""              >> $envFile
      fi
    fi

    if [ "${PCF_TILE_PAS_DEPLOY}" == "true" ]; then
      if [ "${GCP_PAS_TLS_CERTIFICATE}" != "" -a "${GCP_PAS_TLS_FULLCHAIN}" != "" -a \
           "${GCP_PAS_TLS_PRIVATE_KEY}" != "" ]; then

        echo "TLS_CERTIFICATE=\"$GCP_PAS_TLS_CERTIFICATE\""              >> $envFile
        echo "TLS_FULLCHAIN=\"$GCP_PAS_TLS_FULLCHAIN\""                  >> $envFile
        echo "TLS_PRIVATE_KEY=\"$GCP_PAS_TLS_PRIVATE_KEY\""              >> $envFile
      fi
    fi
  fi

  if [ "${PCF_DEPLOYMENT_CLOUD}" == "AWS" ]; then
    echo "AWS_ACCESS_KEY=\"$AWS_ACCESS_KEY\""                                    >> $envFile
    echo "AWS_SECRET_KEY=\"$AWS_SECRET_KEY\""                                    >> $envFile
    echo "AWS_REGION=\"$AWS_REGION\""                                            >> $envFile

    echo "PCF_TERRAFORMS_TEMPLATE_BUNDLE=\"$PCF_TERRAFORMS_TEMPLATE_BUNDLE\""    >> $envFile
    echo "PCF_TERRAFORMS_TEMPLATE_NAME=\"$PCF_TERRAFORMS_TEMPLATE_NAME\""        >> $envFile
    echo "PCF_TERRAFORMS_TEMPLATE_VERSION=\"$PCF_TERRAFORMS_TEMPLATE_VERSION\""  >> $envFile

    if [ "${PCF_TILE_PKS_DEPLOY}" == "true" ]; then 
      if [ "${AWS_PKS_TLS_CERTIFICATE}" != "" -a "${AWS_PKS_TLS_FULLCHAIN}" != "" -a \
           "${AWS_PKS_TLS_PRIVATE_KEY}" != "" ]; then

        echo "TLS_CERTIFICATE=\"$AWS_PKS_TLS_CERTIFICATE\""              >> $envFile
        echo "TLS_FULLCHAIN=\"$AWS_PKS_TLS_FULLCHAIN\""                  >> $envFile
        echo "TLS_PRIVATE_KEY=\"$AWS_PKS_TLS_PRIVATE_KEY\""              >> $envFile
      fi
    fi

    if [ "${PCF_TILE_PAS_DEPLOY}" == "true" ]; then
      if [ "${AWS_PAS_TLS_CERTIFICATE}" != "" -a "${AWS_PAS_TLS_FULLCHAIN}" -o \
           "${AWS_PAS_TLS_PRIVATE_KEY}" != "" ]; then

        echo "TLS_CERTIFICATE=\"$AWS_PAS_TLS_CERTIFICATE\""              >> $envFile
        echo "TLS_FULLCHAIN=\"$AWS_PAS_TLS_FULLCHAIN\""                  >> $envFile
        echo "TLS_PRIVATE_KEY=\"$AWS_PAS_TLS_PRIVATE_KEY\""              >> $envFile
      fi
    fi
  fi

  if [ "${PCF_DEPLOYMENT_CLOUD}" == "Azure" ]; then
    echo "AZURE_SUBSCRIPTION_ID=\"$AZURE_SUBSCRIPTION_ID\""                      >> $envFile
    echo "AZURE_TENANT_ID=\"$AZURE_TENANT_ID\""                                  >> $envFile
    echo "AZURE_CLIENT_ID=\"$AZURE_CLIENT_ID\""                                  >> $envFile
    echo "AZURE_CLIENT_SECRET=\"$AZURE_CLIENT_SECRET\""                          >> $envFile
    echo "AZURE_REGION=\"$AZURE_REGION\""                                        >> $envFile

    echo "PCF_TERRAFORMS_TEMPLATE_BUNDLE=\"$PCF_TERRAFORMS_TEMPLATE_BUNDLE\""    >> $envFile
    echo "PCF_TERRAFORMS_TEMPLATE_NAME=\"$PCF_TERRAFORMS_TEMPLATE_NAME\""        >> $envFile
    echo "PCF_TERRAFORMS_TEMPLATE_VERSION=\"$PCF_TERRAFORMS_TEMPLATE_VERSION\""  >> $envFile
    
    if [ "${PCF_TILE_PKS_DEPLOY}" == "true" ]; then 
      if [ "${AZURE_PKS_TLS_CERTIFICATE}" != "" -a "${AZURE_PKS_TLS_FULLCHAIN}" -o \
           "${AZURE_PKS_TLS_PRIVATE_KEY}" != "" ]; then

        echo "TLS_CERTIFICATE=\"$AZURE_PKS_TLS_CERTIFICATE\""          >> $envFile
        echo "TLS_FULLCHAIN=\"$AZURE_PKS_TLS_FULLCHAIN\""              >> $envFile
        echo "TLS_PRIVATE_KEY=\"$AZURE_PKS_TLS_PRIVATE_KEY\""          >> $envFile
      fi
    fi

    if [ "${PCF_TILE_PAS_DEPLOY}" == "true" ]; then 
      if [ "${AZURE_PAS_TLS_CERTIFICATE}" != "" -a "${AZURE_PAS_TLS_FULLCHAIN}" -o \
           "${AZURE_PAS_TLS_PRIVATE_KEY}" != "" ]; then

        echo "TLS_CERTIFICATE=\"$AZURE_PAS_TLS_CERTIFICATE\""          >> $envFile
        echo "TLS_FULLCHAIN=\"$AZURE_PAS_TLS_FULLCHAIN\""              >> $envFile
        echo "TLS_PRIVATE_KEY=\"$AZURE_PAS_TLS_PRIVATE_KEY\""          >> $envFile
      fi
    fi
  fi
}

verifyTLScertificate() {
  TLS_CERTIFICATE=$1
  TLS_PRIVATE_KEY=$2

  dif=$((openssl x509 -in $TLS_CERTIFICATE -noout -modulus; openssl rsa -in $TLS_PRIVATE_KEY -noout -modulus) | \
      uniq -c | awk '{ print $1 }')
  if [ "$dif" == "" ]; then dif=0; fi
  if [ $dif -ne 2 ]; then
    echo "ERROR: Certificate modulus of $TLS_CERTIFICATE does not match with the private_key $TLS_PRIVATE_KEY"
    echo "       => openssl x509 -in $TLS_CERTIFICATE -noout -modulus"
    echo "       => openssl rsa -in $TLS_PRIVATE_KEY -noout -modulus"
    exit 1
  fi
}

showK8sEnvironment() {
  pks clusters > /dev/null
  if [ $? -ne 0 ]; then exit 1; fi

  PKS_CLNAME=$(kubectl config current-context 2>/dev/null)
  PKS_ENNAME=$(pks cluster cl1 | grep 'Kubernetes Master Host:' | \
      awk '{ print $NF }' | sed "s/${PKS_CLNAME}\.//g")
  PKS_APPATH="apps-${PKS_CLNAME}.${PKS_ENNAME}"

  echo "Kubernetes Cluster ...........: $PKS_CLNAME"
  echo "Kubernetes Master Host .......: $PKS_ENNAME"
  echo "DNS Application Domain .......: *.apps-${PKS_CLNAME}.$PKS_ENNAME"
  echo ""
}

waitCmd() {
  read
}

prtHead() {
  if [ "${tocindex}" == "" ]; then tocindex=1; else let tocindex=tocindex+1; fi
  printf "%2d.) %s\n" $tocindex "$1"
}

prtText() {
  if [ "${tocindex}" == "" ]; then tocindex=1; else let tocindex=tocindex+1; fi
  printf "%2s   %s\n" "" "$1"
}

execCmd() {
  bold=$(tput bold)
  normal=$(tput sgr0)

  echo -e "     => ${bold}$1${normal}\c"; read x
  echo "     -----------------------------------------------------------------------------------------------------------"
  eval "$1" 2>&1 | sed -e '/^$/d' -e 's/^/     /g'
  #$1 | sed -e '/^$/d' -e 's/^/     /g'
  echo "     -----------------------------------------------------------------------------------------------------------"
  echo ""
  if [ $? -ne 0 ]; then exit 1; fi
}

sshEnvironment() {
  JUMP_HOST="jump-${PCF_DEPLOYMENT_ENV_NAME}.${AWS_HOSTED_DNS_DOMAIN}"

  if [ "${PCF_DEPLOYMENT_CLOUD}" == "Azure" ]; then
    stt=$(az group exists --name Admin)
    if [ "$stt" == "true" ]; then
      pip=$(az network public-ip list -g Admin --query "[?contains(name, 'AdminPublicIP_$PCF_DEPLOYMENT_ENV_NAME')]" | jq -r '.[].ipAddress')
    else
      PCF_JUMP_EXIST=0
    fi
    SSH_USER=ubuntu
    SSH_HOME=/home/ubuntu
    SSH_HOST=$pip
    SSH_OPTIONS="-o StrictHostKeyChecking=no -o RequestTTY=yes -o ServerAliveInterval=30"
    SCP_OPTIONS="-o StrictHostKeyChecking=no"
    SSH_COMMAND="ssh -q $SSH_OPTIONS ${SSH_USER}@${SSH_HOST}"
    SCP_COMMAND="scp -r $SCP_OPTIONS"
  fi

  if [ "${PCF_DEPLOYMENT_CLOUD}" == "AWS" ]; then
    SSH_USER=ubuntu
    SSH_HOME=/home/ubuntu
    SSH_HOST=$JUMP_HOST
    SSH_OPTIONS="-o StrictHostKeyChecking=no -o RequestTTY=yes -o ServerAliveInterval=30"
    SCP_OPTIONS="-o StrictHostKeyChecking=no"
    SSH_COMMAND="ssh -q $SSH_OPTIONS -i ~/.ssh/${JUMP_HOST}.pem ${SSH_USER}@${SSH_HOST}"
    SCP_COMMAND="scp -r $SCP_OPTIONS -i ~/.ssh/${JUMP_HOST}.pem"
  fi

  if [ "${PCF_DEPLOYMENT_CLOUD}" == "GCP" ]; then
    SSH_USER=$(whoami)
    SSH_HOME=/home/$(whoami)
    SSH_HOST="${INSTANCE_NAME}.${ZONE}.${prj}"
    SSH_OPTIONS="-o StrictHostKeyChecking=no -o RequestTTY=yes -o ServerAliveInterval=30"
    SCP_OPTIONS="-o StrictHostKeyChecking=no"
    SSH_COMMAND="ssh -q $SSH_OPTIONS ${SSH_USER}@${SSH_HOST}"
    SCP_COMMAND="scp -r $SCP_OPTIONS"
  fi
}

installJumpHost() {
  JUMP_HOST="$1"

  if [ "${PCF_DEPLOYMENT_CLOUD}" == "Azure" ]; then
    messagePrint "Verifing Azure Jump-Server" "$JUMP_HOST"

    stt=$(az group exists --name Admin)
    if [ "$stt" == "false" ]; then
      messagePrint " - Creating Azure Ressource Group" "Admin"
      az group create --name Admin --location $AZURE_REGION > /dev/null 2>&1
      if [ $? -ne 0 ]; then
        echo "ERROR: Creating Ressource Group Admin"
        echo "       => az group create --name Admin --location $AZURE_REGION"
        exit 1
      fi
    fi
#pppppppppppp  InstallJump Azure

    vm_stt=$(az vm list -d --query "[?contains(name, '$JUMP_HOST')]" | jq -r '.[].powerState')
    if [ "${vm_stt}" == "" ]; then  
      # --- VM DOES NOT EXIST, CREATINGIGT ---
      nam=$(az network vnet list -g Admin --query "[?contains(name, 'admin-vnet')]" | jq -r '.[].name') 
      if [ "$nam" != "admin-vnet" ]; then
        messagePrint " - Creating Vnet" "admin-vnet"

        az network vnet create \
            --resource-group Admin \
            --name admin-vnet \
            --address-prefix 192.168.0.0/16 \
            --subnet-name AdminSubnet \
            --subnet-prefix 192.168.1.0/24 > /dev/null 2>&1
        if [ $? -ne 0 ]; then
          echo "ERROR: Creating Vnet admin-vnet"
          exit 1
        fi
      else
        messagePrint " - Verify Vnet" "admin-vnet"
      fi

      nam=$(az network public-ip list -g Admin --query "[?contains(name, 'AdminPublicIP_$PCF_DEPLOYMENT_ENV_NAME')]" | jq -r '.[].name') 
      if [ "$nam" != "AdminPublicIP_$PCF_DEPLOYMENT_ENV_NAME" ]; then
        messagePrint " - Creating PublicIP" "AdminPublicIP_$PCF_DEPLOYMENT_ENV_NAME"
  
        az network public-ip create \
            --resource-group Admin \
            --name AdminPublicIP_$PCF_DEPLOYMENT_ENV_NAME  > /dev/null 2>&1
        if [ $? -ne 0 ]; then
          echo "ERROR: Creating PublicIP AdminPublicIP_$PCF_DEPLOYMENT_ENV_NAME"
          exit 1
        fi
      else
        pip=$(az network public-ip list -g Admin --query "[?contains(name, 'AdminPublicIP_$PCF_DEPLOYMENT_ENV_NAME')]" | jq -r '.[].ipAddress')
  
        messagePrint " - Verify PublicIP (AdminPublicIP_$PCF_DEPLOYMENT_ENV_NAME)" "$pip"
      fi

      nam=$(az network nsg list --query "[?contains(name, 'AdminSG')]" | jq -r '.[].name')
      if [ "$nam" != "AdminSG" ]; then
        messagePrint " - Creating Security Group" "AdminSG"
  
        az network nsg create \
            --resource-group Admin \
            --name AdminSG > /dev/null 2>&1
        if [ $? -ne 0 ]; then
          echo "ERROR: Creating Security Group AdminSG"
          exit 1
        fi
      else
        messagePrint " - Verify Security Group" "AdminSG"
      fi

      nam=$(az network nsg rule list -g Admin --nsg-name AdminSG --query "[?contains(name, 'AdminSG-RuleSSH')]" | \
            jq -r '.[].name')
      if [ "$nam" != "AdminSG-RuleSSH" ]; then
        messagePrint " - Creating Security Group Rule" "AdminSG-RuleSSH"
  
        az network nsg rule create \
            --resource-group Admin \
            --nsg-name AdminSG \
            --name AdminSG-RuleSSH \
            --protocol tcp \
            --priority 1000 \
            --destination-port-range 22 \
            --access allow > /dev/null 2>&1
        if [ $? -ne 0 ]; then
          echo "ERROR: Creating Security Group Rule AdminSG-RuleSSH"
          exit 1
        fi
      else
        messagePrint " - Verify Security Group Rule" "AdminSG-RuleSSH"
      fi

      nam=$(az network nic list -g Admin --query "[?contains(name, 'AdminNic_$PCF_DEPLOYMENT_ENV_NAME')]" | \
            jq -r '.[].name')
      if [ "$nam" != "AdminNic_$PCF_DEPLOYMENT_ENV_NAME" ]; then
        messagePrint " - Creating Nic" "AdminNic_$PCF_DEPLOYMENT_ENV_NAME"
  
        az network nic create \
            --resource-group Admin \
            --name AdminNic_$PCF_DEPLOYMENT_ENV_NAME \
            --vnet-name admin-vnet \
            --subnet AdminSubnet \
            --public-ip-address AdminPublicIP_$PCF_DEPLOYMENT_ENV_NAME \
            --network-security-group AdminSG > /dev/null 2>&1
        if [ $? -ne 0 ]; then
          echo "ERROR: Creating NIC AdminNic_$PCF_DEPLOYMENT_ENV_NAME"
          echo "       => az network nic create --resource-group Admin --name AdminNic_$PCF_DEPLOYMENT_ENV_NAME \\"
          echo "            --vnet-name admin-vnet --subnet AdminSubnet --public-ip-address AdminPublicIP_$PCF_DEPLOYMENT_ENV_NAME "
          exit 1
        fi
      else
        messagePrint " - Verify NIC" "AdminNic_$PCF_DEPLOYMENT_ENV_NAME"
      fi

      #nam=$(az vm list --query "[?contains(name, '$JUMP_HOST')]" | jq -r '.[].name')
      #if [ "$nam" != "$JUMP_HOST" ]; then
      messagePrint " - Creating VM" "$JUMP_HOST"

      az vm create \
          --resource-group Admin \
          --name $JUMP_HOST \
          --location $AZURE_REGION \
          --nics AdminNic_$PCF_DEPLOYMENT_ENV_NAME \
          --image UbuntuLTS \
          --admin-username ubuntu \
          --generate-ssh-keys > /dev/null 2>&1
      if [ $? -ne 0 ]; then
        echo "ERROR: Creating VM"
        echo "       => az vm create --resource-group Admin --name $JUMP_HOST --location $AZURE_REGION \\"
        echo "          --nics AdminNic_$PCF_DEPLOYMENT_ENV_NAME --image UbuntuLTS --admin-username ubuntu --generate-ssh-keys"
        exit 1
      fi
    else
      #stt=$(az vm list -d --query "[?contains(name, '$JUMP_HOST')]" | jq -r '.[].powerState') 
      if [ "${vm_stt}" != "VM running" ]; then 
        messagePrint " - Starting VM" "$JUMP_HOST"
        az vm start --resource-group Admin --name $JUMP_HOST
      fi
    fi
#pppppppp installJump Middle
    pip=$(az network public-ip list -g Admin --query "[?contains(name, 'AdminPublicIP_$PCF_DEPLOYMENT_ENV_NAME')]" | jq -r '.[].ipAddress')
    aip=$(route53getIPaddress $PCF_DEPLOYMENT_ENV_NAME $AWS_HOSTED_DNS_DOMAIN)

    # --- UPDATE DNS DOMAIN ---
    if [ "${pip}" != "${aip}" ]; then 
      messagePrint " - DNS Zone (${AWS_HOSTED_DNS_DOMAIN})" "zone managed by route53"
      messagePrint " - Updating Zone Record for ($JUMP_HOST)" "$pip"
      route53setDNSrecord "$pip" "$JUMP_HOST" "$AWS_HOSTED_DNS_DOMAIN"

      sed -in "/$JUMP_HOST/d" ~/.ssh/known_hosts
      messagePrint " - Wait for SSH Daemon on jump-host to come online" "< 5min"
    fi

    SSH_HOME=/home/ubuntu
    SSH_USER=ubuntu
    SSH_HOST=$pip
    SSH_OPTIONS="-o StrictHostKeyChecking=no -o RequestTTY=yes -o ServerAliveInterval=30"
    SCP_OPTIONS="-o StrictHostKeyChecking=no"
    SSH_COMMAND="ssh -q $SSH_OPTIONS ${SSH_USER}@${SSH_HOST}"
    SCP_COMMAND="scp -r $SCP_OPTIONS"
  fi

#pppppppppppp  InstallJump GCP
  if [ "${PCF_DEPLOYMENT_CLOUD}" == "GCP" ]; then
    messagePrint "Verify GCP Jump-Server" "$JUMP_HOST"

    IMAGE_FAMILY="ubuntu-1804-lts"
    INSTANCE_NAME="pcfjump"
    INSTANCE_NAME="$(echo $JUMP_HOST | awk -F'.' '{ print $1 }')"
    INSTANCE_TYPE="n1-standard-8"
    INSTANCE_TYPE="n1-standard-1"
    ZONE=$(gcloud compute zones list | grep " $GCP_REGION " | head -1 | awk '{ print $1 }')

    cnt=$(gcloud compute instances list --filter="name=( '$INSTANCE_NAME' )" 2>/dev/null | egrep -c "^$INSTANCE_NAME")
    if [ $cnt -eq 0 ]; then
      messagePrint " - Creating VM" "$INSTANCE_NAME"

      gcloud compute instances create $INSTANCE_NAME \
        --zone=$ZONE \
        --image-family=$IMAGE_FAMILY \
        --image-project=ubuntu-os-cloud  \
        --maintenance-policy=TERMINATE \
        --machine-type=$INSTANCE_TYPE > /dev/null 2>&1
      gcloud compute config-ssh > /dev/null 2>&1
    else
      #gcloud compute instances describe $INSTANCE_NAME --zone=europe-west1-b --format json
      stt=$(gcloud compute instances describe $INSTANCE_NAME --zone=$ZONE | egrep "^status:" | awk '{ print $2 }')
      if [ "${stt}" != "RUNNING" ]; then
        messagePrint " - Starting VM" "$INSTANCE_NAME"
        gcloud compute instances start $INSTANCE_NAME --zone=$ZONE > /dev/null 2>&1
        gcloud compute config-ssh > /dev/null 2>&1
        messagePrint " - Wait for SSH Daemon on jump-host to come online" "< 5min"
      fi
    fi

    prj=$(gcloud projects list | sed '1d' | awk '{ print $1 }')

    SSH_USER=$(whoami)
    SSH_HOME=/home/$(whoami)
    SSH_HOST="${INSTANCE_NAME}.${ZONE}.${prj}"
    SSH_OPTIONS="-o StrictHostKeyChecking=no -o RequestTTY=yes -o ServerAliveInterval=30"
    SCP_OPTIONS="-o StrictHostKeyChecking=no"
    SSH_COMMAND="ssh -q $SSH_OPTIONS ${SSH_USER}@${SSH_HOST}"
    SCP_COMMAND="scp -r $SCP_OPTIONS"
  fi

#pppppppppppp  InstallJump AWS
  if [ "${PCF_DEPLOYMENT_CLOUD}" == "AWS" ]; then
    ins=$(aws ec2 --region=$AWS_REGION describe-instances --filters "Name=instance-state-name,Values=pending,running,stopped" \
         Name=tag:Name,Values="$JUMP_HOST" | jq -r ".Reservations[].Instances[].InstanceId" | head -1)
    if [ "${ins}" == "" ]; then
      messagePrint "Creating AWS Jump-Server" "$JUMP_HOST"

      # --- CREATE NEW KEY IF PEM FILE IS MISSING ---
      if [ ! -s ~/.ssh/${JUMP_HOST}.pem ]; then
        messagePrint " - Missing pem file, deleting Key Pair" "${JUMP_HOST}"
        aws ec2 --region=$AWS_REGION delete-key-pair --key-name ${JUMP_HOST}
      fi

      aws ec2 --region=$AWS_REGION describe-key-pairs --key-names ${JUMP_HOST} > /dev/null 2>&1
      if [ $? -ne 0 ]; then
        messagePrint " - Creating Key Pair" "${JUMP_HOST}"
        aws ec2 --region=$AWS_REGION create-key-pair --key-name ${JUMP_HOST} \
                --query 'KeyMaterial' --output text > ~/.ssh/${JUMP_HOST}.pem 2>/dev/null
        chmod 600 ~/.ssh/${JUMP_HOST}.pem
        if [ $? -ne 0 ]; then
          echo "ERROR: Creating Key Pairs failed"
          echo "       => aws ec2 --region=$AWS_REGION create-key-pair --key-name ${JUMP_HOST}  \\"
          echo "                  --query 'KeyMaterial' --output text > ~/.ssh/${JUMP_HOST}.pem"; exit 1
        fi
      else
        messagePrint " - Verify Key Pair" "${JUMP_HOST}"
      fi
  
      # --- CREATE VPC ---
      vpc=$(aws ec2 --region=$AWS_REGION describe-vpcs --filters Name=tag:type,Values="pcfjump" | jq -r '.Vpcs[].VpcId')
      if [ "${vpc}" == "" ]; then
        vpc=$(aws ec2 --region=$AWS_REGION create-vpc --cidr-block 10.0.0.0/16 | jq -r '.Vpc.VpcId')
        aws ec2 --region=$AWS_REGION create-tags --resources $vpc --tags Key=type,Value=pcfjump
        messagePrint " - Creating VPC: $vpc" "10.0.0.0/16"
      else
        messagePrint " - Verify VPC: $vpc" "10.0.0.0/16"
      fi
  
      i=1
      for zone in $(aws ec2 --region=$AWS_REGION describe-availability-zones | jq -r '.AvailabilityZones[].ZoneName'); do
        sid=$(aws ec2 --region=$AWS_REGION describe-subnets --filters Name=tag:type,Values="pcfjump" \
            Name=availability-zone,Values=$zone | jq -r '.Subnets[].SubnetId')
        if [ "${sid}" == "" ]; then
          sid=$(aws ec2 --region=$AWS_REGION create-subnet --vpc-id $vpc --availability-zone $zone \
                        --cidr-block 10.0.$i.0/24 2>/dev/null | jq -r '.Subnet.SubnetId')
          messagePrint " - Creating Subnet: $sid" "10.0.$i.0/16"
          if [ "${sid}" == "" ]; then
            echo "ERROR: Creating of default subnet in zone $zone failed"
            echo "       => aws ec2 --region=$AWS_REGION create-subnet --vpc-id $vpc \\"
            echo "                  --cidr-block 10.0.$i.0/24 --availability-zone $zone"; exit 1
          fi
  
          aws ec2 --region=$AWS_REGION create-tags --resources $sid --tags Key=type,Value=pcfjump > /dev/null 2>&1
          if [ $? -ne 0 ]; then
            echo "ERROR: Creating of Tags failed"
            echo "       => aws ec2 --region=$AWS_REGION create-tags --resources $sid --tags Key=type,Value=pcfjump"; exit 1
          fi
        else
          messagePrint " - Verify Subnet: $sid" "10.0.$i.0/16"
        fi
  
        let i=i+1
      done
  
      igw=$(aws ec2 --region=$AWS_REGION describe-internet-gateways --filters Name=tag:type,Values="pcfjump" | \
          jq -r ".InternetGateways[].InternetGatewayId")
      if [ "${igw}" == "" ]; then
        igw=$(aws ec2 --region=$AWS_REGION create-internet-gateway | jq -r '.InternetGateway.InternetGatewayId')
        messagePrint " - Creating Internet Gateway" "$igw"
        if [ "${sid}" == "" ]; then
          echo "ERROR: Creating of Internet Gateway failed"
          echo "       => aws ec2 --region=$AWS_REGION create-internet-gateway"; exit 1
        fi

        aws ec2 --region=$AWS_REGION create-tags --resources $igw --tags Key=type,Value=pcfjump > /dev/null 2>&1
        if [ $? -ne 0 ]; then
          echo "ERROR: Creating of Tags failed"
          echo "       => aws ec2 --region=$AWS_REGION create-tags --resources $sid --tags Key=type,Value=pcfjump"; exit 1
        fi
      else
        messagePrint " - Verify Internet Gateway" "$igw"
      fi

      att=$(aws ec2 --region=$AWS_REGION describe-internet-gateways --filters Name=tag:type,Values="pcfjump" | \
          jq -r ".InternetGateways[].Attachments[].VpcId")
      if [ "${att}" == "" ]; then
        aws ec2 --region=$AWS_REGION attach-internet-gateway --vpc-id $vpc --internet-gateway-id $igw > /dev/null 2>&1
        messagePrint " - Attaching Internet Gateway" "$vpc"
        if [ $? -ne 0 ]; then
          echo "ERROR: Attaching Internet Gateway to VPC: $vpc failed"
          echo "       => aws ec2 --region=$AWS_REGION attach-internet-gateway --vpc-id $vpc --internet-gateway-id $igw "; exit 1
        fi
      fi

      # --- CREATE ROUTING TABLE ---
      rtb=$(aws ec2 --region=$AWS_REGION describe-route-tables --filters Name=tag:type,Values="pcfjump" | \
          jq -r ".RouteTables[].RouteTableId")
      if [ "${rtb}" == "" ]; then
        rtb=$(aws ec2 --region=$AWS_REGION create-route-table --vpc-id $vpc| jq -r '.RouteTable.RouteTableId')
        messagePrint " - Creating Routing Table" "$igw"
        if [ "${sid}" == "" ]; then
          echo "ERROR: Creating of Routing Table failed"
          echo "       => aws ec2 --region=$AWS_REGION create-route-table"; exit 1
        fi
  
        aws ec2 --region=$AWS_REGION create-tags --resources $rtb --tags Key=type,Value=pcfjump > /dev/null 2>&1
        if [ $? -ne 0 ]; then
          echo "ERROR: Creating of Tags failed"
          echo "       => aws ec2 --region=$AWS_REGION create-tags --resources $rtb --tags Key=type,Value=pcfjump"; exit 1
          exit 1
        fi

        aws ec2 --region=$AWS_REGION create-route --route-table-id $rtb --destination-cidr-block 0.0.0.0/0 --gateway-id $igw
        if [ $? -ne 0 ]; then
          echo "ERROR: Creating route failed"
          echo "       => aws ec2 --region=$AWS_REGION create-route --route-table-id $rtb --destination-cidr-block 0.0.0.0/0 \\"
          echo "                  --gateway-id $igw"
          exit 1
        fi

        #aws ec2 --region=$AWS_REGION describe-route-tables --route-table-id rtb-0483bed5665fd7eff
      else
        messagePrint " - Verify Internet Gateway" "$igw"
      fi

      for zone in $(aws ec2 --region=$AWS_REGION describe-availability-zones | jq -r '.AvailabilityZones[].ZoneName'); do
        sid=$(aws ec2 --region=$AWS_REGION describe-subnets --filters Name=tag:type,Values="pcfjump" \
            Name=availability-zone,Values=$zone | jq -r '.Subnets[].SubnetId')
  
        messagePrint " - Associate Routing Table $rtb" "Subnet $sid"
        aws ec2 --region=$AWS_REGION associate-route-table  --subnet-id $sid --route-table-id $rtb > /dev/null 2>&1
        if [ $? -ne 0 ]; then
          echo "ERROR: Associate Routing Table failed"
          echo "       => aws ec2 --region=$AWS_REGION associate-route-table  --subnet-id $sid --route-table-id $rtb"
          echo "-----------------------------------------------------------------------------------------------------------"
          aws ec2 --region=$AWS_REGION associate-route-table  --subnet-id $sid --route-table-id $rtb
          echo "-----------------------------------------------------------------------------------------------------------"
        fi

        aws ec2 --region=$AWS_REGION modify-subnet-attribute --subnet-id $sid --map-public-ip-on-launch > /dev/null 2>&1
        if [ $? -ne 0 ]; then
          echo "ERROR: Modify Routing Table attribut failed"
          echo "       => aws ec2 --region=$AWS_REGION modify-subnet-attribute --subnet-id $sid --map-public-ip-on-launch"
          echo "-----------------------------------------------------------------------------------------------------------"
          aws ec2 --region=$AWS_REGION modify-subnet-attribute --subnet-id $sid --map-public-ip-on-launch
          echo "-----------------------------------------------------------------------------------------------------------"
        fi
      done
  
      # --- CREATE SECURITY GROUP ---
      gid=$(aws ec2 --region=$AWS_REGION  describe-security-groups \
                    --filters Name=vpc-id,Values=$vpc Name=group-name,Values=pcfjump-sg | jq -r ".SecurityGroups[].GroupId")
      if [ "${gid}" == "" -o "${gid}" == "null" ]; then
        gid=$(aws ec2 --region=$AWS_REGION create-security-group --group-name pcfjump-sg --vpc-id $vpc \
                --description "PCF Jump Server" 2>/dev/null | jq -r ".GroupId")
        messagePrint " - Creating Security Group (pcfjump-sg)" "$gid"
        if [ "${gid}" == "" ]; then
          echo "ERROR: Creating security Group failed"
          echo "       => aws ec2 --region=$AWS_REGION create-security-group --group-name pcfjump-sg \\"
          echo "                  --vpc-id $vpc --description \"PCF Jump Server\""; exit 1
        fi

        messagePrint " - Creating Security Group Ingress for ssh" "Port: tcp/22 Cidr: 0.0.0.0/0"
        aws ec2 --region=$AWS_REGION authorize-security-group-ingress --group-id $gid \
                --protocol tcp --port 22 --cidr 0.0.0.0/0 > /dev/null 2>&1
        if [ $? -ne 0 ]; then
          echo "ERROR: Creating security Group ingress failed"
          echo "       => aws ec2 --region=$AWS_REGION authorize-security-group-ingress --group-id $gid \\"
          echo "                  --protocol tcp --port 22 --cidr 0.0.0.0/0"; exit 1
        fi
  
      else
        messagePrint " - Verify Security Group (pcfjump-sg)" "$gid"
      fi

      aim=ami-0015c36f           # Amazon Linux  t2.nano
      aim=ami-0085d4f8878cddc81  # Ubuntu Server t2.medium
      aim=ami-0085d4f8878cddc81  # Ubuntu Server t2.micro
      aim=ami-0085d4f8878cddc81  # Ubuntu Server t2.medium
      typ=t2.medium

      messagePrint " - Create Instance" "$JUMP_HOST"
      aws ec2 --region=$AWS_REGION run-instances --image-id $aim --security-group-ids $gid \
              --instance-type $typ --key-name ${JUMP_HOST} --count 1 --subnet-id $sid --associate-public-ip-address \
              --tag-specifications "ResourceType=instance,Tags=[{Key=Name,Value=$JUMP_HOST},{Key=type,Value=pcfjump}]" > /dev/null 2>&1
      if [ $? -ne 0 ]; then
        echo "ERROR: Creating of Instance failed"
        echo "       => aws ec2 --region=$AWS_REGION run-instances --image-id $aim --security-groups pcfjump-sg \\"
        echo "                  --instance-type t2.micro --key-name ${JUMP_HOST} --subnet-id $sid \\"
        echo "                  --tag-specifications 'ResourceType=instance,Tags=[{Key=type,Value=pcfjump}]'"
        exit 1
      else
        sleep 20
      fi

      ins=$(aws ec2 --region=$AWS_REGION describe-instances --filters "Name=instance-state-name,Values=pending,running,stopped" \
           Name=tag:Name,Values="$JUMP_HOST" | jq -r ".Reservations[].Instances[].InstanceId" | head -1)
      stt=$(aws ec2 --region=$AWS_REGION describe-instances --instance-ids $ins | \
           jq -r ".Reservations[].Instances[].State.Name")
      dns=$(aws ec2 --region=$AWS_REGION describe-instances --instance-ids $ins | \
           jq -r ".Reservations[].Instances[].PublicDnsName")
      pip=$(aws ec2 --region=$AWS_REGION describe-instances --instance-ids $ins | \
           jq -r ".Reservations[].Instances[].PublicIpAddress")
  
      ZONE_ID=$(aws route53 list-hosted-zones-by-name --dns-name ${AWS_HOSTED_DNS_DOMAIN} | jq -r '.HostedZones[0].Id')
      ZONE_ID_STR=$(echo "${ZONE_ID}" | awk -F'/' '{ print $NF }')
      messagePrint " - DNS Zone (${AWS_HOSTED_DNS_DOMAIN}:" "zone managed by route53"
      messagePrint " - Updating Zone Record for ($JUMP_HOST)" "$pip"

      # --- UPDATE DNS DOMAIN ---
      route53setDNSrecord "$pip" "$JUMP_HOST" "$AWS_HOSTED_DNS_DOMAIN"
    else
      messagePrint "Verify AWS Jump-Server" "$JUMP_HOST"
      stt=$(aws ec2 --region=$AWS_REGION describe-instances --instance-ids $ins | \
          jq -r ".Reservations[].Instances[].State.Name")

      messagePrint " - Verify Instance: $ins" "$stt"
      if [ "${stt}" == "stopped" ]; then
        messagePrint " - Starting Instance: $ins" "this can take several minutes"
        aws ec2 --region=$AWS_REGION start-instances --instance-ids $ins > /dev/null 2>&1
        messagePrint " - Wait for SSH Daemon on jump-host to come online" "< 5min"
        sleep 30
      fi

      ins=$(aws ec2 --region=$AWS_REGION describe-instances --filters "Name=instance-state-name,Values=pending,running,stopped" \
           Name=tag:Name,Values="$JUMP_HOST" | jq -r ".Reservations[].Instances[].InstanceId" | head -1)
      pip=$(aws ec2 --region=$AWS_REGION describe-instances --instance-ids $ins | \
           jq -r ".Reservations[].Instances[].PublicIpAddress")
      aip=$(route53getIPaddress $PCF_DEPLOYMENT_ENV_NAME $AWS_HOSTED_DNS_DOMAIN)

      # --- UPDATE DNS DOMAIN ---
      if [ "${pip}" != "${aip}" ]; then
        # --- UPDATE DNS DOMAIN ---
        messagePrint " - DNS Zone (${AWS_HOSTED_DNS_DOMAIN}:" "zone managed by route53"
        messagePrint " - Updating Zone Record for ($JUMP_HOST)" "$pip"
        route53setDNSrecord "$pip" "$JUMP_HOST" "$AWS_HOSTED_DNS_DOMAIN"
      fi
    fi

    sed -in "/$JUMP_HOST/d" ~/.ssh/known_hosts
    SSH_USER=ubuntu
    SSH_HOME=/home/ubuntu
    SSH_HOST=$JUMP_HOST
    SSH_OPTIONS="-o StrictHostKeyChecking=no -o RequestTTY=yes -o ServerAliveInterval=30"
    SCP_OPTIONS="-o StrictHostKeyChecking=no"
    SSH_COMMAND="ssh -q $SSH_OPTIONS -i ~/.ssh/${JUMP_HOST}.pem ${SSH_USER}@${SSH_HOST}"
    SCP_COMMAND="scp -r $SCP_OPTIONS -i ~/.ssh/${JUMP_HOST}.pem"
  fi

  # --- WAIT UNTIL SSH DEAMON IS READY NO JUMPHOST ----
  ret=1
  while [ $ret -ne 0 ]; do
    $SSH_COMMAND -n id > /dev/null 2>&1; ret=$?
    [ $ret -ne 0 ] && sleep 10
  done
  
#ppppppppppppp InstallJump  End
  GITPCF="https://github.com/pivotal-sadubois/pcfconfig.git"
  PCFHOME="${SSH_HOME}/pcfconfig"

  messagePrint " - Verify SSH Access" "success"
  messagePrint " - Update GIT repo"   "$GITPCF"

  $SSH_COMMAND -n "[ ! -d /home/ubuntu/pcfconfig ] && git clone $GITPCF > /dev/null 2>&1"
  $SSH_COMMAND -n "[ -d /home/ubuntu/pcfconfig ] && cd $PCFHOME; git pull > /dev/null 2>&1"

  # --- HOSTNAME ---
  if [ "${PCF_DEPLOYMENT_CLOUD}" == "Azure" -o "${PCF_DEPLOYMENT_CLOUD}" == "AWS" ]; then
    $SSH_COMMAND -n "sudo hostname $JUMP_HOST > /dev/null 2>&1"
  fi

  # --- TEST FOR RUNNING REMOTE SCRIPT ---
  stt=$($SSH_COMMAND -n "[ -f /tmp/pcfconfig.pid ] && pgrep -F /tmp/pcfconfig.pid")
  stt=$($SSH_COMMAND -n "[ -f /jump_software_installed ] && echo true")
  if [ "${stt}" == "" ]; then
    messagePrint " - Install CLI Utilities"   "aws,az,gcp,bosh,pivnet,cf,om,jq"
    $SSH_COMMAND -n "[ -d $SSH_HOME/pcfconfig ] && chmod a+x ${PCFHOME}/scripts/jumpInstallUtilities.sh && \
        sudo ${PCFHOME}/scripts/jumpInstallUtilities.sh $PCF_PIVNET_TOKEN > /dev/null 2>&1"

    # --- COPY THE AWS DIRECTORY ---
    $SCP_COMMAND -r ~/.aws ${SSH_USER}@${SSH_HOST}:$SSH_HOME > /dev/null 2>&1
  fi

  #if [ "${TLS_CERTIFICATE}" != "" -a "${TLS_PRIVATE_KEY}" != "" ]; then
  #  $SCP_COMMAND $TLS_CERTIFICATE ${SSH_USER}@${SSH_HOST}:/tmp/tls_cert.pem > /dev/null 2>&1
  #  $SCP_COMMAND $TLS_FULLCHAIN   ${SSH_USER}@${SSH_HOST}:/tmp/tls_fullchain.pem > /dev/null 2>&1
  #  $SCP_COMMAND $TLS_PRIVATE_KEY ${SSH_USER}@${SSH_HOST}:/tmp/tls_private_key.pem > /dev/null 2>&1
  #  $SCP_COMMAND $TLS_ROOT_CA     ${SSH_USER}@${SSH_HOST}:/tmp/tls_root_ca.pem > /dev/null 2>&1
  #
  #  TLSSTR="--tls_cert /tmp/tls_cert.pem --tls_private_key /tmp/tls_private_key.pem \
  #          --tls_fullchain /tmp/tls_fullchain.pem --tls_root_cert /tmp/tls_root_ca.pem"
  #fi

  if [ "${PCF_DEPLOYMENT_CLOUD}" == "Azure" ]; then
    $SSH_COMMAND -n "az login --username $AZURE_CLIENT_ID \
       --password $AZURE_CLIENT_SECRET --service-principal --tenant $AZURE_TENANT_ID >/dev/null 2>&1"
    if [ $? -ne 0 ]; then
      echo "ERROR: failed to login to azure on jumphost"
      echo "       => ssh ${SSHPAR}"
      echo "       => az login --username $AZURE_CLIENT_ID --password $AZURE_CLIENT_SECRET \\"
      echo "            --service-principal --tenant $AZURE_TENANT_ID"
      exit 1
    fi

    $SSH_COMMAND -n "az group list >/dev/null 2>&1"
    if [ $? -ne 0 ]; then
      echo "ERROR: failed to login to azure on jumphost"
      echo "       => ssh ${SSHPAR}"
      echo "       => az group list"
      exit 1
    fi
  fi

  if [ "${PCF_DEPLOYMENT_CLOUD}" == "GCP" ]; then
    $SSH_COMMAND -n "gcloud compute instances list > /dev/null 2>&1"; stt=$?
    if [ "${stt}" -ne 0 ]; then
      echo "------------------------------------ ACTIVATE GCP_SERVICE_ACCOUNT -------------------------------------------"
      $SSH_COMMAND gcloud auth login --no-launch-browser --brief --quiet --project $GCP_PROJECT

      #$SSH_COMMAND -n "gcloud config set project $GCP_PROJECT"
      #while read -t 1 garbage; do sleep 0; done
      #$SSH_COMMAND -n "gcloud auth activate-service-account --quiet --key-file=/tmp/$GCPSVC 2>/dev/null"
    fi
  fi

  stt=$($SSH_COMMAND -n "[ -f ~/pcfconfig/certificates/privkey.pem ] && echo ok")
  if [ "${stt}" != "ok" ]; then 
    domain="${PCF_DEPLOYMENT_ENV_NAME}.${AWS_HOSTED_DNS_DOMAIN}"
    route53createHostedZone $domain

    if [ -d $PCFPATH/certificates/$domain -a -f $PCFPATH/certificates/$domain/privkey.pem ]; then 
      echo "Take local cached certificates for PKS Domains ($domain)"  
      $SCP_COMMAND $PCFPATH/certificates/$domain/* ${SSH_USER}@${SSH_HOST}:~/pcfconfig/certificates > /dev/null 2>&1
    else
      echo "-------------------------------------- GENERATE LET'S-ENCRYPT CERTIFICATES -------------------------------------"
      typ=$(echo $domain | egrep -c "azpks|awspks|gcppks")
      if [ $typ -ne 0 ]; then
        echo "Generate Certificate for PKS Domains ($domain)"  
        #$SSH_COMMAND -n "echo \"certbot certonly --dns-route53 -d '*.$domain' -d '*.api.$domain' -d '*.apps-cl1.$domain'\"" 
        $SSH_COMMAND -n "sudo certbot certonly --dns-route53 -d '*.$domain' -d '*.api.$domain' -d 'api.pks.$domain' -d '*.apps-cl1.$domain' \
                     -d '*.apps-cl2.$domain' -d '*.apps-cl3.$domain' -m sadubois@pivotal.io --agree-tos -n --expand"
        if [ $? -ne 0 ]; then 
          echo "ERROR: failed to generate certificate. There are probably to many cert requests happends and a limit reached"
          echo "       Try it again after some hours or search *.$domain in https://crt.sh/"
            exit 1
        fi
      else
        echo "Generate Certificate for PAS Domains ($domain)"  
        $SSH_COMMAND -n "sudo certbot certonly --dns-route53 -d '*.$domain' -d '*.apps.$domain' -d '*.sys.$domain' \
                     -m sadubois@pivotal.io --agree-tos -n --expand"
        if [ $? -ne 0 ]; then 
          echo "ERROR: failed to generate certificate. There are probably to many cert requests happends and a limit reached"
          echo "       Try it again after some hours or search *.$domain in https://crt.sh/"
          exit 1
        fi
      fi

      # --- GET A COPY OF THE CERTIFICATES BACK ---
      [ ! -d ./certificates/$domain ] && mkdir -p ./certificates/$domain
      $SCP_COMMAND ${SSH_USER}@${SSH_HOST}:$SSH_HOME/pcfconfig/certificates/* $PCFPATH/certificates/$domain/ > /dev/null 2>&1

      $SSH_COMMAND -n "[ -d /etc/letsencrypt/live ] && sudo chmod -R a+r /etc/letsencrypt/live /etc/letsencrypt/archive"
      $SSH_COMMAND -n "[ -d /etc/letsencrypt/live ] && sudo chmod 777 /etc/letsencrypt/live /etc/letsencrypt/live/$domain"
      $SSH_COMMAND -n "[ -d /etc/letsencrypt/archive ] && sudo chmod 777 /etc/letsencrypt/archive /etc/letsencrypt/archive/$domain"
      $SSH_COMMAND -n "[ -d /etc/letsencrypt/live/$domain ] && cp /etc/letsencrypt/live/$domain/* ~/pcfconfig/certificates"
      echo "----------------------------------------------------------------------------------------------------------------"
    fi
  fi
}

stopJumpHost() {
  JUMP_HOST=$1

  if [ "${PCF_DEPLOYMENT_CLOUD}" == "GCP" ]; then
    INSTANCE_NAME="$(echo $JUMP_HOST | awk -F'.' '{ print $1 }')"
    ZONE=$(gcloud compute zones list | grep " $GCP_REGION " | head -1 | awk '{ print $1 }')

    cnt=$(gcloud compute instances list --filter="name=( '$INSTANCE_NAME' )" 2>/dev/null | egrep -c "^$INSTANCE_NAME")
    if [ $cnt -gt 0 ]; then
      stt=$(gcloud compute instances describe $INSTANCE_NAME --zone=$ZONE | egrep "^status:" | awk '{ print $2 }')
      if [ "${stt}" == "RUNNING" ]; then
        messagePrint " - Stopping GCP Jump Server" "$JUMP_HOST"
        gcloud compute instances stop $INSTANCE_NAME --zone=$ZONE > /dev/null 2>&1
      fi
    fi
  fi

  if [ "${PCF_DEPLOYMENT_CLOUD}" == "AWS" ]; then
    ins=$(aws ec2 --region=$AWS_REGION describe-instances --filters "Name=instance-state-name,Values=pending,running,stopped" \
         Name=tag:Name,Values="$JUMP_HOST" | jq -r ".Reservations[].Instances[].InstanceId" | head -1)

    if [ "${ins}" != "" ]; then
      stt=$(aws ec2 --region=$AWS_REGION describe-instances --instance-ids $ins | \
          jq -r ".Reservations[].Instances[].State.Name")

      if [ "${stt}" == "running" ]; then
        messagePrint " - Stopping AWS Jump Server" "$JUMP_HOST"
        aws ec2 --region=$AWS_REGION stop-instances --instance-ids $ins > /dev/null 2>&1
      fi
    fi
  fi

  if [ "${PCF_DEPLOYMENT_CLOUD}" == "Azure" ]; then
    stt=$(az group exists --name Admin)
    if [ "$stt" == "true" ]; then
      stt=$(az vm list -d --query "[?contains(name, '$JUMP_HOST')]" | jq -r '.[].powerState')
      if [ "${stt}" == "VM running" ]; then
        messagePrint " - Stopping Azure Jump Server" "$JUMP_HOST"
        az vm stop --resource-group Admin --name $JUMP_HOST > /dev/null 2>&1
      fi
    fi
  fi
}

startJumpHost() {
  JUMP_HOST=$1

  if [ "${PCF_DEPLOYMENT_CLOUD}" == "GCP" ]; then
    INSTANCE_NAME="$(echo $JUMP_HOST | awk -F'.' '{ print $1 }')"
    ZONE=$(gcloud compute zones list | grep " $GCP_REGION " | head -1 | awk '{ print $1 }')

    cnt=$(gcloud compute instances list --filter="name=( '$INSTANCE_NAME' )" 2>/dev/null | egrep -c "^$INSTANCE_NAME")
    if [ $cnt -gt 0 ]; then
      stt=$(gcloud compute instances describe $INSTANCE_NAME --zone=$ZONE | egrep "^status:" | awk '{ print $2 }')
      if [ "${stt}" != "RUNNING" ]; then
        messagePrint " - Starting GCP Jump Server" "$JUMP_HOST"
        gcloud compute instances start $INSTANCE_NAME --zone=$ZONE > /dev/null 2>&1
        gcloud compute config-ssh > /dev/null 2>&1
        messagePrint " - Wait for SSH Daemon on jump-host to come online" "< 5min"
      fi
    fi

    prj=$(gcloud projects list | sed '1d' | awk '{ print $1 }')

    SSH_USER=$(whoami)
    SSH_HOME=/home/$(whoami)
    SSH_HOST="${INSTANCE_NAME}.${ZONE}.${prj}"
    SSH_OPTIONS="-o StrictHostKeyChecking=no -o RequestTTY=yes -o ServerAliveInterval=30"
    SCP_OPTIONS="-o StrictHostKeyChecking=no"
    SSH_COMMAND="ssh -q $SSH_OPTIONS ${SSH_USER}@${SSH_HOST}"
    SCP_COMMAND="scp -r $SCP_OPTIONS"
  fi

  if [ "${PCF_DEPLOYMENT_CLOUD}" == "AWS" ]; then
    ins=$(aws ec2 --region=$AWS_REGION describe-instances --filters "Name=instance-state-name,Values=pending,running,stopped" \
         Name=tag:Name,Values="$JUMP_HOST" | jq -r ".Reservations[].Instances[].InstanceId" | head -1)

    if [ "${ins}" != "" ]; then
      stt=$(aws ec2 --region=$AWS_REGION describe-instances --instance-ids $ins | \
          jq -r ".Reservations[].Instances[].State.Name")
      if [ "${stt}" == "stopped" ]; then
        messagePrint " - Starting AWS Jump Server" "$JUMP_HOST"
        aws ec2 --region=$AWS_REGION start-instances --instance-ids $ins > /dev/null 2>&1
        messagePrint " - Wait for SSH Daemon on jump-host to come online" "< 5min"
      fi

      ins=$(aws ec2 --region=$AWS_REGION describe-instances --filters "Name=instance-state-name,Values=pending,running,stopped" \
           Name=tag:Name,Values="$JUMP_HOST" | jq -r ".Reservations[].Instances[].InstanceId" | head -1)
      pip=$(aws ec2 --region=$AWS_REGION describe-instances --instance-ids $ins | \
           jq -r ".Reservations[].Instances[].PublicIpAddress")

      # --- UPDATE DNS DOMAIN ---
      messagePrint " - DNS Zone (${AWS_HOSTED_DNS_DOMAIN}:" "zone managed by route53"
      messagePrint " - Updating Zone Record for ($JUMP_HOST)" "$pip"
      route53setDNSrecord "$pip" "$JUMP_HOST" "$AWS_HOSTED_DNS_DOMAIN"
    fi

    SSH_USER=ubuntu
    SSH_HOME=/home/ubuntu
    SSH_HOST=$JUMP_HOST
    SSH_OPTIONS="-o StrictHostKeyChecking=no -o RequestTTY=yes -o ServerAliveInterval=30"
    SCP_OPTIONS="-o StrictHostKeyChecking=no"
    SSH_COMMAND="ssh -q $SSH_OPTIONS -i ~/.ssh/${JUMP_HOST}.pem ${SSH_USER}@${SSH_HOST}"
    SCP_COMMAND="scp -r $SCP_OPTIONS -i ~/.ssh/${JUMP_HOST}.pem"
  fi

#pppppppppppp StartVM
  if [ "${PCF_DEPLOYMENT_CLOUD}" == "Azure" ]; then
    stt=$(az group exists --name Admin)
    if [ "$stt" == "true" ]; then
      stt=$(az vm list -d --query "[?contains(name, '$JUMP_HOST')]" | jq -r '.[].powerState')
      if [ "${stt}" != "VM running" ]; then
        messagePrint " - Starting Azure Jump Server" "$JUMP_HOST"
        az vm start --resource-group Admin --name $JUMP_HOST
        messagePrint " - Wait for SSH Daemon on jump-host to come online" "< 5min"
      fi
    fi

    pip=$(az network public-ip list -g Admin --query "[?contains(name, 'AdminPublicIP_$PCF_DEPLOYMENT_ENV_NAME')]" | jq -r '.[].ipAddress')

    # --- UPDATE DNS DOMAIN ---
    messagePrint " - DNS Zone (${AWS_HOSTED_DNS_DOMAIN}:" "zone managed by route53"
    messagePrint " - Updating Zone Record for ($JUMP_HOST)" "$pip"
    route53setDNSrecord "$pip" "$JUMP_HOST" "$AWS_HOSTED_DNS_DOMAIN"

    SSH_USER=ubuntu
    SSH_HOME=/home/ubuntu
    SSH_HOST=$pip
    SSH_OPTIONS="-o StrictHostKeyChecking=no -o RequestTTY=yes -o ServerAliveInterval=30"
    SCP_OPTIONS="-o StrictHostKeyChecking=no"
    SSH_COMMAND="ssh -q $SSH_OPTIONS ${SSH_USER}@${SSH_HOST}"
    SCP_COMMAND="scp -r $SCP_OPTIONS"
  fi

  # --- WAIT UNTIL SSH DEAMON IS READY NO JUMPHOST ----
  ret=1
  while [ $ret -ne 0 ]; do
    $SSH_COMMAND -n id > /dev/null 2>&1; ret=$?
    [ $ret -ne 0 ] && sleep 10
  done
} 

#ffffffffff
cleanupEnvironment() {
  env="$1"
  loc="$2"

  if [ "${PCF_DEPLOYMENT_CLOUD}" == "AWS" ]; then
    export ENV_NAME=$env
    export AWS_LOCATION=$loc

    # --- DELETE INSTANCES ---
    SECGRP=/tmp/$$_aws_routing_table.json
    aws --region $AWS_LOCATION ec2 describe-instances > $SECGRP
    tot=$(grep -c "InstanceId" $SECGRP); i=0; let tot=tot-1
    while [ $i -le $tot ]; do
      gid=$(jq -r ".Reservations[$i].Instances[].InstanceId" 2>/dev/null $SECGRP)
  
      cnt=$(jq -r ".Reservations[$i].Instances[].Tags[].Value" 2>/dev/null $SECGRP | egrep -c "^${ENV_NAME}|p-bosh")
      if [ $cnt -gt 0 ]; then
        cnt=$(jq -r ".Reservations[$i].Instances[].State.Name" 2>/dev/null $SECGRP | egrep -c "terminated")
        if [ $cnt -eq 0 ]; then
          messagePrint " - Terminate Instance:" "$gid"
          #aws --region $AWS_LOCATION ec2 terminate-instances --instance-ids $gid > /dev/null 2>&1
a=1
          if [ $? -ne 0 ]; then
            echo "ERROR: failled to Terminage Instance: $gid"
            echo "aws --region $AWS_LOCATION ec2 terminate-instances  --instance-ids $gid"
            exit 1
          fi
        fi
      fi
  
      let i=i+1
    done

    if [ "${PCF_TILE_PAS_DEPLOY}" == "true" ]; then PCFMODE=pas; else PCFMODE=pks; fi
    $SSH_COMMAND -n "[ -d $SSH_HOME/workspace/cf-terraform-aws/terraforming-$PCFMODE ] && \
          cd $SSH_HOME/workspace/cf-terraform-aws/terraforming-$PCFMODE; terraform destroy -auto-approve" > /dev/null 2>&1
    if [ $? -eq 0 ]; then
      messagePrint " - Terraform destroy on environment" "succeeded"
    else
      messagePrint " - Terraform destroy on environment" "failed"
    fi

    cleanAWSenv
  fi

}

route53deleteHostedZone() {
  ZONE_ID=$1
  aws route53 list-resource-record-sets --hosted-zone-id $ZONE_ID | jq -c '.ResourceRecordSets[]' | \
  while read -r resourcerecordset; do
    read -r name type <<<$(echo $(jq -r '.Name,.Type' <<<"$resourcerecordset"))

     if [ $type != "NS" -a $type != "SOA" ]; then
        aws route53 change-resource-record-sets \
          --hosted-zone-id $ZONE_ID \
          --change-batch '{"Changes":[{"Action":"DELETE","ResourceRecordSet":
          '"$resourcerecordset"'
        }]}' \
        --output text --query 'ChangeInfo.Id' >/dev/null 2>&1
     fi
  done

  aws route53 delete-hosted-zone --id $ZONE_ID >/dev/null 2>&1
  if [ $? -ne 0 ]; then
    echo "ERROR: failed to delete AWS Route53 zone $ZONE_ID"
    echo "       => aws route53 delete-hosted-zone --id $ZONE_ID"
    #exit 1
  fi
}

route53createHostedZone() {
  zone=$1

  ZONE_ID=$(aws route53 list-hosted-zones-by-name --dns-name ${zone} | jq -r ".HostedZones[] | select(.Name | \
            scan(\"^$zone.\")).Id")
  if [ "${ZONE_ID}" != "" ]; then 
    route53deleteHostedZone $ZONE_ID
  fi

  aws route53 create-hosted-zone --name $zone --caller-reference "$(date)" \
       --hosted-zone-config Comment="Managed by pcfconfig" > /dev/null 2>&1
  if [ $? -ne 0 ]; then
      echo "ERROR: failed to create AWS Route53 zone $ZONE_ID"
      echo "       => aws route53 create-hosted-zone --name $zone --caller-reference \"$(date)\" \\"
      echo "          --hosted-zone-config Comment=\"command-line version\""
      exit 1
  fi

  ZONE_ID=$(aws route53 list-hosted-zones-by-name --dns-name ${zone} | jq -r ".HostedZones[] | select(.Name | \
            scan(\"^$zone.\")).Id")
  NAME_SERVERS=$(aws route53 get-hosted-zone --id $ZONE_ID | jq -r '.DelegationSet.NameServers[]')

  # --- CREATE ZONE ---
  route53setNSrecord $zone "$AWS_HOSTED_DNS_DOMAIN" "$NAME_SERVERS"
}

route53getIPaddress() {
  env=$1
  dom=$2
  hst="jump-${env}.${dom}."
  ZONE_ID=$(aws route53 list-hosted-zones-by-name --dns-name ${dom} | jq -r ".HostedZones[] | select(.Name | \
            scan(\"^$dom.\")).Id")
  ZONE_ID_STR=$(echo "${ZONE_ID}" | awk -F'/' '{ print $NF }')

  aws route53 list-resource-record-sets --hosted-zone-id $ZONE_ID_STR --query "ResourceRecordSets[?Name == '${hst}']" | \
  jq -r '.[].ResourceRecords[].Value'
}

#route53setNSrecord "$pip" "$JUMP_HOST" "$AWS_HOSTED_DNS_DOMAIN"
route53setNSrecord () {
  hnm=$1; dom=$2; dns="$3"

  ZONE_ID=$(aws route53 list-hosted-zones-by-name --dns-name ${dom} | jq -r ".HostedZones[] | select(.Name | \
            scan(\"^$dom.\")).Id")
  ZONE_ID_STR=$(echo "${ZONE_ID}" | awk -F'/' '{ print $NF }')
  if [ "${ZONE_ID}" == "" ]; then
    echo "ERROR: ZoneID for domain $dom can not be optained, please veriofy manually"
    echo "       aws route53 list-hosted-zones-by-name --dns-name ${dom}"
    exit 1
  fi

  DNS1=$(echo $dns | awk '{ print $1 }') 
  DNS2=$(echo $dns | awk '{ print $2 }') 
  DNS3=$(echo $dns | awk '{ print $3 }') 
  DNS4=$(echo $dns | awk '{ print $4 }') 

  TMPROUTE53=/tmp/$$_tmp_route53.json
  echo "{"                                                   >  $TMPROUTE53
  echo "  \"Comment\": \"CREATE/DELETE/UPSERT a record \","  >> $TMPROUTE53
  echo "  \"Changes\": [{"                                   >> $TMPROUTE53
  echo "  \"Action\": \"UPSERT\","                           >> $TMPROUTE53
  echo "  \"ResourceRecordSet\": {"                          >> $TMPROUTE53
  echo "    \"Name\": \"${hnm}\","                           >> $TMPROUTE53
  echo "    \"Type\": \"NS\","                               >> $TMPROUTE53
  echo "    \"TTL\": 300,"                                   >> $TMPROUTE53
  echo "    \"ResourceRecords\": [ "                         >> $TMPROUTE53
  echo "      { \"Value\": \"${DNS1}\" },"                   >> $TMPROUTE53
  echo "      { \"Value\": \"${DNS2}\" },"                   >> $TMPROUTE53
  echo "      { \"Value\": \"${DNS3}\" },"                   >> $TMPROUTE53
  echo "      { \"Value\": \"${DNS4}\" }"                    >> $TMPROUTE53
  echo "    ]"                                               >> $TMPROUTE53
  echo "}}]"                                                 >> $TMPROUTE53
  echo "}"                                                   >> $TMPROUTE53

  aws route53 change-resource-record-sets --hosted-zone-id $ZONE_ID \
      --change-batch file://${TMPROUTE53} > /dev/null 2>&1
  if [ $? -ne 0 ]; then
    echo "ERROR: failed to set DNS for $hnm"
    echo "       => aws route53 change-resource-record-sets --hosted-zone-id \"${ZONE_ID}\" \\"
    echo "              --change-batch file://${TMPROUTE53}"
    cat /tmp/$$_zone_record
    exit 1
  fi
}

#route53setDNSrecord "$pip" "$JUMP_HOST" "$AWS_HOSTED_DNS_DOMAIN"
route53setDNSrecord () {
  ipa=$1; hnm=$2; dom=$3

  ZONE_ID=$(aws route53 list-hosted-zones-by-name --dns-name ${dom} | jq -r '.HostedZones[0].Id')
  ZONE_ID_STR=$(echo "${ZONE_ID}" | awk -F'/' '{ print $NF }')
  if [ "${ZONE_ID}" == "" ]; then 
    echo "ERROR: ZoneID for domain $dom can not be optained, please veriofy manually"
    echo "       aws route53 list-hosted-zones-by-name --dns-name ${dom}"
    exit 1
  fi

cat << EOF | sed -e "s/FQHN/$hnm/g" -e "s/IPADDR/$ipa/g" > /tmp/$$_zone_record
{
            "Comment": "CREATE/DELETE/UPSERT a record ",
            "Changes": [{
            "Action": "UPSERT",
                        "ResourceRecordSet": {
                                    "Name": "FQHN",
                                    "Type": "A",
                                    "TTL": 300,
                                 "ResourceRecords": [{ "Value": "IPADDR"}]
}}]
}
EOF

   aws route53 change-resource-record-sets --hosted-zone-id "${ZONE_ID}" --change-batch file:///tmp/$$_zone_record > /dev/null 2>&1
   if [ $? -ne 0 ]; then 
     echo "ERROR: failed to set DNS for $hnm"
     echo "       => aws route53 change-resource-record-sets --hosted-zone-id "${ZONE_ID}" --change-batch file:///tmp/$$_zone_record"
     cat /tmp/$$_zone_record
     exit 1
   fi
}

cleanRoute53() {
  if [ "${ROUTE53_TOKEN}" != "" -a "${DNS_SUFFIX}" != "" ]; then 
    aws route53 list-hosted-zones-by-name --dns-name $DNS_SUFFIX --hosted-zone-id $ROUTE53_TOKEN > /dev/null 2>&1
    if [ $? -eq 0 ]; then
      TMPAWS=/tmp/$$_tmp_route54.json
      aws route53 list-hosted-zones-by-name --dns-name $ENV_NAME.$DNS_SUFFIX --hosted-zone-id $ROUTE53_TOKEN > $TMPAWS
      for zone in $(jq -r '.HostedZones[].Id' $TMPAWS); do
        messagePrint " - Deleting Route53 Zone:" "[$zone]" 
  
        aws route53 list-resource-record-sets --hosted-zone-id $zone | jq -c '.ResourceRecordSets[]' | \
        while read -r resourcerecordset; do
          read -r name type <<<$(echo $(jq -r '.Name,.Type' <<<"$resourcerecordset"))
  
           if [ $type != "NS" -a $type != "SOA" ]; then
              aws route53 change-resource-record-sets \
                --hosted-zone-id $zone \
                --change-batch '{"Changes":[{"Action":"DELETE","ResourceRecordSet":
                '"$resourcerecordset"'
              }]}' \
              --output text --query 'ChangeInfo.Id' >/dev/null 2>&1
           fi
        done
  
        aws route53 delete-hosted-zone --id $zone >/dev/null 2>&1
      done
    fi
  fi
}

preCleanGCP() {
  list=$(gcloud compute zones list | grep "${GCP_REGION}" 2>/dev/null | awk '{ print $1 }')
  GCP_AZ1=$(echo $list | awk '{ print $1 }')
  GCP_AZ2=$(echo $list | awk '{ print $2 }')
  GCP_AZ3=$(echo $list | awk '{ print $3 }')
  GCP_AVAILABILITY_ZONES="$GCP_AZ1,$GCP_AZ2,$GCP_AZ3"

  rm -f /tmp/$$_tmp; touch /tmp/$$_tmp
  DNS_ZONE=${PCF_DEPLOYMENT_ENV_NAME}-zone
  gcloud dns record-sets import --delete-all-existing -z $DNS_ZONE /tmp/$$_tmp >/dev/null 2>&1
  gcloud dns managed-zones delete $DNS_ZONE >/dev/null 2>&1
} 

preCleanAWS() {
echo "functions: preCleanAWS gaga1"
#gaga99999999999
  # --- DELETE PKS LOAD-BALANCERS ---
  for n in elb-api-lb k8s-master-cl1 k8s-master-cl2 k8s-master-cl3; do
    aws --region $AWS_LOCATION elb describe-load-balancers --load-balancer-names $n >/dev/null 2>&1
    if [ $? -eq 0 ]; then
      for tag in $(aws --region $AWS_LOCATION elb describe-tags --load-balancer-name $nam 2>/dev/null | \
        jq -r '.TagDescriptions[].Tags[].Value'); do

        # --- DELETE LOAD-BALANCERS WITH TAG ENV_NAME ---
        enm=$(aws --region $AWS_LOCATION elb describe-tags --load-balancer-name $nam | \
            jq -r '.TagDescriptions[].Tags[].Value' | grep -c "${ENV_NAME}")

        # --- CLEANUOP NGINX-INGRESS-LOADBALANCER ---
        cnt=$(echo $tag | egrep -c "nginx-ingress-controller")
        if [ ${cnt} -gt 0 -o ${enm} -gt 0 ]; then
          messagePrint " - Cleaning up elp Load-Balancers:" "$nam"
          aws --region $AWS_LOCATION elb delete-load-balancer --load-balancer-name $nam >/dev/null 2>&1
          if [ $? -ne 0 ]; then
            echo "ERROR: failled to delete load-balancer: $nam"
            echo "aws --region $AWS_LOCATION elb delete-load-balancer --load-balancer-name $nam"
            exit 1
          fi
        fi
      done
    fi
  done
echo "functions: preCleanAWS gaga2"
}

cleanAWSenv() {
  # --- DELETE HOSTED ZONE ---
  domain="$ENV_NAME.$AWS_HOSTED_DNS_DOMAIN"
  ZONE_ID=$(aws route53 list-hosted-zones-by-name --dns-name ${domain} | \
            jq -r ".HostedZones[] | select(.Name | scan(\"^$domain.\")).Id")

  if [ "${ZONE_ID}" != "" ]; then
    messagePrint " - Deleting DNS Hosted Zone:" "$ZONE_ID"
    route53deleteHostedZone $ZONE_ID
  fi

  # --- DELETE INSTANCES ---
  SECGRP=/tmp/$$_aws_routing_table.json
  aws --region $AWS_LOCATION ec2 describe-instances > $SECGRP
  tot=$(grep -c "InstanceId" $SECGRP); i=0; let tot=tot-1
  while [ $i -le $tot ]; do
    gid=$(jq -r ".Reservations[$i].Instances[].InstanceId" 2>/dev/null $SECGRP)

    cnt=$(jq -r ".Reservations[$i].Instances[].Tags[].Value" 2>/dev/null $SECGRP | egrep -c "^${ENV_NAME}|p-bosh")
    if [ $cnt -gt 0 ]; then
      cnt=$(jq -r ".Reservations[$i].Instances[].State.Name" 2>/dev/null $SECGRP | egrep -c "terminated")
      if [ $cnt -eq 0 ]; then
        messagePrint " - Terminate Instance:" "$gid"
        aws --region $AWS_LOCATION ec2 terminate-instances --instance-ids $gid > /dev/null 2>&1
        if [ $? -ne 0 ]; then
          echo "ERROR: failled to Terminage Instance: $gid"
          echo "aws --region $AWS_LOCATION ec2 terminate-instances  --instance-ids $gid"
          exit 1
        fi

        sleep 30
      fi
    fi
    
    let i=i+1
  done

  # --- CLEANUP ---
  rm -f $SECGRP

  # --- IAM DELETE ROLES ---
  TMPAWS=/tmp/$$_aws.json
  aws --region $AWS_LOCATION iam list-instance-profiles > $TMPAWS
  tot=$(grep -c "InstanceProfileId" $TMPAWS); i=0; let tot=tot-1
  while [ $i -le $tot ]; do
    arn=$(jq -r ".InstanceProfiles[$i].InstanceProfileId" 2>/dev/null $TMPAWS)
    nam=$(jq -r ".InstanceProfiles[$i].InstanceProfileName" 2>/dev/null $TMPAWS)

    cnt=$(echo $nam | egrep -c "^${ENV_NAME}_")
    if [ $cnt -gt 0 ]; then
      messagePrint " - Delete IAM Instance Profile:" "$nam"
      for rol in $(jq -r ".InstanceProfiles[$i].Roles[].RoleName" 2>/dev/null $TMPAWS); do
        aws --region $AWS_LOCATION iam remove-role-from-instance-profile \
           --instance-profile-name $nam --role-name $rol 
      done

      aws --region $AWS_LOCATION iam delete-instance-profile --instance-profile-name $nam > /dev/null 2>&1
      if [ $? -ne 0 ]; then
        echo "ERROR: failled to delete IAM Instance Profile: $nam"
        echo "aws --region $AWS_LOCATION iam delete-instance-profile --instance-profile-name $nam"
        exit 1
      fi
    fi
    let i=i+1
  done
 
  # --- DELETE KMS ALIASES ---
  aws --region eu-central-1 kms list-aliases --query "Aliases[?contains(to_string(AliasName),'$ENV_NAME')]" > $TMPAWS
  tot=$(grep -c "PolicyName" $TMPAWS); i=0
  while [ $i -lt $tot ]; do
    tid=$(jq -r ".[$i].TargetKeyId" 2>/dev/null $TMPAWS)
    arn=$(jq -r ".[$i].AliasArn" 2>/dev/null $TMPAWS)
    nam=$(jq -r ".[$i].AliasName" 2>/dev/null $TMPAWS)

    messagePrint " - Delete KMS Alias:" "$nam"
  done


  # --- IAM DELETE POLICIES ---
  aws --region $AWS_LOCATION iam list-roles --query "Roles[?starts_with(to_string(RoleName), '$ENV_NAME')]" > $TMPAWS
  tot=$(grep -c "PolicyName" $TMPAWS); i=0
  while [ $i -lt $tot ]; do
    rid=$(jq -r ".[$i].PolicyId" 2>/dev/null $TMPAWS)
    arn=$(jq -r ".[$i].Arn" 2>/dev/null $TMPAWS)
    nam=$(jq -r ".[$i].PolicyName" 2>/dev/null $TMPAWS)

    messagePrint " - 1Delete IAM Policy:" "$nam"
    aws --region $AWS_LOCATION kms delete-alias --alias-name "$nam" 
  done

  # --- IAM DELETE ROLES ---
  TMPAWS=/tmp/$$_aws.json
  aws --region $AWS_LOCATION iam list-roles --query "Roles[?starts_with(to_string(RoleName), '$ENV_NAME')]" > $TMPAWS

  tot=$(grep -c "RoleName" $TMPAWS); i=0
  while [ $i -lt $tot ]; do
    rid=$(jq -r ".[$i].RoleId" 2>/dev/null $TMPAWS)
    arn=$(jq -r ".[$i].Arn" 2>/dev/null $TMPAWS)
    nam=$(jq -r ".[$i].RoleName" 2>/dev/null $TMPAWS)

    messagePrint " - Delete IAM Role:" "$nam"

    for tmp in $(aws --region $AWS_LOCATION  iam list-policies | jq -r '.Policies[].Arn' | grep $ENV_NAME); do 
      usr=$(aws --region $AWS_LOCATION iam list-entities-for-policy --policy-arn $tmp | jq -r '.PolicyUsers[].UserName')
      grp=$(aws --region $AWS_LOCATION iam list-entities-for-policy --policy-arn $tmp | jq -r '.PolicyGroups[].GroupName')
      rol=$(aws --region $AWS_LOCATION iam list-entities-for-policy --policy-arn $tmp | jq -r '.PolicyRoles[].RoleName')
      if [ "${usr}" != "" ]; then
        aws --region $AWS_LOCATION iam detach-user-policy --policy-arn $tmp --user-name $usr
      fi

      if [ "${rol}" != "" ]; then
        aws --region $AWS_LOCATION iam detach-role-policy --policy-arn $tmp --role-name $rol
      fi

      if [ "${grp}" != "" ]; then
        aws --region $AWS_LOCATION iam detach-user-policy --policy-arn $tmp --group-name $usr
      fi

      aws iam delete-policy --policy-arn $tmp
    done

    for pol in $(aws --region $AWS_LOCATION iam list-attached-role-policies --role-name $nam | \
        jq -r ".AttachedPolicies[].PolicyArn"); do

      aws --region $AWS_LOCATION iam detach-role-policy --role-name $nam --policy-arn $pol
      aws --region $AWS_LOCATION iam delete-role-policy --role-name $nam --policy-name $pol
    done

    # --- DELETE ROLE POLICY ---
    for pol in $(aws --region $AWS_LOCATION iam list-role-policies --role-name $nam | \
                 jq -r '.PolicyNames[]'); do

      aws --region $AWS_LOCATION iam delete-role-policy --role-name $nam --policy-name $pol
    done

    aws --region $AWS_LOCATION iam delete-role --role-name $nam > /dev/null 2>&1
    if [ $? -ne 0 ]; then
      echo "ERROR: failled to delete IAM Role: $nam"
      echo "       aws --region $AWS_LOCATION iam delete-role --role-name $nam"
      exit 1
    fi
    let i=i+1
  done

  # --- CLEANUP ---
  rm -f $TMPAWS

  # --- IAM DELETE USERS ---
  for arn in $(aws --region $AWS_LOCATION iam list-users | jq -r '.Users[].UserName' 2>/dev/null); do
    cnt=$(echo $arn | egrep -c "^${ENV_NAME}_")
    if [ $cnt -gt 0 ]; then
      messagePrint " - Cleaning up iam User:" "$arn"

      # --- DETACH POLICY ---
      for pol in $(aws --region $AWS_LOCATION iam list-attached-user-policies --user-name $arn | \
          jq -r ".AttachedPolicies[].PolicyArn"); do

        aws --region $AWS_LOCATION iam detach-user-policy --user-name $arn --policy-arn $pol
      done

      # --- DELETE POLICY ---
      for pol in $(aws --region $AWS_LOCATION iam list-attached-user-policies --user-name $arn | \
          jq -r ".AttachedPolicies[].PolicyName"); do

        aws --region $AWS_LOCATION iam delete-user-policy --user-name $arn --policy-name $pol
      done

      # --- DELETE ACCESS-KEYS ---
      for key in $(aws --region $AWS_LOCATION iam list-access-keys --user-name $arn | \
          jq -r ".AccessKeyMetadata[].AccessKeyId"); do

        aws --region $AWS_LOCATION iam delete-access-key --access-key-id $key --user-name $arn
      done

      aws --region $AWS_LOCATION iam delete-user --user-name $arn
      if [ $? -ne 0 ]; then
        echo "ERROR: failled to delete User"
        echo "aws --region $AWS_LOCATION iam delete-user --user-name $arn"
        exit 1
      fi
    fi
  done

#  # --- IAM DELETE POLICIES ---
#  for arn in $(aws --region $AWS_LOCATION iam list-policies | jq -r '.Policies[].Arn' 2>/dev/null); do
#echo "arn:$arn"
#echo "aws --region $AWS_LOCATION iam describe-policies --load-balancer-arns $arn"
#    nam=$(aws --region $AWS_LOCATION iam describe-policies --load-balancer-arns "$arn" | \
#        jq -r '.LoadBalancers[].LoadBalancerName')
#echo "nam:$nam"
#
#    cnt=$(echo $arn | egrep -c "^${ENV_NAME}_")
#    if [ $cnt -gt 0 ]; then
#echo "aws --region $AWS_LOCATION iam delete-policy --policy-arn $arn"
#      aws --region $AWS_LOCATION iam delete-policy --policy-arn $arn
#      messagePrint " - Cleaning up iam User:" "$arn"
#      if [ $? -ne 0 ]; then
#        echo "ERROR: failled to delete User"
#        echo "aws --region $AWS_LOCATION iam delete-user --user-name $arn"
#        exit 1
#      fi
#    fi
#  done

  # --- DELETE LOAD BALANCERS ---
  TMPAWS=/tmp/$$_aws.json
  for nam in $(aws --region $AWS_LOCATION elb describe-load-balancers | jq -r '.LoadBalancerDescriptions[].LoadBalancerName' 2>/dev/null); do
    aws --region $AWS_LOCATION elb describe-load-balancers --load-balancer-names $nam >/dev/null 2>&1
    if [ $? -eq 0 ]; then
      for tag in $(aws --region $AWS_LOCATION elb describe-tags --load-balancer-name $nam 2>/dev/null | \
        jq -r '.TagDescriptions[].Tags[].Value'); do

        # --- DELETE LOAD-BALANCERS WITH TAG ENV_NAME ---
        enm=$(aws --region $AWS_LOCATION elb describe-tags --load-balancer-name $nam | \
            jq -r '.TagDescriptions[].Tags[].Value' | grep -c "${ENV_NAME}")

        # --- CLEANUOP NGINX-INGRESS-LOADBALANCER ---
        cnt=$(echo $tag | egrep -c "nginx-ingress-controller") 
        if [ ${cnt} -gt 0 -o ${enm} -gt 0 ]; then
          messagePrint " - Cleaning up elp Load-Balancers:" "$nam"
          aws --region $AWS_LOCATION elb delete-load-balancer --load-balancer-name $nam >/dev/null 2>&1
          if [ $? -ne 0 ]; then
            echo "ERROR: failled to delete load-balancer: $nam"
            echo "aws --region $AWS_LOCATION elb delete-load-balancer --load-balancer-name $nam"
            exit 1
          fi
        fi
      done
    fi
  done

  rm -f $TMPAWS

  # --- DELETE LOAD BALANCERS ---
  for arn in $(aws --region $AWS_LOCATION elbv2 describe-load-balancers | jq -r '.LoadBalancers[].LoadBalancerArn' 2>/dev/null); do
    nam=$(aws --region $AWS_LOCATION elbv2 describe-load-balancers --load-balancer-arns $arn | \
        jq -r '.LoadBalancers[].LoadBalancerName') 

    cnt=$(echo $nam | egrep -c "^${ENV_NAME}-")
    if [ $cnt -gt 0 ]; then 
      aws --region $AWS_LOCATION elbv2 delete-load-balancer --load-balancer-arn $arn
      messagePrint " - Cleaning up elpv2 LoadBalancers:" "$nam"
    fi
  done

  # --- DELETE TARGET GROUPS ---
  SECGRP=/tmp/$$_aws_tgp.json
  aws --region $AWS_LOCATION elbv2 describe-target-groups > $SECGRP
  tot=$(grep -c "TargetGroupArn" $SECGRP); i=0; let tot=tot-1
  while [ $i -le $tot ]; do
    sid=$(jq -r ".TargetGroups[$i].TargetGroupArn" 2>/dev/null $SECGRP)
    snm=$(jq -r ".TargetGroups[$i].TargetGroupName" 2>/dev/null $SECGRP)

    cnt=$(echo "$snm" | egrep -c "^${ENV_NAME}-")
    if [ $cnt -gt 0 ]; then
      messagePrint " - Delete Target Group:" "$snm"
      aws --region $AWS_LOCATION elbv2 delete-target-group --target-group-arn $sid > /dev/null 2>&1
      if [ $? -ne 0 ]; then
        echo "ERROR: failled to delete Target group"
        echo "aws --region $AWS_LOCATION elbv2 delete-target-group --target-group-arn $sid"
        exit 1
      fi
    fi
    let i=i+1
  done

  # --- CLEANUP ---
  rm -f $SECGRP

  for key in $(aws --region $AWS_LOCATION ec2 describe-key-pairs | jq -r '.KeyPairs[].KeyName' 2>/dev/null); do
    cnt=$(echo $key | egrep -c "^${ENV_NAME}-")
    if [ $cnt -gt 0 ]; then 
      messagePrint " - Delete KeyPair:" "$key"
      aws --region $AWS_LOCATION ec2 delete-key-pair --key-name $key >/dev/null 2>&1
      if [ $? -ne 0 ]; then
        aws --region $AWS_LOCATION ec2 delete-key-pair --key-name $key
        exit 1
      fi
    fi
  done

  # --- DELETE VPC's ---
  TMPVCP=/tmp/$$_aws_vpc.json
  aws --region $AWS_LOCATION ec2 describe-vpcs > $TMPVCP
  tot=$(grep -c "VpcId" $TMPVCP); i=0; let tot=tot-1
  while [ $i -le $tot ]; do
    vpc=$(jq -r ".Vpcs[$i].VpcId" 2>/dev/null $TMPVCP)
    cnt=$(jq -r ".Vpcs[$i].Tags[].Value" 2>/dev/null $TMPVCP | egrep -c "^${ENV_NAME}")
    if [ $cnt -eq 0 ]; then let i=i+1; continue; fi

    # --- DELETE SECURITY GROUPS BY ID ---
#    for id in $(aws --region $AWS_LOCATION ec2 describe-security-groups --filter "Name=vpc-id,Values=$vpc" | \
#                jq -r ".SecurityGroups[].GroupId" 2>/dev/null $TMPVAL); do
#
#      messagePrint " - Delete Security Group:" "$id"
#      aws --region $AWS_LOCATION ec2 delete-security-group --group-id $id > /dev/null 2>&1
#      if [ $? -ne 0 ]; then
#        echo "ERROR: failled to Security Group:: $id"
#        echo "aws --region $AWS_LOCATION ec2 delete-security-group --group-id $id"
#        exit 1
#      fi
#    done
#
#    for id in $(aws --region $AWS_LOCATION ec2 describe-security-groups --filter "Name=vpc-id,Values=$vpc" | \
#                jq -r ".SecurityGroups[].GroupName" 2>/dev/null $TMPVAL); do
#
#      messagePrint " - Delete Security Group:" "$id"
#      aws --region $AWS_LOCATION ec2 delete-security-group --group-name $id > /dev/null 2>&1
#      if [ $? -ne 0 ]; then
#        echo "ERROR: failled to Security Group:: $id"
#        echo "aws --region $AWS_LOCATION ec2 delete-security-group --group-name $id"
#        exit 1
#      fi
#    done

    # --- DELETE NAT GATEWAY ---
#    for id in $(aws --region $AWS_LOCATION ec2 describe-network-acls --filter "Name=vpc-id,Values=$vpc" | \
#                jq -r ".NetworkAcls[].NetworkAclId" 2>/dev/null $TMPVAL); do
#
#      messagePrint " - Delete Network ACL:" "$id"
#      aws --region $AWS_LOCATION ec2 delete-network-acl --network-acl-id $id > /dev/null 2>&1
#      if [ $? -ne 0 ]; then
#        echo "ERROR: failled to Network ACL: $id"
#        echo "aws --region $AWS_LOCATION ec2 delete-network-acl --network-acl-id $id"
#        #exit 1
#      fi
#    done

    # --- DELETE NAT GATEWAY ---
    for id in $(aws --region $AWS_LOCATION ec2 describe-nat-gateways --filter "Name=vpc-id,Values=$vpc" | \
                jq -r ".NatGateways[].NatGatewayId" 2>/dev/null $TMPVAL); do

      messagePrint " - Delete NAT Gateway:" "$id"
      aws --region $AWS_LOCATION ec2 delete-nat-gateway --nat-gateway-id $id > /dev/null 2>&1
      if [ $? -ne 0 ]; then
        echo "ERROR: failled to NAT Gateway: $id"
        echo "aws --region $AWS_LOCATION ec2 delete-nat-gateway --nat-gateway-id $id"
        #exit 1
      fi
    done

    sleep 10

    # --- DELETE NETWORK INTERFACVE ---
#    for id in $(aws --region $AWS_LOCATION ec2 describe-network-interfaces --filter "Name=vpc-id,Values=$vpc" | \
#                jq -r ".NetworkInterfaces[].NetworkInterfaceId" 2>/dev/null $TMPVAL); do
#
#      messagePrint " - Delete Network Interface:" "$id"
#      aws --region $AWS_LOCATION ec2 delete-network-interface --network-interface-id $id > /dev/null 2>&1
#      if [ $? -ne 0 ]; then
#        echo "ERROR: failled to Network Interface:: $id"
#        echo "aws --region $AWS_LOCATION ec2 delete-network-interface --network-interface-id $id"
#        exit 1
#      fi
#    done

    sleep 60

    # --- DELETE ADDRESSES ---
    SECGRP=/tmp/$$_aws_routing_table.json
    aws --region $AWS_LOCATION ec2 describe-addresses > $SECGRP
    tot=$(grep -c "PublicIp" $SECGRP); i=0; let tot=tot-1
    while [ $i -le $tot ]; do
      pid=$(jq -r ".Addresses[$i].PublicIp" 2>/dev/null $SECGRP)
      aid=$(jq -r ".Addresses[$i].AllocationId" 2>/dev/null $SECGRP)

      cnt=$(jq -r ".Addresses[$i].Tags[].Value" 2>/dev/null $SECGRP | egrep -c "^${ENV_NAME}")
      if [ $cnt -gt 0 ]; then
        messagePrint " - Release PublicIP:" "$pid"
        aws --region $AWS_LOCATION ec2 release-address --allocation-id $aid > /dev/null 2>&1; re1=$?
        aws --region $AWS_LOCATION ec2 release-address --public-ip $pid > /dev/null 2>&1; re2=$?
        if [ $re1 -ne 0 -a $re2 -ne 0 ]; then
#=> Delete NatGateway first (awspks-nat)
          echo "ERROR: 1failed to release IP: $pid"
          echo "aws --region $AWS_LOCATION ec2 release-address --allocation-id $aid"
          echo "aws --region $AWS_LOCATION ec2 release-address --public-ip $pid"
          exit 1
        fi

        sleep 20
      fi

      let i=i+1
    done

    # --- CLEANUP ---
    rm -f $TMPAWS

    # --- DELETE LOAD BALANCERS ---
    for nam in $(aws --region $AWS_LOCATION elb describe-load-balancers | \
         jq -r '.LoadBalancerDescriptions[].LoadBalancerName' 2>/dev/null); do
      tvpc=$(aws --region $AWS_LOCATION elb describe-load-balancers --load-balancer-name $nam | \
          jq -r '.LoadBalancerDescriptions[].VPCId')
      if [ "$tvpc" == "${vpc}" ]; then
        aws --region $AWS_LOCATION elb delete-load-balancer --load-balancer-name $nam
        messagePrint " - Cleaning up elp LoadBalancers:" "$nam"
        sleep 30
      fi
    done

    # --- DELETE INTERNET GATEWAYS ---
    for id in $(aws --region $AWS_LOCATION ec2 describe-internet-gateways --filter "Name=attachment.vpc-id,Values=$vpc" | \
                jq -r ".InternetGateways[].InternetGatewayId" 2>/dev/null); do

      messagePrint " - Detach Internet Gateway:" "$id"
      aws --region $AWS_LOCATION ec2 detach-internet-gateway --internet-gateway-id $id --vpc-id $vpc > /dev/null 2>&1
      if [ $? -ne 0 ]; then
        echo "ERROR: failled to detach internet gateway: $id"
        echo "aws --region $AWS_LOCATION ec2 detach-internet-gateway --internet-gateway-id $id --vpc-id $vpc"
        exit 1
      fi

      messagePrint " - Delete Internet Gateway:" "$id"
      aws --region $AWS_LOCATION ec2 delete-internet-gateway --internet-gateway-id $id > /dev/null 2>&1
      if [ $? -ne 0 ]; then
        echo "ERROR: failled to delete internet gateway: $id"
        echo "aws --region $AWS_LOCATION ec2 delete-internet-gateway --internet-gateway-id $id"
        exit 1
      fi
    done

    # --- DELETE SUBNETS ---
    for id in $(aws --region $AWS_LOCATION ec2 describe-subnets --filter "Name=vpc-id,Values=$vpc" | \
                jq -r ".Subnets[].SubnetId" 2>/dev/null); do

      messagePrint " - Delete Subnet:" "$id"
      aws --region $AWS_LOCATION ec2 delete-subnet --subnet-id $id > /dev/null 2>&1
      if [ $? -ne 0 ]; then
        echo "ERROR: failled to deleting subnet: $id"
        echo "aws --region $AWS_LOCATION ec2 delete-subnet --subnet-id $id"
        exit 1
      fi
    done

    SECGRP=/tmp/$$_aws_security_groups.json
    aws --region $AWS_LOCATION ec2 describe-security-groups --filter "Name=vpc-id,Values=$vpc" > $SECGRP
    tot=$(grep -c "GroupName" $SECGRP); i=0; let tot=tot-1
    while [ $i -le $tot ]; do
      gnm=$(jq -r ".SecurityGroups[$i].GroupName" 2>/dev/null $SECGRP)
      gid=$(jq -r ".SecurityGroups[$i].GroupId" 2>/dev/null $SECGRP)

      cnt=$(jq -r ".SecurityGroups[$i].Tags[].Value" 2>/dev/null $SECGRP | egrep -c "^${ENV_NAME}")
      if [ $cnt -gt 0 ]; then
        messagePrint " - Delete Security Group:" "$gnm"
        aws --region $AWS_LOCATION ec2 delete-security-group --group-id $gid > /dev/null 2>&1
        if [ $? -ne 0 ]; then
          aws --region $AWS_LOCATION ec2 delete-security-group --group-name $gnm > /dev/null 2>&1
          if [ $? -ne 0 ]; then
            echo "ERROR: failled to delete security group"
            echo "aws --region $AWS_LOCATION ec2 delete-security-group --group-id $gid"
            echo "aws --region $AWS_LOCATION ec2 delete-security-group --group-name $gnm"
            exit 1
          fi
        fi
      fi
      let i=i+1
    done

    # --- DELETE ALL SCURITY GROUPS ATTACHED TO THIS VPC ---
    for gid in $(aws --region $AWS_LOCATION ec2 describe-security-groups | \
         jq -r '.SecurityGroups[].GroupId' 2>/dev/null); do
      sgnm=$(aws --region $AWS_LOCATION ec2 describe-security-groups --group-ids  $gid | \
          jq -r '.SecurityGroups[].GroupName')
      tvpc=$(aws --region $AWS_LOCATION ec2 describe-security-groups --group-ids  $gid | \
          jq -r '.SecurityGroups[].VpcId')
      if [ "$tvpc" == "${vpc}" -a "${sgnm}" != "default" ]; then
        messagePrint " - Cleaning up SecurityGroup:" "$gid"
        aws --region $AWS_LOCATION ec2 delete-security-group --group-id $gid > /dev/null 2>&1
        if [ $? -ne 0 ]; then
          echo "ERROR: failled to delete security group"
          echo "aws --region $AWS_LOCATION ec2 delete-security-group --group-id $gid"
          exit 1
        fi
      fi

      sleep 30
    done

    # --- CLEANUP ---
    rm -f $SECGRP

    # --- DELETE IP-ADDRESS ---
#    for id in $(aws --region $AWS_LOCATION ec2 describe-route-tables --filter "Name=vpc-id,Values=$vpc" | \
#                jq -r ".RouteTables[].RouteTableId" 2>/dev/null); do
#
#      messagePrint " - Delete Routing Table:" "$id"
#
#      aws --region $AWS_LOCATION ec2 delete-route-table --route-table-id $id> /dev/null 2>&1
#      if [ $? -ne 0 ]; then
#        echo "ERROR: failled to delete routing table: $id"
#        echo "aws --region $AWS_LOCATION ec2 delete-route-table --route-table-id $id"
#        #exit 1
#      fi
#    done

    # --- DELETE ROUTING TABLES ---
    for id in $(aws --region $AWS_LOCATION ec2 describe-route-tables --filter "Name=vpc-id,Values=$vpc" | \
                jq -r ".RouteTables[].RouteTableId" 2>/dev/null); do

      messagePrint " - Delete Routing Table:" "$id"
      aws --region $AWS_LOCATION ec2 delete-route-table --route-table-id $id> /dev/null 2>&1
      #if [ $? -ne 0 ]; then
      #  echo "ERROR: failled to delete routing table: $id"
      #  echo "aws --region $AWS_LOCATION ec2 delete-route-table --route-table-id $id"
      #  #exit 1
      #fi
    done

    # --- DELETE VPC ---
    messagePrint " - Delete VPC:" "$vpc"
    aws --region $AWS_LOCATION ec2 delete-vpc --vpc-id $vpc > /dev/null 2>&1
    if [ $? -ne 0 ]; then
      echo "ERROR: failled to delete VPC: $vpc"
      echo "aws --region $AWS_LOCATION ec2 delete-vpc --vpc-id $vpc"
      exit 1
    fi

    let i=i+1
  done

  # --- CLEANUP ---
  rm -f $TMPVCP

  SECGRP=/tmp/$$_aws_routing_table.json
  aws --region $AWS_LOCATION ec2 describe-route-tables > $SECGRP
  tot=$(grep -c "RouteTableId" $SECGRP); i=0; let tot=tot-1
  while [ $i -le $tot ]; do
    gid=$(jq -r ".RouteTables[$i].RouteTableId" 2>/dev/null $SECGRP)

    cnt=$(jq -r ".RouteTables[$i].Tags[].Value" 2>/dev/null $SECGRP | egrep -c "^${ENV_NAME}")
    if [ $cnt -gt 0 ]; then
      messagePrint " - Delete Routing Table:" "$gid"
      aws --region $AWS_LOCATION ec2 delete-route-table --group-id $gid > /dev/null 2>&1
      if [ $? -ne 0 ]; then
        echo "ERROR: failled to delete Routing Table: $gid"
        echo "aws --region $AWS_LOCATION ec2 delete-route-table --route-table-id $gid"
        exit 1
      fi
    fi
    let i=i+1
  done

  # --- CLEANUP ---
  rm -f $SECGRP

  SECGRP=/tmp/$$_aws_nat_gateways.json
  aws --region $AWS_LOCATION ec2 describe-nat-gateways > $SECGRP
  tot=$(grep -c "GroupName" $SECGRP); i=0; let tot=tot-1
  while [ $i -le $tot ]; do
    gid=$(jq -r ".NatGateways[$i].NatGatewayId" 2>/dev/null $SECGRP)

    cnt=$(jq -r ".NatGateways[$i].Tags[].Value" 2>/dev/null $SECGRP | egrep -c "^${ENV_NAME}")
    if [ $cnt -gt 0 ]; then
      messagePrint " - Delete NAT Gateway:" "$gid"
      aws --region $AWS_LOCATION ec2 delete-nat-gateway --group-id $gid > /dev/null 2>&1
      if [ $? -ne 0 ]; then
        aws --region $AWS_LOCATION ec2 delete-nat-gateway --nat-gateway-id $gid > /dev/null 2>&1
        if [ $? -ne 0 ]; then
          echo "ERROR: failled to delete NAT Gateway: $gid"
          echo "aws --region $AWS_LOCATION ec2 delete-nat-gateway --group-id $gid"
          exit 1
        fi
      fi
    fi
    let i=i+1
  done

  # --- CLEANUP ---
  rm -f $SECGRP

  SECGRP=/tmp/$$_aws_security_groups.json
  aws --region $AWS_LOCATION ec2 describe-security-groups > $SECGRP
  tot=$(grep -c "GroupName" $SECGRP); i=0; let tot=tot-1
  while [ $i -le $tot ]; do
    gnm=$(jq -r ".SecurityGroups[$i].GroupName" 2>/dev/null $SECGRP)
    gid=$(jq -r ".SecurityGroups[$i].GroupId" 2>/dev/null $SECGRP)
#gugu

    cnt=$(jq -r ".SecurityGroups[$i].Tags[].Value" 2>/dev/null $SECGRP | egrep -c "^${ENV_NAME}")
    if [ $cnt -gt 0 ]; then 
      messagePrint " - Delete Sevcurity Group:" "$gnm"
      aws --region $AWS_LOCATION ec2 delete-security-group --group-id $gid > /dev/null 2>&1
      if [ $? -ne 0 ]; then 
        aws --region $AWS_LOCATION ec2 delete-security-group --group-name $gnm > /dev/null 2>&1
        if [ $? -ne 0 ]; then 
          echo "ERROR: failled to delete security group"
          echo "aws --region $AWS_LOCATION ec2 delete-security-group --group-id $gid"
          echo "aws --region $AWS_LOCATION ec2 delete-security-group --group-name $gnm"
          exit 1
        fi
      fi
    fi
    let i=i+1
  done

  # --- CLEANUP ---
  rm -f $SECGRP

  SECGRP=/tmp/$$_aws_subnets.json
  aws --region $AWS_LOCATION ec2 describe-subnets > $SECGRP
  tot=$(grep -c "SubnetId" $SECGRP); i=0; let tot=tot-1
  while [ $i -le $tot ]; do
    sid=$(jq -r ".Subnets[$i].SubnetId" 2>/dev/null $SECGRP)

    cnt=$(jq -r ".Subnets[$i].Tags[].Value" 2>/dev/null $SECGRP | egrep -c "^${ENV_NAME}")
    if [ $cnt -gt 0 ]; then
      messagePrint " - Delete Subnet:" "$sid"
      aws --region $AWS_LOCATION ec2 delete-subnet --subnet-id $sid > /dev/null 2>&1
      if [ $? -ne 0 ]; then
        echo "ERROR: failled to delete security group"
        echo "aws --region $AWS_LOCATION ec2 delete-subnet --subnet-id $sid"
        exit 1
      fi
    fi
    let i=i+1
  done

  # --- CLEANUP ---
  rm -f $SECGRP

  # --- DELETE ADDRESSES ---
  SECGRP=/tmp/$$_aws_routing_table.json
  aws --region $AWS_LOCATION ec2 describe-addresses > $SECGRP
  tot=$(grep -c "PublicIp" $SECGRP); i=0; let tot=tot-1
  while [ $i -le $tot ]; do
    pid=$(jq -r ".Addresses[$i].PublicIp" 2>/dev/null $SECGRP)
    aid=$(jq -r ".Addresses[$i].AllocationId" 2>/dev/null $SECGRP)

    cnt=$(jq -r ".Addresses[$i].Tags[].Value" 2>/dev/null $SECGRP | egrep -c "^${ENV_NAME}")
    if [ $cnt -gt 0 ]; then
      messagePrint " - Release PublicIP:" "$pid"
      aws --region $AWS_LOCATION ec2 release-address --allocation-id $aid > /dev/null 2>&1; re1=$?
      aws --region $AWS_LOCATION ec2 release-address --public-ip $pid > /dev/null 2>&1; re2=$?
      if [ $re1 -ne 0 -a $re2 -ne 0 ]; then
#=> Delete NatGateway first (awspks-nat)
        echo "ERROR: 2failed to release IP: $pid"
        echo "aws --region $AWS_LOCATION ec2 release-address --allocation-id $aid"
        echo "aws --region $AWS_LOCATION ec2 release-address --public-ip $pid"
        exit 1
      fi

      sleep 20
    fi
   
    let i=i+1
  done

  # --- CLEANUP ---
  rm -f $TMPAWS

  # --- IAM DELETE POLICIES ---
  TMPAWS=/tmp/$$_aws.json
  aws --region $AWS_LOCATION iam list-policies > $TMPAWS
  tot=$(grep -c "PolicyName" $TMPAWS); i=0; let tot=tot-1
  while [ $i -le $tot ]; do
    arn=$(jq -r ".Policies[$i].Arn" 2>/dev/null $TMPAWS)
    nam=$(jq -r ".Policies[$i].PolicyName" 2>/dev/null $TMPAWS)

    cnt=$(echo $nam | egrep -c "^${ENV_NAME}_")
    if [ $cnt -gt 0 ]; then
      messagePrint " - Delete IAM Policy:" "$nam"
      rol=$(aws iam list-entities-for-policy --policy-arn $arn | jq -r '.PolicyRoles[].RoleName')
      if [ "$rol" != "" ]; then 
        aws --region $AWS_LOCATION iam detach-role-policy --role-name $rol --policy-arn $arn > /dev/null 2>&1
      fi

      aws --region $AWS_LOCATION iam delete-policy --policy-arn $arn > /dev/null 2>&1
      if [ $? -ne 0 ]; then
        echo "ERROR: failled to delete IAM Policy: $nam"
        echo "aws --region $AWS_LOCATION iam delete-policy --policy-arn $arn"
        exit 1
      fi
    fi
    let i=i+1
  done

  # --- CLEANUP ---
  rm -f $SECGRP

  for alias in $(aws --region $AWS_LOCATION kms list-aliases | jq -r '.Aliases[].AliasName'); do
    cnt=$(echo $alias | egrep -c "alias/${ENV_NAME}") 
    if [ $cnt -gt 0 ]; then 
      messagePrint " - Delete KMS Alias:" "$alias"
      aws --region $AWS_LOCATION kms delete-alias --alias-name $alias
    fi
  done

  # --- DELETE S3 BUCKETS ---
  for bucket in $(aws s3api --region=$AWS_LOCATION list-buckets | jq -r '.Buckets[].Name' | \
                egrep "^${ENV_NAME}-"); do
    messagePrint " - Delete S3 Bucket:" "$bucket"
    aws s3api --region=$AWS_LOCATION delete-bucket --bucket $bucket > /dev/null 2>&1
    #if [ $? -ne 0 ]; then
    #  echo "ERROR: failled to delete S3 Bucket: $nam"
    #  echo "aws s3api --region $AWS_LOCATION delete-bucket --bucket $bucket"
    #  exit 1
    #fi
  done

  # --- DELETE EBS VOLUMES
  TMPAWS=/tmp/$$_vol_aws.json
  aws --region $AWS_LOCATION ec2 describe-volumes > $TMPAWS
  i=0; tot=$(jq -r ".Volumes[$i].VolumeId" 2>/dev/null $TMPAWS | egrep -c "^vol-")

  while [ $i -lt $tot ]; do
    stt=$(jq -r ".Volumes[$i].State" 2>/dev/null $TMPAWS)
    vid=$(jq -r ".Volumes[$i].VolumeId" 2>/dev/null $TMPAWS)
    cnt=$(jq -r ".Volumes[$i].Tags[].Value" $TMPAWS 2>/dev/null| egrep -c "p-bosh|bosh-init") 

    if [ $cnt -gt 0 ]; then 
      if [ "$stt" == "available" ]; then 
        messagePrint " - Delete Volume:" "$vid"
        aws --region $AWS_LOCATION ec2 delete-volume --volume-id $vid > /dev/null 2>&1
        if [ $? -ne 0 ]; then
          echo "ERROR: failled to delete volume: $vid"
          echo "aws --region $AWS_LOCATION ec2 delete-volume --volume-id $vid"
          exit 1
        fi
      else
        messagePrint " - Detaching Volume:" "$vid"
        #aws ec2 --region $AWS_LOCATION detach-volume --volume-id $vid > /dev/null 2>&1
        #aws ec2 --region $AWS_LOCATION ec2 delete-volume --volume-id $vid > /dev/null 2>&1
      fi
    fi

    let i=i+1
  done
  rm -f $SECGRP
}

cleanGCPenv() {
  list=$(gcloud compute zones list | grep "${GCP_REGION}" 2>/dev/null | awk '{ print $1 }')
  GCP_AZ1=$(echo $list | awk '{ print $1 }')
  GCP_AZ2=$(echo $list | awk '{ print $2 }')
  GCP_AZ3=$(echo $list | awk '{ print $3 }')
  GCP_AVAILABILITY_ZONES="$GCP_AZ1,$GCP_AZ2,$GCP_AZ3"

  for tmp in $(gcloud compute instances list --zones="$GCP_AVAILABILITY_ZONES" \
               --filter="name!='jump-${PCF_DEPLOYMENT_ENV_NAME}'" 2>/dev/null | \
               grep -v "NAME" | awk '{ printf("%s:%s\n",$1,$2)}'); do

    ins=$(echo $tmp | awk -F: '{ print $1 }')
    reg=$(echo $tmp | awk -F: '{ print $2 }')
    messagePrint " - Terminate Instance:" "$ins"
    gcloud compute instances delete $ins --zone $reg -q > /dev/null 2>&1
  done

  # --- DELETE IMAGES ---
  for n in $(gcloud compute images list 2>/dev/null | \
        egrep "^$ENV_NAME" | awk '{ print $1 }'); do

    # --- DONT DELETE PCFJUMP VM ---
    cnt=$(echo "$n" | egrep -c "^pcfjump")
    if [ $cnt -eq 0 ]; then
      messagePrint " - Cleaning up GCP Image:" "$n"
      gcloud compute images delete ${n} -q > /dev/null 2>&1
      if [ $? -ne 0 ]; then
        gcloud compute images delete ${n} -q
        exit 1
      fi
    fi
  done

  # --- DELETE DNS ZONES ---
  for n in $(gcloud dns managed-zones list 2>/dev/null | \
        egrep "^${ENV_NAME}-" | awk '{ print $1 }'); do

    gcloud dns record-sets import -z $n --delete-all-existing >/dev/null 2>&1
    #for zone in $(gcloud dns record-sets list --zone=$n 2>/dev/null | grep -v "NAME" | \
    #              awk '{ print $1 }'); do
#
#      messagePrint " - Deleting DNS Zone Records of zone $n:" "$zone"
#      gcloud dns record-sets transaction remove -z $n ${zone} -q > /dev/null 2>&1
#    done

    # --- DONT DELETE PCFJUMP VM ---
    messagePrint " - Deleting DNS Zone:" "$n"
    gcloud dns managed-zones delete ${n} -q > /dev/null 2>&1
    if [ $? -ne 0 ]; then
      gcloud dns managed-zones delete ${n} -q
      exit 1
    fi
  done

  # --- DELETE INSTANCES ---
  for n in $(gcloud compute instances list --filter="zone:($GCP_REGION)" 2>/dev/null | \
        grep -v "NAME" | awk '{ printf("%s:%s\n",$1,$2)}'); do

    # --- DONT DELETE PCFJUMP VM ---
    cnt=$(echo "$n" | egrep -c "^jump-")
    if [ $cnt -eq 0 ]; then
      nam=$(echo $n | awk -F: '{ print $1 }')
      zon=$(echo $n | awk -F: '{ print $2 }')
      messagePrint " - Cleaning up GCP Instance:" "$n"
      gcloud compute instances delete ${nam} --zone ${zon} -q > /dev/null 2>&1
      if [ $? -ne 0 ]; then 
        echo "ERROR deleting instance $n"
        echo "      => gcloud compute instances delete ${nam} --zone ${zon} -q"
        exit 1
      fi
    fi
  done

  # --- DELETE FRONTEND ---
  for n in $(gcloud compute forwarding-rules list 2>/dev/null | \
        egrep "^${ENV_NAME}-" | awk '{ printf("%s:%s\n",$1,$2)}'); do

    nam=$(echo $n | awk -F: '{ print $1 }')
    zon=$(echo $n | awk -F: '{ print $2 }')
    messagePrint " - Cleaning up forwarding-rule:" "$nam"

    gcloud compute forwarding-rules delete $nam --region=$zon -q >/dev/null 2>&1
  done

  # --filter="region:($GCP_REGION)"  NOT-WORKING
  for n in $(gcloud compute url-maps list 2>/dev/null | \
      egrep "^${ENV_NAME}-" | awk '{ print $1 }'); do

    messagePrint " - Cleaning up GCP url-maps:" "$n"
    #gcloud compute url-maps delete $n -q --region $GCP_REGION 2>/dev/null
    gcloud compute url-maps delete $n -q 2>/dev/null
    if [ $? -ne 0 ]; then
      echo "ERROR deleting url-maps $n"
      echo "      => gcloud compute url-maps delete $n -q"
      exit 1
    fi
  done

  # --- DELETE BACKEND SERVICE ---
  # --filter="region:($GCP_REGION)
  for n in $(gcloud compute backend-services list 2>/dev/null | \
        egrep "^${ENV_NAME}-" | awk '{ print $1 }'); do

    gcloud compute backend-services delete --global $n -q > /dev/null 2>&1
    if [ $? -ne 0 ]; then
      gcloud compute backend-services delete --region=$GCP_REGION $n -q > /dev/null 2>&1
      if [ $? -ne 0 ]; then
        echo "ERROR: failed to delete backend-services $n"
        echo "       => gcloud compute backend-services delete --region=$GCP_REGION $n -q"
        exit 1
      fi
    fi
  done

  # --- DELETE BACKEND SERVICE ---
  for n in $(gcloud compute addresses list 2>/dev/null | \
        grep -v "NAME" | awk '{ print $1 }'); do

    messagePrint " - Cleaning up adresses:" "$n"
    gcloud compute addresses delete $n --region=$GCP_REGION -q > /dev/null 2>&1
    gcloud compute addresses delete $n --global -q > /dev/null 2>&1
  done

  # --- DELETE PROXY ---
  for n in $(gcloud compute target-http-proxies list 2>/dev/null | \
        grep -v "NAME" | awk '{ print $1 }'); do

    messagePrint " - Cleaning up target-http-proxies:" "$n"
    gcloud compute target-http-proxies delete $n -q > /dev/null 2>&1
  done

  for n in $(gcloud compute target-https-proxies list 2>/dev/null | \
        grep -v "NAME" | awk '{ print $1 }'); do

    messagePrint " - Cleaning up target-https-proxies:" "$n"
    gcloud compute target-https-proxies delete $n -q > /dev/null 2>&1
  done

  for n in $(gcloud compute target-ssl-proxies list 2>/dev/null | \
        grep -v "NAME" | awk '{ print $1 }'); do

    messagePrint " - Cleaning up target-ssl-proxies:" "$n"
    gcloud compute target-ssl-proxies delete $n -q > /dev/null 2>&1
  done

  for n in $(gcloud compute target-tcp-proxies list 2>/dev/null | \
        grep -v "NAME" | awk '{ print $1 }'); do

    messagePrint " - Cleaning up target-tcp-proxies:" "$n"
    gcloud compute target-tcp-proxies delete $n -q > /dev/null 2>&1
  done

  # --filter="region:($GCP_REGION)"  NOT-WORKING
  for n in $(gcloud compute url-maps list 2>/dev/null | \
      egrep "^${ENV_NAME}-" | awk '{ print $1 }'); do

    messagePrint " - Cleaning up GCP url-maps:" "$n"
    #gcloud compute url-maps delete $n -q --region $GCP_REGION 2>/dev/null
    gcloud compute url-maps delete $n -q 2>/dev/null
    if [ $? -ne 0 ]; then
      echo "ERROR deleting url-maps $n"
      echo "      => gcloud compute url-maps delete $n -q"
      exit 1
    fi
  done

  # --- TARGET POOLS ---
  for n in $(gcloud compute target-pools list --filter="region:($GCP_REGION)" 2>/dev/null | \
        egrep "^${ENV_NAME}-" | awk '{ printf("%s:%s\n",$1,$2)}'); do

    nam=$(echo $n | awk -F: '{ print $1 }')
    zon=$(echo $n | awk -F: '{ print $2 }')

    messagePrint " - Cleaning up target-pools:" "$nam"
    gcloud compute target-pools delete --region=$zon $nam -q > /dev/null 2>&1
    if [ $? -ne 0 ]; then
      echo "ERROR: failed to delete target-pools"
      echo "       => gcloud compute target-pools delete --region=$zon $nam -q"
      exit 1
    fi
  done

  # --- HEALTH CHECKS ---
  for n in $(gcloud compute health-checks list --filter="region:($GCP_REGION)" 2>/dev/null | \
        egrep "^$ENV_NAME" | awk '{ print $1 }'); do

    messagePrint " - Cleaning up health-checks:" "$n"
    gcloud compute health-checks delete $n -q > /dev/null 2>&1
  done

  # --filter="region:($GCP_REGION)" NOT-WORKING
  for n in $(gcloud compute http-health-checks list 2>/dev/null | \
        egrep "^${ENV_NAME}-" | awk '{ print $1 }'); do

    messagePrint " - Cleaning up http-health-checks:" "$n"
    gcloud compute http-health-checks delete $n -q > /dev/null 2>&1
    if [ $? -ne 0 ]; then
      echo "ERROR: failed to delete http-health-checks"
      echo "       => gcloud compute http-health-checks delete $n -q"
      exit 1
    fi
  done

  # --filter="region:($GCP_REGION)" NOT-WORKING
  for n in $(gcloud compute https-health-checks list 2>/dev/null | \
        egrep "^${ENV_NAME}-" | awk '{ print $1 }'); do

    messagePrint " - Cleaning up https-health-checks:" "$n"
    gcloud compute https-health-checks delete $n -q > /dev/null 2>&1
    if [ $? -ne 0 ]; then
      echo "ERROR: failed to delete https-health-checks"
      echo "       => gcloud compute https-health-checks delete $n -q"
      exit 1
    fi
  done

  # --- DELETE URL-MAPS CHECK ---
  # --filter="region:($GCP_REGION)" NOT-WORKING
  for n in $(gcloud compute url-maps list 2>/dev/null | \
        grep "^${ENV_NAME}-" | awk '{ print $1 }'); do

    messagePrint " - Cleaning up url-maps:" "$n"
    gcloud compute url-maps delete $n -q > /dev/null 2>&1
  done

  # --- DELETE INSTANCES ---
  for n in $(gcloud compute instance-groups list --filter="zone:($GCP_REGION)" 2>/dev/null | \
        grep "^${ENV_NAME}-" | awk '{ printf("%s:%s:%s\n",$1,$2,$(NF-1))}'); do

    # --- DONT DELETE PCFJUMP VM ---
    cnt=$(echo "$n" | egrep -c "^pcfjump")
    if [ $cnt -eq 0 ]; then
      nam=$(echo $n | awk -F: '{ print $1 }')
      zon=$(echo $n | awk -F: '{ print $2 }')
      man=$(echo $n | awk -F: '{ print $3 }')
      messagePrint " - Cleaning up GCP Instance Groups:" "$nam"
      if [ "${man}" == "No" ]; then 
        gcloud compute instance-groups unmanaged delete ${nam} --zone ${zon} -q > /dev/null 2>&1
        if [ $? -ne 0 ]; then
          gcloud compute instance-groups unmanaged delete ${nam} --zone ${zon} -q
          exit 1
        fi
      else
        gcloud compute instance-groups managed delete ${nam} --zone ${zon} -q > /dev/null 2>&1
        if [ $? -ne 0 ]; then
          gcloud compute instance-groups managed delete ${nam} --zone ${zon} -q
          exit 1
        fi
      fi
    fi
  done


  # --- DELETE STORAGE BUCKETS ---
  for n in $(gsutil list 2>/dev/null | \
        egrep "\-${ENV_NAME}-" | awk '{ print $1 }' | sed 's+$/++g'); do

    messagePrint " - Cleaning up Storage Bucket:" "$n"
    gsutil -m rm -r $n > /dev/null 2>&1
  done

  # --- DELETE MANAGED ZONES ---
  for zone in $(gcloud dns managed-zones list 2>/dev/null | \
      egrep "^$ENV_NAME" | awk '{ print $1 }'); do

    rm -f /tmp/$$_tmp; touch /tmp/$$_tmp
    gcloud dns record-sets import --delete-all-existing -z $zone /tmp/$$_tmp >/dev/null 2>&1
    gcloud dns managed-zones delete $zone >/dev/null 2>&1
  done

  # --- DELETE NAT ROUTER ---
  for n in $(gcloud compute routers list --filter="region:($GCP_REGION)" 2>/dev/null | \
    egrep "^$ENV_NAME" | awk '{ print $1 }'); do

    messagePrint " - Cleaning up GCP NAT Router:" "$n"
    gcloud compute routers delete $n --region=$GCP_REGION -q 2>/dev/null
    if [ $? -ne 0 ]; then
      echo "ERROR: Deleting Nat Router $n failed"
      echo "       => gcloud compute routers delete $n --region=$GCP_REGION -q"
      exit 1
    fi
  done

  for n in $(gcloud compute networks subnets list --filter="region:($GCP_REGION)" 2>/dev/null | \
    egrep "^$ENV_NAME" | awk '{ print $1 }'); do

    messagePrint " - Cleaning up GCP Subnet:" "$n"
    gcloud compute networks subnets delete $n --region=$GCP_REGION -q 2>/dev/null
    if [ $? -ne 0 ]; then 
      echo "ERROR: Deleting Subnet $n failed"
      echo "       => gcloud compute networks subnets delete $n --region=$GCP_REGION -q"
      exit 1
    fi
  done

  # --- DELETE FIREWALL RULES ---
  # --filter="region:($GCP_REGION)" DOES-NOT-WORK
  for n in $(gcloud compute firewall-rules list 2>/dev/null | \
      egrep "^${ENV_NAME}-| ${ENV_NAME}-pcf-network" 2>/dev/null | awk '{ print $1 }'); do

    messagePrint " - Cleaning up GCP firewall-tules:" "$n"
    gcloud compute firewall-rules delete $n -q 2>/dev/null
    if [ $? -ne 0 ]; then 
      echo "ERROR: Deleting Firewall Rule $n"
      echo "       => gcloud compute firewall-rules delete $n -q"
      exit 1
    fi
  done

  for net in $(gcloud compute networks subnets list --regions=$GCP_REGION 2>/dev/null | \
      egrep "^$ENV_NAME" 2>/dev/null | awk '{ printf("%s:%s\n",$1,$2)}'); do

    nam=$(echo $net | awk -F: '{ print $1 }')
    zon=$(echo $net | awk -F: '{ print $2 }')

    messagePrint " - Cleaning up GCP Subnetwork:" "$nam"
    gcloud compute networks subnets delete $nam --region=$GCP_REGION-q 2>/dev/null
    if [ $? -ne 0 ]; then
      echo "ERROR: Deleting Subnet $nam"
      echo "       => gcloud compute networks subnets delete $nam --region=$GCP_REGION -q"
      exit 1
    fi
  done

  # --filter="region:($GCP_REGION)"
  for net in $(gcloud compute networks list 2>/dev/null | \
      egrep "^${ENV_NAME}-" 2>/dev/null | awk '{ print $1 }'); do

    messagePrint " - Cleaning up GCP Network:" "$net"
    gcloud compute networks delete $net -q 2>/dev/null
    if [ $? -ne 0 ]; then 
      echo "ERROR: Deleting GCP Network $net"
      echo "       => gcloud compute networks delete $net -q"
      exit 1
    fi
  done

  for n in $(gcloud iam service-accounts list 2>/dev/null | \
      grep -v "EMAIL" | egrep "^$ENV_NAME" | awk '{ print $(NF-1) }'); do

    messagePrint " - Cleaning up GCP Service Account:" "$n"
    gcloud iam service-accounts delete $n -q 2>/dev/null
  done

  # --- CLEANUP SERVICE BINDINGS ---
#  if [ "${GCP_PROJECT}" == "" ]; then 
#    GCP_PROJECT=$(gcloud projects list | grep -v "PROJECT_ID" | awk '{ print $1 }')
#  fi
#
#  gcloud projects get-iam-policy $GCP_PROJECT --format="json" > /tmp/$$_policy
#  cnt=$(sed 's/\"role\"://g' /tmp/$$_policy | grep -c "role") 
#
#  i=0; while [ $i -le $cnt ]; do
#    jq -r '.bindings[$i].role' /tmp/$$_policy
#    let i=i+1
#  done
#
#  rm -f /tmp/$$_policy

  for n in $(gcloud compute backend-services list --filter="region:($GCP_REGION)" 2>/dev/null | \
       egrep "^$ENV_NAME" | awk '{ print $1 }'); do

    messagePrint " - Cleaning up GCP backend-services:" "$n"
    gcloud compute forwarding-rules delete $n -q 2>/dev/null
  done

  for n in $(gcloud compute forwarding-rules list --filter="region:($GCP_REGION)" 2>/dev/null | \
       egrep "^$ENV_NAME" | awk '{ print $1 }'); do

    messagePrint " - Cleaning up GCP forwarding-rules:" "$n"
    gcloud compute forwarding-rules delete $n -q --region $GCP_REGION 2>/dev/null
  done

  for n in $(gcloud compute addresses list --filter="region:($GCP_REGION)" 2>/dev/null | \
       egrep "^$ENV_NAME" | awk '{ print $1 }'); do

    messagePrint " - Cleaning up GCP Addresses:" "$n"
    gcloud compute addresses delete $n -q --region $GCP_REGION 2>/dev/null
  done

  for n in $(gcloud compute health-checks list --filter="region:($GCP_REGION)" 2>/dev/null | \
      egrep "^$ENV_NAME" | awk '{ print $1 }'); do

    messagePrint " - Cleaning up GCP health-checks:" "$n"
    gcloud compute health-checks delete $n -q --region $GCP_REGION 2>/dev/null
  done

  for n in $(gcloud compute target-pools list --filter="region:($GCP_REGION)" 2>/dev/null | \
      egrep "^$ENV_NAME" | awk '{ print $1 }'); do

    messagePrint " - Cleaning up GCP target-pools:" "$n"
    gcloud compute target-pools delete $n -q --region $GCP_REGION 2>/dev/null
  done

  #gcloud compute backend-services list --filter="region:($GCP_REGION)"
  #gcloud compute target-tcp-proxies list
  #gcloud compute target-http-proxies list

  sleep 10
}

checkOpsMantools() {
  # --- CHECK FOR OM UTILITY ---
  OM=$(which om)
  if [ "${OM}" == "" ]; then
    echo ""
    echo "ERROR: please install the om utility from https://github.com/pivotal-cf/om"; exit 0
  else
    # --- TEST FOR WORKING OM UTILITY ---
    OM_VERSION=$($OM version 2>/dev/null); ret=$?
    if [ ${ret} -ne 0 -o "${OM_VERSION}" == "" ]; then
      echo ""
      echo "ERROR: The om utility $(which om) does not seam to be correct"
      echo "       please install the om utility from https://github.com/pivotal-cf/om"; exit 0
    else
      messagePrint "checking for the om utility" "Installed - ${OM_VERSION}"
    fi
  fi

  # --- CHECK FOR JQ UTILITY ---
  JQ=$(which jq)
  if [ "${JQ}" == "" ]; then
    echo ""
    echo "ERROR: please install the jq utility from https://stedolan.github.io/jq/download"; exit 0
  else
    # --- TEST FOR WORKING JQ UTILITY ---
    JQ_VERSION=$(JQ -V 2>/dev/null); ret=$?
    if [ "$($JQ -V | egrep -c '^jq-')" -eq 1 -a "$(echo '{"foo": 42}' | jq .foo)" != "42" ]; then
      echo ""
      echo "ERROR: the jq utility $(which jq) does not seam to be correct"
      echo "       please install the om utility from https://stedolan.github.io/jq/download/"; exit 0
    else
      messagePrint "checking for the jq utility" "Installed - ${JQ_VERSION}"
    fi
  fi

  # --- CHECK FOR TERRAFORMS ---
  TF=$(which terraform)
  if [ "${TF}" == "" ]; then
    echo ""
    echo "ERROR: please install the terraform from https://www.terraform.io/downloads.html"; exit 0
  else
    # --- TEST FOR WORKING JQ UTILITY ---
    TF_VERSION=$($TF -v 2>/dev/null | head -1 | awk '{ print $2 }'); ret=$?
    if [ ${ret} -ne 0 -o "${TF_VERSION}" == "" ]; then
      echo ""
      echo "ERROR: the terraform $(which terraform) does not seam to be correct"
      echo "       please install terraform from https://www.terraform.io/downloads.html"; exit 0
    else
      messagePrint "checking for the terraform " "Installed - ${TF_VERSION}"
    fi
  fi
}

verifyCertificate () {
  CLOUD="$1"
  MODE="$2"
  TLS_CERTIFICATE="$3"
  TLS_FULLCHAIN="$4"
  TLS_PRIVATE_KEY="$5"
  TLS_CHAIN="$6"
  TLS_ROOT_CA="$7"

  if [ "${TLS_CERTIFICATE}" == "" -o "${TLS_PRIVATE_KEY}" == "" -o \
       "${TLS_FULLCHAIN}" == "" ]; then
    
    echo ""
    echo "  MISSING ENVIRONMENT-VARIABES    DESCRIPTION        "
    echo "  --------------------------------------------------------------------------------------------------------------"
    echo "  To allow TLS encrypted httpd traffic a Certificate and key needs to be created for your DNS Domain. Free"
    echo "  certificates can be optained through https://letsencrypt.org."
    echo "" 
        
    if [ "${TLS_CERTIFICATE}" == "" ]; then
      echo "  ${CLOUD}_${MODE}_TLS_CERTIFICATE       (optional)  TLS Certificate (type PEM Certificate)"
    fi
    
    if [ "${TLS_FULLCHAIN}" == "" ]; then
      echo "  ${CLOUD}_${MODE}_TLS_FULLCHAIN         (optional)  TLS Fullchain (type PEM Certificate)"
    fi
    
    if [ "${TLS_PRIVATE_KEY}" == "" ]; then
      echo "  ${CLOUD}_${MODE}_TLS_PRIVATE_KEY       (optional)  TLS Private Key"
    fi
    
    if [ "${ROOT_CA}" == "" ]; then 
      echo "  ${CLOUD}_${MODE}_TLS_ROOT_CA           (automatic) TLS Root CA"
    fi
        
    dom="$PCF_DEPLOYMENT_ENV_NAME.$AWS_HOSTED_DNS_DOMAIN"
    echo "                                  "
    echo "                                  $PCF_DEPLOYMENT_ENV_NAME.$AWS_HOSTED_DNS_DOMAIN"
    echo "                                    |      |_________ represented by the PCF_ENVIRONMENT_NAME variable"
    echo "                                    |________________ represented by the AWS_HOSTED_DNS_DOMAIN variable"
    echo ""                                 
    echo "                                  The certificate Should include the following domains:"
    echo "                                  - PKS Services (API, OpsMan, Harbor) .: *.${dom}"
    echo "                                  - PKS Cluster and Applications .......: *.apps.cl1.${dom}"
    echo "                                                                          *.apps.cl2.${dom}"
    echo "                                                                          *.apps.cl3.${dom}"
    echo ""
  else
    messageTitle "TLS Encryption for domain (${PCF_DEPLOYMENT_ENV_NAME}.${AWS_HOSTED_DNS_DOMAIN})"

    for n in $TLS_CERTIFICATE $TLS_FULLCHAIN; do
      cnt=$(grep -c "BEGIN CERTIFICATE" $n) 
      if [ $cnt -eq 0 ]; then 
        echo "ERROR: The file ($n) is not in (Base64) format"
        echo "       It should begin with '-----BEGIN CERTIFICATE-----' and end with '-----END CERTIFICATE-----'"
        exit 1
      fi
    done

    for n in $TLS_PRIVATE_KEY; do
      cnt=$(egrep -c "BEGIN RSA PRIVATE|BEGIN PRIVATE" $n)
      if [ $cnt -eq 0 ]; then
        echo "ERROR: The file ($n) is not (private-key Base64) format"
        echo "       It should begin with '-----BEGIN RSA PRIVATE' and end with '-----END RSA PRIVATE'"
        exit 1
      fi
    done

    # --- VERIFY THE CERTIFICATE ---
    cnm="${PCF_DEPLOYMENT_ENV_NAME}.${AWS_HOSTED_DNS_DOMAIN}"
    cnt=$(openssl crl2pkcs7 -nocrl -certfile $TLS_FULLCHAIN | openssl pkcs7 -print_certs | egrep "^subject|^issuer" | \
          sed -e 's/CN = /CN=/g' -e 's/^subject=.*CN=//g' -e 's/^issuer=.*CN=//g' | egrep -c "^\*.${cnm}")
    if [ $cnt -eq 0 ]; then
      echo "ERROR: The file ($(basename $TLS_FULLCHAIN)) does not contain the CN=*.${cnm}" 
      exit 1
    fi

    ISSUER="*.${cnm}"; item_found=1
    while [ ${item_found} -eq 1 ]; do
      item_found=0
      for item in $(openssl crl2pkcs7 -nocrl -certfile $TLS_FULLCHAIN | openssl pkcs7 -print_certs | \
                    egrep "^subject|^issuer" | sed -e 's/CN = /CN=/g' -e 's/^subject=.*CN=//g' \
                    -e 's/^issuer=.*CN=//g' -e 's/ /~1~/g' | paste -d ':' - -); do
  
        sub=$(echo "${item}" | awk -F: '{ print $1 }') 
        iss=$(echo "${item}" | awk -F: '{ print $2 }') 

        if [ "${sub}" == "${ISSUER}" ]; then ISSUER="${iss}"; SUBJECT="${sub}"; item_found=1; fi
      done
    done

    ROOT_CA=$ISSUER
    ROOT_CA_NAME=$(echo $ISSUER | sed 's/~1~/ /g') 

    if [ "${TLS_ROOT_CA}" == "" ]; then 
      # --- TRY TO FIND THE ROOT_CA ---
      if [ "${ROOT_CA_NAME}" == "DST Root CA X3" ]; then 
        ROOT_CA_URL="https://letsencrypt.org/certs/trustid-x3-root.pem.txt"
        curl --output /tmp/trustid-x3-root.pem $ROOT_CA_URL > /dev/null 2>&1
        TLS_ROOT_CA=/tmp/trustid-x3-root.pem
        eval export ${CLOUD}_${MODE}_TLS_ROOT_CA=/tmp/trustid-x3-root.pem
      fi

      # --- GENERATE CA.PEM WITH ROOT_CA AND FULLCHAIN ---
      cat $TLS_ROOT_CA $TLS_FULLCHAIN > $HOME/pcfconfig/certificates/ca.pem

      if [ "${TLS_ROOT_CA}" == "" ]; then    
        echo "ERROR: ROOT_CA for $ROOT_CA_NAME could not be found, please download the file manually" 
        echo "       and set the variable in the ~/.pcfconfig"
        echo "       => export ${CLOUD}_${MODE}_TLS_ROOT_CA=<ca.crt>"
        exit 1
      fi
    fi

    # --- VERIFY TO ROOT_CA ---
    for n in $TLS_ROOT_CA; do
      if [ ! -f $n ]; then 
        echo "ERROR: the file $n does not exist"; exit 1
      fi

      cnt=$(grep -c "BEGIN CERTIFICATE" $n)
      if [ $cnt -eq 0 ]; then
        echo "ERROR: The file ($(basename $n)) is not in (Base64) format"
        echo "       It should begin with '-----BEGIN CERTIFICATE-----' and end with '-----END CERTIFICATE-----'"
        exit 1
      fi
    done

    # --- VERIFY THE CERTIFICATE ISSUER AND SUBJECT ---
    tmp=$(openssl crl2pkcs7 -nocrl -certfile $TLS_ROOT_CA | openssl pkcs7 -print_certs | \
          egrep "^subject|^issuer" | sed -e 's/CN = /CN=/g' -e 's/^subject=.*CN=//g' -e 's/^issuer=.*CN=//g' -e 's/ /~1~/g' | \
          paste -d ':' - -)
    sub=$(echo "${tmp}" | awk -F: '{ print $1 }' | sed 's/~1~/ /g') 
    iss=$(echo "${tmp}" | awk -F: '{ print $2 }' | sed 's/~1~/ /g') 
    if [ "${iss}" != "${sub}" ]; then
      echo "ERROR: $TLS_ROOT_CA is not a Root CA. Issuer and Subject should be the same"
      echo "       => File: $TLS_ROOT_CA Issuer=$sub / Subject=$iss"
      exit 1
    fi

    if [ "${iss}" != "${ROOT_CA_NAME}" ]; then
      echo "ERROR: $TLS_ROOT_CA is not Signed by $ROOT_CA_NAME."
      echo "       => File: $TLS_ROOT_CA Subject=$iss"
      exit 1
    fi

    # --- VERIFY CERTITICATE AND FULLCHAAIN SIGNED BY ROOT_CA ---
    cat $TLS_ROOT_CA $TLS_FULLCHAIN > /tmp/ca.crt
    openssl verify -CAfile /tmp/ca.crt $TLS_CERTIFICATE > /dev/null 2>&1
    if [ $? -ne 0 ]; then
      echo "ERROR: Certificate ($TLS_CERTIFICATE) was not signed by the Roor CA ($ROOT_CA_NAME)"
      exit 1
    fi

    openssl verify -CAfile /tmp/ca.crt $TLS_FULLCHAIN > /dev/null 2>&1
    if [ $? -ne 0 ]; then
      echo "ERROR: Certificate ($TLS_FULLCHAIN) was not signed by the Roor CA ($ROOT_CA_NAME)"
      exit 1
    fi

    # --- VERIFY IF PRIVATE KEY MATCH THE CERTIFICATE ---
    pk=$(openssl rsa  -noout -modulus -in $TLS_PRIVATE_KEY | openssl md5) 
    cr=$(openssl x509 -noout -modulus -in $TLS_CERTIFICATE | openssl md5) 
    fc=$(openssl x509 -noout -modulus -in $TLS_FULLCHAIN | openssl md5) 

    if [ "${pk}" != "${cr}" ]; then
      echo "ERROR: Cert ($(basename $TLS_CERTIFICATE)) does not match the private key ($(basename $TLS_PRIVATE_KEY))"
      echo "       => openssl rsa -noout -modulus -in $TLS_PRIVATE_KEY | openssl md5"
      echo "       => openssl x509 -noout -modulus -in $TLS_CERTIFICATE | openssl md5"
      exit 1
    fi

    if [ "${pk}" != "${fc}" ]; then
      echo "ERROR: Cert ($(basename $TLS_FULLCHAIN)) does not match the private key ($(basename $TLS_PRIVATE_KEY))"
      echo "       => openssl rsa -noout -modulus -in $TLS_PRIVATE_KEY | openssl md5"
      echo "       => openssl x509 -noout -modulus -in $TLS_FULLCHAIN | openssl md5"
      exit 1
    fi

    messagePrint " - TLS Certificate"                  "$TLS_CERTIFICATE"
    messagePrint " - TLS fullchain"                    "$TLS_FULLCHAIN"
    messagePrint " - TLS Private Key"                  "$TLS_PRIVATE_KEY"
    messagePrint " - TLS Root CA ($ROOT_CA_NAME)"      "$TLS_ROOT_CA"
  fi
}

checkCloudAccess() {
  missing_variables=0

  if [ "${PCF_DEPLOYMENT_CLOUD}" == "GCP" ]; then
    #if [ "${GCP_SERVICE_ACCOUNT}" == "" -o "${GCP_REGION}" == "" -o "${GCP_PROJECT}" == "" ]; then 
    if [ "${GCP_REGION}" == "" -o "${GCP_PROJECT}" == "" ]; then 
      missing_variables=1
      echo ""
      echo "  MISSING ENVIRONMENT-VARIABES    DESCRIPTION        "
      echo "  --------------------------------------------------------------------------------------------------------------"

      #if [ "${GCP_SERVICE_ACCOUNT}" == "" ]; then
      #  echo "  GCP_SERVICE_ACCOUNT           (required) GCP Service Account"
      #fi

      if [ "${GCP_PROJECT}" == "" ]; then
        echo "  GCP_PROJECT                   (required) GCP Project"
        echo "                                  => gcloud projects list | sed '1d' | awk '{ print \$1 }'"
      fi

      if [ "${GCP_REGION}" == "" ]; then
        echo "  GCP_REGION                    (required) Choose the GCP Region where your installation should run"
        echo "                                  => gcloud compute zones list | sed '1d' | awk '{ print $2 }' | sort -u"
        echo "                                     europe-west1, us-east1, europe-west4  etc."
      fi
    else
      echo "GCP Access Credentials"
      #messagePrint " - GCP Service Account"          "$GCP_SERVICE_ACCOUNT"
      messagePrint " - GCP Project"                  "$GCP_PROJECT"
      messagePrint " - GCP Region"                   "$GCP_REGION"
    fi

#    if [ "$PCF_TILE_PKS_DEPLOY" == "true" ]; then
#        verifyCertificate GCP PKS "$GCP_PKS_TLS_CERTIFICATE" "$GCP_PKS_TLS_FULLCHAIN" \
#                                  "$GCP_PKS_TLS_PRIVATE_KEY" "$GCP_PKS_TLS_ROOT_CA"
#    fi
#
#    if [ "$PCF_TILE_PAS_DEPLOY" == "true" ]; then
#        verifyCertificate GCP PAS "$GCP_PAS_TLS_CERTIFICATE" "$GCP_PKS_TLS_FULLCHAIN" \
#                                  "$GCP_PAS_TLS_PRIVATE_KEY" "$GCP_PAS_TLS_ROOT_CA"
#    fi
  fi

  if [ "${PCF_DEPLOYMENT_CLOUD}" == "AWS" ]; then
    if [ "${AWS_ACCESS_KEY}" == "" -o "${AWS_SECRET_KEY}" == "" -o \
         "${AWS_REGION}" == "" ]; then

      missing_variables=1
      echo ""
      echo "  MISSING ENVIRONMENT-VARIABES    DESCRIPTION        "
      echo "  --------------------------------------------------------------------------------------------------------------"

      if [ "${AWS_ACCESS_KEY}" == "" ]; then
        echo "  AWS_ACCESS_KEY                  (required) AWS Acess Key"
      fi

      if [ "${AWS_SECRET_KEY}" == "" ]; then
        echo "  AWS_SECRET_KEY                  (required) AWS Secret Key"
      fi

      if [ "${AWS_REGION}" == "" ]; then
        echo "  AWS_REGION                    (required) Choose the AWS Region where your installation should run"
        echo "                                  => aws ec2 --region=eu-west-3 describe-regions --output text | awk '{ print $NF }'"
        echo "                                     eu-north-1, eu-west-3, eu-central-1 etc."
      fi
    else
      messageTitle "Azure Access Credentials"
      messagePrint " - AWS AccwssKey"                "$AWS_ACCESS_KEY"
      messagePrint " - AWS SecretKey"                "$AWS_SECRET_KEY"
      messagePrint " - AWS Region"                   "$AWS_REGION"
    fi

#    if [ "$PCF_TILE_PKS_DEPLOY" == "true" ]; then
#        verifyCertificate AWS PKS "$AWS_PKS_TLS_CERTIFICATE" "$AWS_PKS_TLS_FULLCHAIN" \
#                                  "$AWS_PKS_TLS_PRIVATE_KEY" "$AWS_PKS_TLS_ROOT_CA"
#    fi
#
#    if [ "$PCF_TILE_PAS_DEPLOY" == "true" ]; then
#        verifyCertificate AWS PAS "$AWS_PAS_TLS_CERTIFICATE" "$AWS_PAS_TLS_FULLCHAIN" \
#                                  "$AWS_PAS_TLS_PRIVATE_KEY" "$AWS_PAS_TLS_ROOT_CA"
#    fi
  fi

  if [ "${PCF_DEPLOYMENT_CLOUD}" == "Azure" ]; then 
    if [ "${AZURE_SUBSCRIPTION_ID}" == "" -o "${AZURE_TENANT_ID}" == "" -o \
         "${AZURE_CLIENT_ID}" == "" -o "${AZURE_CLIENT_SECRET}" == "" -o "${AZURE_REGION}" == "" ]; then

      missing_variables=1
      echo ""
      echo "  MISSING ENVIRONMENT-VARIABES    DESCRIPTION        "
      echo "  --------------------------------------------------------------------------------------------------------------"

      if [ "${AZURE_SUBSCRIPTION_ID}" == "" ]; then
        echo "  AZURE_SUBSCRIPTION_ID           (required) has the format <xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx>"
      fi 

      if [ "${AZURE_TENANT_ID}" == "" ]; then
        echo "  AZURE_TENANT_ID                 (required) has the format <xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx>"
      fi 

      if [ "${AZURE_CLIENT_ID}" == "" ]; then
        echo "  AZURE_CLIENT_ID                 (required) has the format <xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx>"
      fi 

      if [ "${AZURE_CLIENT_SECRET}" == "" ]; then
        echo "  AZURE_CLIENT_SECRET             (required) has the format <xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx>"
      fi

      if [ "${AZURE_REGION}" == "" ]; then
        echo "  AZURE_REGION                    (required) Choose the Azure Region where your installation should run"
        echo "                                  => az account list-locations -o table | awk '{ print $NF }'"
        echo "                                     westeurope, northeurope, switzerlandnorth etc."
      fi
    else
      messageTitle "Azure Access Credentials"
      messagePrint " - Azure SubscriptionId"         "$AZURE_SUBSCRIPTION_ID"
      messagePrint " - Azure TennantId"              "$AZURE_TENANT_ID"
      messagePrint " - Azure ClientId"               "$AZURE_CLIENT_ID"
      messagePrint " - Azure Client Secret"          "$AZURE_CLIENT_SECRET"
      messagePrint " - Azure Region"                 "$AZURE_REGION"
    fi

#    if [ "$PCF_TILE_PKS_DEPLOY" == "true" ]; then
#        verifyCertificate AZURE PKS "$AZURE_PKS_TLS_CERTIFICATE" "$AZURE_PKS_TLS_FULLCHAIN" \
#                                    "$AZURE_PKS_TLS_PRIVATE_KEY" "$AZURE_PKS_TLS_ROOT_CA"
#    fi
#
#    if [ "$PCF_TILE_PAS_DEPLOY" == "true" ]; then
#        verifyCertificate AZURE PAS "$AZURE_PAS_TLS_CERTIFICATE" "$AZURE_PKS_TLS_FULLCHAIN" \
#                                    "$AZURE_PAS_TLS_PRIVATE_KEY" "$AZURE_PAS_TLS_ROOT_CA"
#    fi
  fi

  if [ "${PCF_PIVNET_TOKEN}" == "" -o "${AWS_ACCESS_KEY}" == "" -o \
       "${AWS_SECRET_KEY}" == "" -o "${AWS_HOSTED_DNS_DOMAIN}" == "" ]; then

    missing_variables=1
    echo ""
    echo "  MISSING ENVIRONMENT-VARIABES    DESCRIPTION        "
    echo "  --------------------------------------------------------------------------------------------------------------"

    if [ "${PCF_PIVNET_TOKEN}" == "" ]; then
      echo "  PCF_PIVNET_TOKEN                (required) PIVNET Access Token to download software. Get a UAA API TOKEN from"
      echo "                                  => https://network.pivotal.io/users/dashboard/edit-profile"
    fi

    if [ "${AWS_ACCESS_KEY}" == "" ]; then
      echo "  AWS_ACCESS_KEY                  (required) A DNS Domain managed by AWS Route 53 ie. yourdomain.com with a"
      echo "                                  valid DNS Zone. => https://console.aws.amazon.com/route53"
    fi

    if [ "${AWS_SECRET_KEY}" == "" ]; then
      echo "  AWS_SECRET_KEY                  (required) A DNS Domain managed by AWS Route 53 ie. yourdomain.com with a"
      echo "                                  valid DNS Zone. => https://console.aws.amazon.com/route53"
    fi

    if [ "${AWS_HOSTED_DNS_DOMAIN}" == "" ]; then
      echo "  AWS_HOSTED_DNS_DOMAIN           (required) A DNS Domain managed by AWS Route 53 ie. yourdomain.com with a"
      echo "                                  valid DNS Zone. => https://console.aws.amazon.com/route53"
    fi

    #if [ "${AWS_HOSTED_ZONE_ID}" == "" ]; then
    #  echo "  AWS_HOSTED_ZONE_ID              (required) An AWS Route 53 Token is required to add/update DNS records"
    #  echo "                                  => https://console.aws.amazon.com/route53 -> hosted Zones -> Zone ID"
    #fi
  else
    messageTitle "Supporting services access (Pivotal Network, AWS Route53)"
    messagePrint " - Pivotal Network Token"           "$PCF_PIVNET_TOKEN"
    messagePrint " - AWS Route53 Hosted DNS Domain"   "$AWS_HOSTED_DNS_DOMAIN"

    # --- VERIFY PIVNET ACCESS ---
    pivnetAPI $PCF_PIVNET_TOKEN
    if [ $? -ne 0 ]; then
      write_line
      echo "ERROR: Pivnet Token: $PCF_PIVNET_TOKEN does not seam to be valit. Please greate a new one by"
      echo "       login to http://network.pivotal.io => Your login Name => Edit Profile => UAA API TOKEN"
      exit 1
    fi

    # --- CHECK IF AWS CLI IS CONFIGURED ---
    if [ ! -d ~/.aws -o -d ~/.aws/credentials ]; then
      echo "ERROR: AWS CLI is not configured yet, please run aws configure"
      echo "       => aws configure"
      exit 1
    fi

    export AWS_HOSTED_ZONE_ID=$(aws route53 list-hosted-zones --query "HostedZones[?starts_with(to_string(Name), '${AWS_HOSTED_DNS_DOMAIN}.')]" | \
                        jq -r '.[].Id' | awk -F '/' '{ print $NF }')
    if [ $? -ne 0 -o "${AWS_HOSTED_ZONE_ID}" == "" ]; then
      echo "ERROR: failed to get domain information for ($AWS_HOSTED_DNS_DOMAIN)"
      echo "       => aws route53 list-hosted-zones --query \"HostedZones[?starts_with(to_string(Name), '${AWS_HOSTED_DNS_DOMAIN}.')]\""
      exit 1
    else
      messagePrint " - AWS Route53 ZoneID"              "$AWS_HOSTED_ZONE_ID"
    fi

    #pivnetAPI $PCF_PIVNET_TOKEN GET products/pivotal-container-service/releases/112041/eula_acceptance
    #pivnetAPI $PCF_PIVNET_TOKEN GET products/pivotal-container-service/releases
    #pivnetAPI $PCF_PIVNET_TOKEN GET products/elastic-runtime/releases 2>/dev/null | jq -r '.releases[] | select(.version | scan("^2.6.6$")).id'

    #pivnetAPI $PCF_PIVNET_TOKEN GET products/elastic-runtime/releases 2>/dev/null | \
    #    jq -r '.releases[] | select(.version | scan("^2.6.6$")).id'
    #pivnetAPI $PCF_PIVNET_TOKEN GET products/elastic-runtime/releases/467360 | jq

    pslug="pivotal-container-service"; pver="1.5"
    pslug="elastic-runtime"; pver="2.6.6"
    pslug="elastic-runtime"; pver="467928"
  fi

  if [ ${missing_variables} -eq 1 ]; then
    echo "  --------------------------------------------------------------------------------------------------------------"
    echo "  IMPORTANT: Please set the missing environment variables either in your shell or in the pcfconfig"
    echo "             configuration file ~/.pcfconfig and set all variables with the 'export' notation"
    echo "             ie. => export AZURE_PKS_TLS_CERTIFICATE=/home/demouser/certs/cert.pem"
    echo "  --------------------------------------------------------------------------------------------------------------"
    exit 1
  fi
}

pivnetAPIdownload() {
  REFRESH_TOKEN="$1"
  PRODUCT_SLUG="$2"
  PRODUCT_ID=$3
  PRODUCT_FILE=$4
  FILE_NAME="$5"

  token=$(curl -X POST https://network.pivotal.io/api/v2/authentication/access_tokens \
               -d "{\"refresh_token\":\"$REFRESH_TOKEN\"}" 2>/dev/null | jq -r '.access_token')
  if [ "${token}" == "" -o "${token}" == "null" ]; then return 1; fi
  
  # --- LOGIN INTO PIVNET ---
  wget -O /tmp/$FILE_NAME --header="Authorization: Bearer $token" \
  https://network.pivotal.io/api/v2/products/$PRODUCT_SLUG/releases/$PRODUCT_ID/product_files/$PRODUCT_FILE/download > /dev/null 2>&1

  if [ ! -f /tmp/$FILE_NAME ]; then
    echo "ERROR: Error downloading file from PIVNET /tmp/$FILE_NAME"
  fi
  
  return 0
}

pivnetAPI() {
  REFRESH_TOKEN="$1"
  token=$(curl -X POST https://network.pivotal.io/api/v2/authentication/access_tokens \
               -d "{\"refresh_token\":\"$REFRESH_TOKEN\"}" 2>/dev/null | jq -r '.access_token')
  if [ "${token}" == "" -o "${token}" == "null" ]; then return 1; fi

  # --- LOGIN INTO PIVNET ---
  curl -X GET https://network.pivotal.io/api/v2/authentication -H "Authorization: Bearer $token" 

  # --- PIVNET ACCESS TEST ---
  if [ "${2}" == "" ]; then 
    return 0
  fi

  curl -H "Authorization: Bearer $token" -X $2 https://network.pivotal.io/api/v2/$3

  return 0
}

getProductVersion() {
  ver=$1
  name=$2
  slug=$3

  rec=$(echo "$ver" | awk -F'.' '{ print NF }')
  if [ $rec -eq 2 ]; then SEARCH_STR="^${ver}.[0-9]*$"; else SEARCH_STR="^${ver}$"; fi

  ver=$(pivnetAPI $PCF_PIVNET_TOKEN GET products/$slug/releases 2>/dev/null | \
        jq -r ".releases[] | select(.version | scan(\"$SEARCH_STR\")).version" | head -1)

  echo "$ver"
}

getProductSlug() {
  ver=$1
  name=$2
  slug=$3
  fid=""

  rec=$(echo "$ver" | awk -F'.' '{ print NF }')

  if [ "${slug}" == "stemcells-ubuntu-xenial" ]; then
    SEARCH_STR="$ver"
  else
    if [ $rec -eq 2 ]; then SEARCH_STR="^${ver}.[0-9]*$"; else SEARCH_STR="^${ver}$"; fi
  fi

  for id in $(pivnetAPI $PCF_PIVNET_TOKEN GET products/$slug/releases 2>/dev/null | \
              jq -r ".releases[] | select(.version | scan(\"$SEARCH_STR\")).id" | head -1); do

    fid=$(pivnetAPI $PCF_PIVNET_TOKEN GET products/$slug/releases/$id/product_files 2>/dev/null | \
      jq -r ".product_files[] | select(.name | scan(\"^$name\")).aws_object_key" | \
      awk -F'/' '{ print $NF }')

    if [ "${fid}" != "" ]; then
      # --- ACCEPT EULA ---
      pivnetAPI $PCF_PIVNET_TOKEN POST products/$slug/releases/$id/eula_acceptance > /dev/null 2>&1
      break
    else
      echo "ERROR: Unable to find OpsManager $2 om Pivnet"
      exit 1
    fi
  done

  echo "$fid"
}

uploadStemCell() {
  PRODUCT_SLUG=$1
  SLUG_VER=$2

  # --- GET STEMCEL-VERSION ---
  if [ "${PCF_DEPLOYMENT_CLOUD}" == "AWS" ]; then SLUG_STR="Ubuntu Xenial Stemcell for AWS"; fi
  if [ "${PCF_DEPLOYMENT_CLOUD}" == "Azure" ]; then SLUG_STR="Ubuntu Xenial Stemcell for Azure"; fi
  if [ "${PCF_DEPLOYMENT_CLOUD}" == "GCP" ]; then SLUG_STR="Ubuntu Xenial Stemcell for Google Cloud Platform"; fi

  for pid in $(pivnetAPI $PCF_PIVNET_TOKEN GET products/$PRODUCT_SLUG/releases 2> /dev/null | \
             jq -r ".releases[] | select(.version | scan(\"^$SLUG_VER\")).id"); do
    fid=$(pivnetAPI $PCF_PIVNET_TOKEN GET products/$PRODUCT_SLUG/releases/$pid 2>/dev/null | \
          jq -r ".product_files[] | select(.name | scan(\"^$SLUG_STR\")) | select(.file_version | scan(\"$SLUG_VER\")).id")

    if [ "${fid}" != "" ]; then
      # --- ACCEPT EULA ---
      pivnetAPI $PCF_PIVNET_TOKEN POST products/$PRODUCT_SLUG/releases/$pid/eula_acceptance > /dev/null 2>&1
      break
    else
      echo "ERROR: Unable to find $PRODUCT_SLUG $2 on Pivnet"
      exit 1
    fi
  done

  file=$(pivnetAPI $PCF_PIVNET_TOKEN GET products/$PRODUCT_SLUG/releases/$pid 2>/dev/null | \
       jq -r ".product_files[] | select(.id | tostring | scan(\"^$fid$\")).aws_object_key" | \
       awk -F'/' '{ print $NF }')

  if [ ! -f /tmp/$file ]; then
    messageTitle "Download Product from PIVNET"
    messagePrint " - Product Slug:" "$SLUG_VER"
    messagePrint " - Product FileID:" "$fid"
    messagePrint " - Download Location:" "/tmp/$file"
    pivnetAPIdownload $PCF_PIVNET_TOKEN $PRODUCT_SLUG $pid $fid $file
  fi

  messageTitle "Uploading Stemcell for Harbor"
  messagePrint " - Staging Stemcell Version:" "$SLUG_VER"
  messagePrint " - Staging Stemcell Type:" "$PRODUCT_SLUG"
  messagePrint " - Staging Stemcell Description:" "$PRODUCT_SLUG $SLUG_VER"

  messageTitle "Uploading Stemcell"
  messagePrint " - Stemcell File:" "/tmp/$file"

  $OM $OM_LOGIN upload-stemcell --stemcell /tmp/$file > /dev/null 2>&1
}

uploadProductTile() {
  PRODUCT_SLUG=$1
  PRODUCT_VERSION=$2
  PRODUCT_NAME=$3

  # --- CHECK IF PRODUCT IS ALREADY STAGED ---
  cnt=$($OM $OM_LOGIN staged-products | egrep -c " $PRODUCT_SLUG ")

  if [ $cnt -eq 0 ]; then
    rec=$(echo "$PRODUCT_VERSION" | awk -F'.' '{ print NF }')
    if [ $rec -eq 2 ]; then SEARCH_STR="^${PRODUCT_VERSION}.[0-9]*$"; else SEARCH_STR="^${PRODUCT_VERSION}$"; fi

    for id in $(pivnetAPI $PCF_PIVNET_TOKEN GET products/$PRODUCT_SLUG/releases 2>/dev/null | \
                jq -r ".releases[] | select(.version | scan(\"^$SEARCH_STR\")).id" | head -1); do
  
      fid=$(pivnetAPI $PCF_PIVNET_TOKEN GET products/$PRODUCT_SLUG/releases/$id 2>/dev/null | \
           jq -r ".product_files[] | select(.name | scan(\"^$PRODUCT_NAME\")) | select(.file_version | scan(\"$PRODUCT_VERSION\")).id")
  
      if [ "${fid}" != "" ]; then
        # --- ACCEPT EULA ---
        pivnetAPI $PCF_PIVNET_TOKEN POST products/$PRODUCT_SLUG/releases/$id/eula_acceptance > /dev/null 2>&1
        break
      else
        echo "ERROR: Unable to find $PRODUCT_SLUG $2 on Pivnet"
        exit 1
      fi
    done
  
    file=$(pivnetAPI $PCF_PIVNET_TOKEN GET products/$PRODUCT_SLUG/releases/$id 2>/dev/null | \
         jq -r ".product_files[] | select(.id | tostring | scan(\"^$fid$\")).aws_object_key" | \
         awk -F'/' '{ print $NF }')
  
    if [ ! -f /tmp/$file ]; then
      messageTitle "Download Product from PIVNET"
      messagePrint " - Product Slug:" "$PRODUCT_SLUG"
      messagePrint " - Product FileID:" "$fid"
      messagePrint " - Download Location:" "/tmp/$file"
      pivnetAPIdownload $PCF_PIVNET_TOKEN $PRODUCT_SLUG $id $fid $file
    fi
  
    cnt=$($OM $OM_LOGIN available-products | grep -c " $PRODUCT_SLUG ")
    if [ $cnt -eq 0 ]; then 
      messageTitle "Uploading Stemcell for Harbor"
      messagePrint " - Staging Stemcell Version:" "$SLUG_VER"
      messagePrint " - Staging Stemcell Type:" "$PRODUCT_SLUG"
      messagePrint " - Staging Stemcell Description:" "$PRODUCT_SLUG $SLUG_VER"

      while [ $cnt -eq 0 ]; do
        $OM $OM_LOGIN upload-product --product /tmp/$file > /dev/null 2>&1
        cnt=$($OM $OM_LOGIN available-products | grep -c " $PRODUCT_SLUG ")

        sleep 10
      done
    fi

    OPSMAN_AVAILABLE_PRODUCT=$($OM $OM_LOGIN available-products | grep " $PRODUCT_SLUG " | awk '{ print $4 }')

    messageTitle "Staging Harbor Product Tile"
    messagePrint " - Staging Harbor Tile:" "$OPSMAN_AVAILABLE_PRODUCT"
    $OM $OM_LOGIN stage-product --product-name $PRODUCT_SLUG --product-version ${OPSMAN_AVAILABLE_PRODUCT} > /dev/null 2>&1
    if [ $? -ne 0 ]; then
      echo "ERROR: failed to stage product"
      echo "       => $OM $OM_LOGIN stage-product \\"
      echo "          --product-name $PRODUCT_SLUG --product-version ${OPSMAN_AVAILABLE_PRODUCT}"
      exit 1
    fi
  fi
}



# getOpsManagerAMI GCP 2.6.9
# getOpsManagerAMI GCP 2.6
getOpsManagerAMI() {
  cloud=$1
  ver=$2
  slug=ops-manager

  if [ "${cloud}" == "Azure" ]; then sstr="Pivotal Ops Manager YAML for Azure|Pivotal Cloud Foundry Ops Manager YAML for Azure"; fi
  if [ "${cloud}" == "GCP" ]; then sstr="Pivotal Ops Manager YAML for GCP|Pivotal Cloud Foundry Ops Manager YAML for Azure"; fi
  if [ "${cloud}" == "AWS" ]; then sstr="Pivotal Ops Manager YAML for AWS|Pivotal Cloud Foundry Ops Manager YAML for AWS"; fi

  rec=$(echo "$ver" | awk -F'.' '{ print NF }')
  if [ $rec -eq 2 ]; then SEARCH_STR="^${ver}.[0-9]*$"; else SEARCH_STR="^${ver}$"; fi

  for id in $(pivnetAPI $PCF_PIVNET_TOKEN GET products/$slug/releases 2>/dev/null | \
              jq -r ".releases[] | select(.version | scan(\"^$SEARCH_STR\")).id" | head -1); do

    fid=$(pivnetAPI $PCF_PIVNET_TOKEN GET products/$slug/releases/$id 2>/dev/null | \
      jq -r ".product_files[] | select(.name | scan(\"^$sstr\")) | select(.file_version | scan(\"$ver\")).id")

    if [ "${fid}" != "" ]; then
      # --- ACCEPT EULA ---
      pivnetAPI $PCF_PIVNET_TOKEN POST products/$slug/releases/$id/eula_acceptance > /dev/null 2>&1
      break
    else
      echo "ERROR: Unable to find OpsManager $2 om Pivnet"
      exit 1
    fi
  done

  file=$(pivnetAPI $PCF_PIVNET_TOKEN GET products/$slug/releases/$id 2>/dev/null | \
         jq -r ".product_files[] | select(.id | tostring | scan(\"^$fid$\")).aws_object_key" | \
         awk -F'/' '{ print $NF }')

  pivnetAPIdownload $PCF_PIVNET_TOKEN $slug $id $fid $file

  if [ "${cloud}" == "GCP" ]; then 
    egrep "ops-manager" /tmp/$file | head -1 | awk '{ print $2 }'
  fi

  if [ "${cloud}" == "Azure" ]; then 
    egrep "http" /tmp/$file | head -1 | awk '{ print $2 }'
  fi

  if [ "${cloud}" == "AWS" ]; then 
    if [ "$AWS_REGION" != "" ]; then 
      egrep "^$AWS_REGION:" /tmp/$file | head -1 | awk '{ print $2 }'
    else
      egrep "ami-" /tmp/$file | head -1 | awk '{ print $2 }'
    fi
  fi

  # --- CLEANUP ---
  rm -f /tmp/$file
}

# getTerraformTemplate GCP 2.6 0.94.0
# getTerraformTemplate GCP 2.6 0.74.0
# getTerraformTemplate GCP 2.6 latest
getTerraformTemplate() {
  cloud=$1
  bundle=$2
  ver=$3
  slug=elastic-runtime

  if [ "${cloud}" == "GCP" ]; then sstr="GCP Terraform Templates"; fi
  if [ "${cloud}" == "AWS" ]; then sstr="AWS Terraform Templates"; fi
  if [ "${cloud}" == "Azure" ]; then sstr="Azure Terraform Templates"; fi

  if [ "${ver}" == "latest" ]; then 
    id=$(pivnetAPI $PCF_PIVNET_TOKEN GET products/$slug/releases 2>/dev/null | \
        jq -r ".releases[] | select(.version | scan(\"^$bundle\")).id" | head -1)
  
    fid=$(pivnetAPI $PCF_PIVNET_TOKEN GET products/$slug/releases/$id 2>/dev/null | \
      jq -r ".product_files[] | select(.name | scan(\"^$sstr\")).id")

    if [ "${fid}" != "" ]; then
      # --- ACCEPT EULA ---
      pivnetAPI $PCF_PIVNET_TOKEN POST products/$slug/releases/$id/eula_acceptance > /dev/null 2>&1
    fi
  else
    for id in $(pivnetAPI $PCF_PIVNET_TOKEN GET products/$slug/releases 2>/dev/null | \
                jq -r ".releases[] | select(.version | scan(\"^$bundle\")).id"); do
  
      fid=$(pivnetAPI $PCF_PIVNET_TOKEN GET products/elastic-runtime/releases/$id 2>/dev/null | \
        jq -r ".product_files[] | select(.name | scan(\"^$sstr\")) | select(.file_version | scan(\"$ver\")).id")
  
      if [ "${fid}" != "" ]; then 
        # --- ACCEPT EULA ---
        pivnetAPI $PCF_PIVNET_TOKEN POST products/$slug/releases/$id/eula_acceptance > /dev/null 2>&1
        break
      fi
    done
  fi

  file=$(pivnetAPI $PCF_PIVNET_TOKEN GET products/elastic-runtime/releases/$id 2>/dev/null | \
         jq -r ".product_files[] | select(.id | tostring | scan(\"^$fid$\")).aws_object_key" | \
         awk -F'/' '{ print $NF }')

  pivnetAPIdownload $PCF_PIVNET_TOKEN $slug $id $fid $file

  echo "/tmp/$file"
}

checkCloudCLI() {
  if [ "${cloud}" == "GCP" -o "${TF_DEPLOYMENT}" == "gcp" -o "${PCF_DEPLOYMENT_CLOUD}" == "GCP" ]; then
    # --- CHECK FOR AWS CLI ---
    GCLOUD=$(which gcloud)
    if [ "${GCLOUD}" != "" ]; then
      $GCLOUD --version >/dev/null 2>&1; ret=$?
      if [ ${ret} -eq 0 ]; then
        GCLOUD_VERSION=$($GCLOUD --version 2>/dev/null | grep "Google Cloud SDK" | awk '{ print $NF}')
        GCP_CLI_ENABLED=1
        messagePrint "checking for gcloud CLI utility" "installed - ${GCLOUD_VERSION}"
      else
        echo ""
        echo "ERROR: The gcloud utility does not seam to be correct"
        echo "       please install gcloud from https://cloud.google.com/sdk/install"; exit 1
      fi
    else
      messagePrint "checking for gcloud CLI utility" "not installed"
      echo ""
      echo "ERROR: gcloud utility is not installed. please install terraform from"
      echo "       https://cloud.google.com/sdk/install"; exit 1
    fi

    # --- CHECK FOR AWS CLI ---
    AWSCLI=$(which aws)
    if [ "${AWSCLI}" != "" ]; then
      $AWSCLI --version >/dev/null 2>&1; ret=$?
      if [ ${ret} -eq 0 ]; then
        AWS_VERSION=$($AWSCLI --version 2>/dev/null | awk -F'/' '{ print $2 }' | awk '{ print $1}')
        AWS_CLI_ENABLED=1
        messagePrint "checking for AWS CLI utility (needed for AWS Route53)" "installed - ${AWS_VERSION}"
      else
        echo ""
        echo "ERROR: the AWS cli utility does not seam to be correct, please reinstall it from:"
        echo "       https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html"; exit 1
      fi
    else
      messagePrint "checking for AWS CLI utility" "not installed"
      echo "ERROR: the AWS cli utility is not installed, please install it from:"
      echo "       https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html"; exit 1
    fi
  fi

  if [ "${cloud}" == "AWS" -o "${TF_DEPLOYMENT}" == "aws" -o "${PCF_DEPLOYMENT_CLOUD}" == "AWS" ]; then
    # --- CHECK FOR AWS CLI ---
    AWSCLI=$(which aws)
    if [ "${AWSCLI}" != "" ]; then
      $AWSCLI --version >/dev/null 2>&1; ret=$?
      if [ ${ret} -eq 0 ]; then
        AWS_VERSION=$($AWSCLI --version 2>/dev/null | awk -F'/' '{ print $2 }' | awk '{ print $1}')
        AWS_CLI_ENABLED=1
        messagePrint "checking for AWS CLI utility" "installed - ${AWS_VERSION}"
      else
        echo ""
        echo "ERROR: the AWS cli utility does not seam to be correct, please reinstall it from:"
        echo "       https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html"; exit 1
      fi
    else
      messagePrint "checking for AWS CLI utility" "not installed"
      echo "ERROR: the AWS cli utility is not installed, please install it from:"
      echo "       https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html"; exit 1
    fi
  fi

  if [ "${cloud}" == "Azure" -o "${TF_DEPLOYMENT}" == "azure" -o "${PCF_DEPLOYMENT_CLOUD}" == "Azure" ]; then
    # --- CHECK FOR AWS CLI ---
    AZCLI=$(which az)
    if [ "${AZCLI}" != "" ]; then
      $AZCLI -v >/dev/null 2>&1; ret=$?
      if [ ${ret} -eq 0 ]; then
        AZ_VERSION=$($AZCLI -v 2>/dev/null | egrep "^azure-cli" | awk '{ print $2 }'); ret=$?
        AZURE_CLI_ENABLED=1
        messagePrint "checking for Azure CLI utility (az)" "installed - ${AZ_VERSION}"
      else
        echo ""
        echo "ERROR: the $cloud CLI $(which az) does not seam to be correct"
        echo "       please install it from https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest"; exit 1
      fi
    else
      messagePrint "checking for $cloud CLI utility" "no installed"
    fi

    # --- CHECK FOR AWS CLI ---
    AWSCLI=$(which aws)
    if [ "${AWSCLI}" != "" ]; then
      $AWSCLI --version >/dev/null 2>&1; ret=$?
      if [ ${ret} -eq 0 ]; then
        AWS_VERSION=$($AWSCLI --version 2>/dev/null | awk -F'/' '{ print $2 }' | awk '{ print $1}')
        AWS_CLI_ENABLED=1
        messagePrint "checking for AWS CLI utility (needed for AWS Route53)" "installed - ${AWS_VERSION}"
      else
        echo ""
        echo "ERROR: the AWS cli utility does not seam to be correct, please reinstall it from:"
        echo "       https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html"; exit 1
      fi
    else
      messagePrint "checking for AWS CLI utility" "not installed"
      echo "ERROR: the AWS cli utility is not installed, please install it from:"
      echo "       https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html"; exit 1
    fi
  fi
}

write_line() {
  messageTitle "----------------------------------------------------------------------------------------------------------------"
}

wait_loop() {
  TIME=$1
  MESSAGE="$2"
  echo -e "$2 \c"

  n=1
  while [ $n -le $TIME ]; do
    str=$(printf "[%03d/%03d]" $n $TIME)
    echo -e ". $str\c"
    sleep 1
    echo -e "\b\b\b\b\b\b\b\b\b\b\c       "
    let n=n+1
  done

  echo -e "\n"
}

messageTitle() {
  _msg="$*"
  _dat=$(date "+%Y%m%d-%H:%M:%S") 

  if [ "${PCF_DEPLOYMENT_DEBUG}" == "true" -o "${DEBUG}" == "1" ]; then
    echo "[${_dat}] ${_msg}"
  else
    echo "${_msg}"
  fi
} 

messagePrint() {
  _msg="$1"
  _stt="$2"
  _cnt=$(echo "${_msg}" | wc -c | sed 's/ //g')
  _dat=$(date "+%Y%m%d-%H:%M:%S") 

  _str=""
  while [ $_cnt -lt 58 ]; do
    _str="${_str}."
    let _cnt=_cnt+1
  done
  
  # --- INIZIALIZE VALUES IF EMPTY --- ---
  [ "$DEBUG" == "" ] && DEBUG=0

  if [ "${PCF_DEPLOYMENT_DEBUG}" == "true" -o "${DEBUG}" == "1" ]; then 
    echo "[${_dat}] ${_msg} ${_str}: ${_stt}"
  else
    echo "${_msg} ${_str}: ${_stt}"
  fi
}

