#!/bin/bash
# ############################################################################################
# File: ........: pcfconfig-terraform / pcfconfig-opsman / pcfconfig-pks
# Language .....: bash
# Author .......: Sacha Dubois, Pivotal
# Description ..: PCF OpsManager Configuration Utility
# ############################################################################################

NODE=""
USER=""
PASS=""
DCRY=""
DEBUG=0
USAGE=0
NO_APPLY=0
NO_DOWNLOAD=0
AWS_CLI_ENABLED=1
GCP_CLI_ENABLED=1
AZURE_CLI_ENABLED=1
MSG_SILENT=0
PIVNET_TOKEN=""
ROUTE53_TOKEN=""
NOASK=0

TMPPATH=$(dirname $0)
PCFCONFIG_PATH=$(dirname $TMPPATH)
PCFCONFIG_BASE=$(basename $0)

# --- SOURCE FUNCTIONS---
. ${PCFCONFIG_PATH}/functions

# --- OPSMAN ---
OPSMAN_TEMPLATE=""

# --- PAS/PKS VARIABLES ---
OPS_UPLOAD=1
PAS_VERSION=""
PAS_SRT=0
PKS_VERSION=""
PKS_ADMIN_USER=""
PKS_ADMIN_PASS=""
PKS_ADMIN_MAIL=""
PKS_CLUSTER_1_NAME=""
PKS_CLUSTER_2_NAME=""
PKS_CLUSTER_3_NAME=""
PKS_CLUSTER_1_PLAN=""
PKS_CLUSTER_2_PLAN=""
PKS_CLUSTER_3_PLAN=""

TLS_CERTIFICATE=""
TLS_PRIVATE_KEY=""

# --- TERRAFORM ---
TERRAFORM_VARS=terraform.tfvars
TERRAFORM_TFSTATE=terraform.tfstate
TF_DEPLOYMENT=""
TF_TEMPLATE=""
PCF_VERSION=""
TF_PKS_VARFILE=""
TF_PAS_VARFILE=""
TF_WORKDIR="~/workspace"
TF_PREFIX=pivotal-cf-terraforming
TF_DIR_MODE=""

##############################################################################################
############################### COMMAND-LINE ARGS PROCESSING  ################################
##############################################################################################
echo "$*"
exit 1

while [ "$1" != "" ]; do
  case $1 in
    --no-ask) NOASK=1;;
    --debug) DEBUG=1;;
    --usage) USAGE=1;;
    --noapply) NO_APPLY=1;;
    --nodownload) NO_DOWNLOAD=1;;
    -u) USER=$2; shift;;                            # PCFCONFIG-OPSMAN / PCFCONFIG-PKS/PAS
    -p) PASS=$2; shift;;                            # PCFCONFIG-OPSMAN / PCFCONFIG-PKS/PAS
    -dp) DCRY=$2; shift;;                           # PCFCONFIG-OPSMAN 
    -pt) PIVNET_TOKEN=$2; shift;;                   # PCFCONFIG-PKS
    --decryption-key) DCRY=$2; shift;;              # PCFCONFIG-OPSMAN
    --pivnet-token) PIVNET_TOKEN=$2; shift;;        # PCFCONFIG-PKS
    --pks-version) PKS_VERSION=$2; shift;;          # PCFCONFIG-PKS
    --pks-cluster-1-name) PKS_CLUSTER_1_NAME=$2; shift;; 
    --pks-cluster-1-plan) PKS_CLUSTER_1_PLAN=$2; shift;; 
    --pks-cluster-2-name) PKS_CLUSTER_2_NAME=$2; shift;; 
    --pks-cluster-2-plan) PKS_CLUSTER_2_PLAN=$2; shift;; 
    --pks-cluster-3-name) PKS_CLUSTER_3_NAME=$2; shift;; 
    --pks-cluster-3-plan) PKS_CLUSTER_3_PLAN=$2; shift;; 
    --pas-version) PAS_VERSION=$2; shift;;          # PCFCONFIG-PAS
    --pas-srt) PAS_SRT=1;;                          # PCFCONFIG-PAS
    --tls_cert) TLS_CERTIFICATE=$2; shift;;         # PCFCONFIG-PAS
    --tls_private_key) TLS_PRIVATE_KEY=$2; shift;;  # PCFCONFIG-PAS
    --tls_root_cert) TLS_ROOT_CERT=$2; shift;;      # PCFCONFIG-PAS
    --pks-tfvars) TF_PKS_VARFILE=$2; shift;;        # TERRAFORM VARIABLE FILE
    --pas-admin-user) PAS_ADMIN_USER=$2; shift;;    # PCFCONFIG-PKS
    --pas-admin-pass) PAS_ADMIN_PASS=$2; shift;;    # PCFCONFIG-PKS
    --pas-admin-mail) PAS_ADMIN_MAIL=$2; shift;;    # PCFCONFIG-PKS
    --pks-admin-user) PKS_ADMIN_USER=$2; shift;;    # PCFCONFIG-PKS
    --pks-admin-pass) PKS_ADMIN_PASS=$2; shift;;    # PCFCONFIG-PKS
    --pks-admin-mail) PKS_ADMIN_MAIL=$2; shift;;    # PCFCONFIG-PKS
    --pas-tfvars) TF_PAS_VARFILE=$2; shift;;        # TERRAFORM VARIABLE FILE
    --aws-route53) ROUTE53_TOKEN=$2; shift;;        # TERRAFORM VARIABLE FILE
    --cf-version) PCF_VERSION=$2; shift;;           # PCF VERSION
    --tf-template) TF_TEMPLATE=$2; shift;;          # TERRAFORM TEMPLATE VERSION
    --deployment) TF_DEPLOYMENT=$2; shift;;         # TERRAFORM VARIABLE FILE
    --directory-prefix) TF_PREFIX=$2; shift;;       # DIRECTORY PREFIX
    --install-mode) TF_DIR_MODE=$2; shift;;         # DIRECTORY MODE (clean, preserve, delete)
    --opsman-template) OPSMAN_TEMPLATE=$2; shift;;  # OPSMAN TEMPLATE 
    --stemcell-version) PCF_TILE_STEMCELL_VERSION=$2; shift;;     # PKS STEMCELL VERSION
    --stemcell-type) PCF_TILE_STEMCELL_TYPE=$2; shift;;           # PKS STEMCELL TYPE
    --pks-template) PCF_TILE_PKS_CONFIG=$2; shift;;                   # PKS STEMCELL TYPE
    --pas-template) PCF_TILE_PAS_CONFIG=$2; shift;;                   # PKS STEMCELL TYPE
    --pas-slug) PCF_TILE_PAS_SLUG=$2; shift;;                   # PKS STEMCELL TYPE
  esac
  shift
done

echo "TLS_CERTIFICATE:$TLS_CERTIFICATE"
echo "TLS_PRIVATE_KEY:$TLS_PRIVATE_KEY"
echo "TLS_ROOT_CERT:$TLS_ROOT_CERT"
exit 1

# --- COMPATIBLITE VALUES ---
PCF_DEPLOYMENT_CLOUDID=$TF_DEPLOYMENT
PCF_PIVNET_TOKEN=$PIVNET_TOKEN

[ "$TF_DEPLOYMENT" == "aws" ]   && PCF_DEPLOYMENT_CLOUD="AWS" && PCF_DEPLOYMENT_CLOUDID="aws"
[ "$TF_DEPLOYMENT" == "azure" ] && PCF_DEPLOYMENT_CLOUD="Azure" && PCF_DEPLOYMENT_CLOUDID="azure"
[ "$TF_DEPLOYMENT" == "gcp" ]   && PCF_DEPLOYMENT_CLOUD="GCP" && PCF_DEPLOYMENT_CLOUDID="gcp"

if [ "${PKS_VERSION}" != "" ]; then
  cnt=$(echo $PKS_VERSION | awk -F'.' '{ print NF }')
  if [ $cnt -eq 2 ]; then
    PCF_TILE_PKS_BUNDLE=$PKS_VERSION
    PCF_TILE_PKS_VERSION=""
  else
    PCF_TILE_PKS_BUNDLE=$(echo $PKS_VERSION | awk -F'.' '{ printf("%s.%s\n",$1,$2 )}')
    PCF_TILE_PKS_VERSION=$PKS_VERSION
  fi
fi

if [ "${PAS_VERSION}" != "" ]; then
  cnt=$(echo $PAS_VERSION | awk -F'.' '{ print NF }')
  if [ $cnt -eq 2 ]; then
    PCF_TILE_PAS_BUNDLE=$PAS_VERSION
    PCF_TILE_PAS_VERSION=""
  else
    PCF_TILE_PAS_BUNDLE=$(echo $PAS_VERSION | awk -F'.' '{ printf("%s.%s\n",$1,$2 )}')
    PCF_TILE_PAS_VERSION=$PAS_VERSION
  fi
fi

if [ "${PCF_VERSION}" != "" ]; then 
  cnt=$(echo $PCF_VERSION | awk -F'.' '{ print NF }') 
  if [ $cnt -eq 2 ]; then 
    PCF_OPSMANAGER_BUNDLE=$PCF_VERSION
    PCF_OPSMANAGER_VERSION=""
  else
    PCF_OPSMANAGER_BUNDLE=$(echo $PCF_VERSION | awk -F'.' '{ printf("%s.%s\n",$1,$2 )}') 
    PCF_OPSMANAGER_VERSION=$PCF_VERSION
  fi
fi

[ "$PKS_CLUSTER_1_NAME" == "-" ] && PKS_CLUSTER_1_NAME=""
[ "$PKS_CLUSTER_1_PLAN" == "-" ] && PKS_CLUSTER_1_PLAN=""
[ "$PKS_CLUSTER_2_NAME" == "-" ] && PKS_CLUSTER_2_NAME=""
[ "$PKS_CLUSTER_2_PLAN" == "-" ] && PKS_CLUSTER_2_PLAN=""
[ "$PKS_CLUSTER_3_NAME" == "-" ] && PKS_CLUSTER_3_NAME=""
[ "$PKS_CLUSTER_3_PLAN" == "-" ] && PKS_CLUSTER_3_PLAN=""

##############################################################################################
########################################## FUNCTIONS #########################################
##############################################################################################

echo ""
echo "PCF Configuration Utility Module: ($PCFCONFIG_BASE)"
echo "by Sacha Dubois, Pivotal Inc,"
echo "-----------------------------------------------------------------------------------------------------------"

usage_pks_setup() {
  echo "USAGE: $PCFCONFIG_BASE [options]"
  echo "              OPTIONS: --pks-admin-user <user>          - PKS Administration User"
  echo "                       --pas-admin-pass <password>      - PKS Administration Password"
  echo "                       --pks-admin-mail <email>         - PKS Administration Email"
  echo "                       --pks-cluster-1-name <name>      - PKS Kubernetes Cluster 1 Name"
  echo "                       --pks-cluster-1-plan <name>      - PKS Kubernetes Cluster 1 Plan"
  echo "                       --pks-cluster-2-name <name>      - PKS Kubernetes Cluster 2 Name"
  echo "                       --pks-cluster-2-plan <name>      - PKS Kubernetes Cluster 2 Plan"
  echo "                       --pks-cluster-3-name <name>      - PKS Kubernetes Cluster 3 Name"
  echo "                       --pks-cluster-3-plan <name>      - PKS Kubernetes Cluster 3 Plan"
  echo "                       --debug                          - Debugging"
}

usage_terraform() {
  echo "USAGE: $PCFCONFIG_BASE [options]"
  echo "              OPTIONS: --pks-tfvars <terraform.tfvars>  - Terraform Variable File for PKS"
  echo "                       --pas-tfvars <terraform.tfvars>  - Terraform Variable File for PAS"
  echo "                       --pivnet-token <token>           - Pivnet API Token"
  echo "                       --workdir <directory>            - Working Directory (default: ~/workspace)"
  echo "                       --cf-version <version>           - PCF Version (ie. 2.4.6)"
  echo "                       --deployment <cloud-env>         - Deployment (awx, gcp or azure)"
  echo "                       --directory-prefix <prefix>      - Directory Prefix (default: pivotal-cf-terraforming)"
  echo "                       --install-mode <mode>            - Mode if Terraform target directory already exists"
  echo "                                                            => delete - remove old directory" 
  echo "                                                            => preserve - rename it to dir.YYYYMMDD"
  echo "                                                            => clean - clean from old terraform deployments"
  echo "                       --noapply                        - Do not Apply changes on OpsManager"
  echo "                       --debug                          - Debugging"
}

usage_opsman() {
  echo "USAGE: $PCFCONFIG_BASE [options]"
  echo "              OPTIONS: -u <admin>                       - OpsManager Admin User"
  echo "                       -p <admin>                       - OpsManager Admin Password"
  echo "                       --decryption-key <phrase>        - OpsManager Decryption Prhase"
  echo "                       --pivnet-token <token>           - Pivnet API Token"
  echo "                       --aws-route53 <token>            - AWS Route53 Token"
  echo "                       --opsman-template <file>         - Specify the OpsManager Template Name"
  echo "                       --terraform-directory <dir>      - Specify the Terraform Directory"
  echo "                       --terraform-mode <pks/pas>       - Specify the Terraform Mode"
  echo "                                                          => pas - Pivotal Application Platform (PAS)"
  echo "                                                          => pks - Pivotal Container Service (PKS)"
  echo "                       --debug                          - Debugging"
  echo "                       --noapply                        - Do not Apply changes on OpsManager"
}

usage_pks() {
  echo "USAGE: $PCFCONFIG_BASE [options]"
  echo "              OPTIONS: -u <admin>                 - OpsManager Amdin User"
  echo "                       -p <admin>                 - OpsManager Amdin Password"
  echo "                       --pivnet-token <token>     - Pivnet API Token"
  echo "                       --pks-version <version>    - PKS Version"
  echo "                       --aws-route53 <token>      - AWS Route53 Token"
  echo "                       --tls_cert <file>          - TLS Certificate (default self-generated)"
  echo "                       --tls_private_key <file>   - TLS Private Key (default self-generated)"
  echo "                       --debug                    - Debugging"
  echo "                       --noapply                  - Do not Apply changes on OpsManager"
  echo "                       --nodownload               - No software download from pivnet if copy local is available"
}

usage_pas() {
  echo "USAGE: $PCFCONFIG_BASE [options]"
  echo "              OPTIONS: -u <admin>                 - OpsManager Amdin User"
  echo "                       -p <admin>                 - OpsManager Amdin Password"
  echo "                       --pivnet-token <token>     - Pivnet API Token"
  echo "                       --pas-version <version>    - PAS Version"
  echo "                       --pas-srt                  - PAS Small Footprint"
  echo "                       --aws-route53 <token>      - AWS Route53 Token"
  echo "                       --debug                    - Debugging"
  echo "                       --noapply                  - Do not Apply changes on OpsManager"
  echo "                       --nodownload               - No software download from pivnet if copy local is available"
}

environmentCleanUp() {
  TFDIR="$1"

  if [ "${cloud}" == "AWS" -o "${TF_DEPLOYMENT}" == "aws" ]; then
    ENV_NAME=$(egrep "^env_name" $TFDIR/$TERRAFORM_VARS | awk '{ print $NF }' | sed 's/"//g')
    AWS_LOCATION=$(egrep "^region" $TFDIR/$TERRAFORM_VARS | awk '{ print $NF }' | sed 's/"//g')
    DNS_SUFFIX=$(egrep "^dns_suffix" $TFDIR/$TERRAFORM_VARS | awk '{ print $NF }' | sed 's/"//g')

    if [ "${ROUTE53_TOKEN}" != "" ]; then
      aws route53 list-hosted-zones-by-name --dns-name $DNS_SUFFIX --hosted-zone-id $ROUTE53_TOKEN > /dev/null 2>&1
      if [ $? -eq 0 ]; then
        ROUTE53_STAT="zone managed by route53"
      fi
    fi

    messagePrint "Cleaning up Leftover AWS Objects" "Environment: $ENV_NAME Location: $AWS_LOCATION"

    cleanRoute53
    cleanAWSenv
  fi

  if [ "${cloud}" == "GCP" -o "${TF_DEPLOYMENT}" == "gcp" ]; then
    ENV_NAME=$(egrep "^env_name" $TFDIR/$TERRAFORM_VARS | awk '{ print $NF }' | sed 's/"//g')
    GCP_REGION=$(egrep "^region" $TFDIR/$TERRAFORM_VARS | awk '{ print $NF }' | sed 's/"//g')

    messagePrint "Cleaning up Leftover GCP Objects" "Environment: $ENV_NAME Location: $GCP_REGION"
    cleanGCPenv
  fi
}

checkPKStools() {
  # --- CHECK FOR OPENSSL UTILITY ---
  OPENSSL=$(which openssl)
  if [ "${OPENSSL}" == "" ]; then
    echo ""
    echo "ERROR: please install the openssl utility"; exit 0
  else
    # --- TEST FOR WORKING OPENSSL UTILITY ---
    OPENSSL_VERSION=$($OPENSSL version 2>/dev/null); ret=$?
    if [ ${ret} -ne 0 -o "${OPENSSL_VERSION}" == "" ]; then
      echo ""
      echo "ERROR: the utility $(which openssl) does not seam to be correct"
      echo "       please install the openssl utility"; exit 0
    else
      messagePrint "checking for the openssl utility" "Installed - ${OPENSSL_VERSION}"
    fi
  fi
}

checkEnvironment() {
  # --- VERIFY TERRAFORM FILES ---
  TERRAFORM_VARS=terraform.tfvars
  TERRAFORM_TFSTATE=terraform.tfstate

  if [ -f main.tf -a -f variables.tf ]; then
    pks=$(egrep -c "module \"pks\"" main.tf)
    if [ ${pks} -gt 0 ]; then
      messagePrint "checking terraform product selection" "Pivotal Container Service (PKS)"
      product="Pivotal Container Service (PKS)"; productid=PKS
    fi

    pas=$(egrep -c "module \"pas\"" main.tf)
    if [ ${pas} -gt 0 ]; then
      messagePrint "checking terraform product selection" "Pivotal Application Service (PAS)"
      product="Pivotal Cloud Foundry"; productid=PCF
    fi

    if [ "${productid}" == "PCF" ]; then 
      # --- CHECK FOR CF UTILITY ---
      CF=$(which cf)
      if [ "${CF}" == "" ]; then
        echo ""
        echo "ERROR: please install the cf utility from https://docs.cloudfoundry.org/cf-cli/install-go-cli.html"; exit 1
      else
        # --- TEST FOR WORKING OM UTILITY ---
        CF_VERSION=$($CF version | awk '{ print $NF }' 2>/dev/null); ret=$?
        if [ ${ret} -ne 0 -o "${CF_VERSION}" == "" ]; then
          echo ""
          echo "ERROR: The om utility $(which om) does not seam to be correct"
          echo "       please install the om utility from https://docs.cloudfoundry.org/cf-cli/install-go-cli.html"; exit 1
        else
          messagePrint "checking for the cf utility" "Installed - ${CF_VERSION}"
        fi
      fi
    fi

    # --- VERIFY PROVIDER ---
    CLOUD_PROVIDER=$(egrep "^provider" main.tf | head -1 | sed 's/"//g' | awk '{ print $2 }')
    case $CLOUD_PROVIDER in
      azurerm)
           messagePrint "checking terraform cloud provider" "Microsoft Azure (AZURE)"
           cloud="Azure"; PCF_CLOUD_NAME=azure
           ;;
      aws)
          messagePrint "checking terraform cloud provider" "Amazon WebServices (AWS)"
          cloud="AWS"; PCF_CLOUD_NAME=aws
          ;;
      google)
          messagePrint "checking terraform cloud provider" "Google Gloud Platform (GCP)"
          cloud="GCP"; PCF_CLOUD_NAME=gcp
          ;;
     *)
          messagePrint "checking terraform cloud provider" "Unknown Cloud Provider ($CLOUD_PROVIDER)"
          echo "ERROR: The cloud provider $CLOUD_PROVIDER is currently not supported"; exit 1
          ;;
    esac

    checkCloudCLI

    # --- TERRAFORM NOT CONFIGURED YET ---
    if [ ! -f $TERRAFORM_VARS -a ! -f $TERRAFORM_TFSTATE ]; then
      echo ""
      echo "ERROR: terraform vaiables file $TERRAFORM_VARS has not been created by now."
      echo "       Please refer to the $product documentation and follow the"
      echo "       instructions in the section: \"Installing $productid on $cloud using Terraform\""; exit 1
    fi

    # --- CHECK FO AN INITIAL RUN ---
    if [ -f $TERRAFORM_VARS -a ! -d .terraform ]; then
      echo ""
      echo "ERROR: terraform vaiables file $TERRAFORM_VARS has been created but terraform"
      echo "       has not yet been initialzed (terraform init)."
      echo "       Please refer to the $product documentation and follow the"
      echo "       instructions in the section: \"Installing $productid on $cloud using Terraform\""; exit 1
    fi

    # --- CHECK FO AN INITIAL RUN ---
    if [ -f $TERRAFORM_VARS -a -d .terraform -a ! -f plan ]; then
      echo ""
      echo "ERROR: Terraform has been initialized already but no plan has been created yet."
      echo "       Please run \"terraform plan -out=plan\" to create a plan or consult the "
      echo "       $product documentation and follow the"
      echo "       instructions in the section: \"Installing $productid on $cloud using Terraform\""; exit 1
    fi

    # --- TERRAFORM IS READY TO DEPLOY ---
    if [ -f $TERRAFORM_VARS -a -f plan -a ! -f $TERRAFORM_TFSTATE ]; then
      echo ""
      echo "ERROR: Terraform has been initialized and a plan has been deployed."
      echo "       Please run \"terraform apply 'plan'\" to deploy installation to $cloud."
      echo "       On questions please consult the $product documentation and follow the"
      echo "       instructions in the section: \"Installing $productid on $cloud using Terraform\""; exit 1
    fi

#    if [ -f $TERRAFORM_TFSTATE ]; then
#      cnt=$($JQ -r '.modules[0].outputs.ops_manager_ssh_public_key_name.value' $TERRAFORM_TFSTATE | grep -v "null" | wc -l | sed 's/ *//g')
#      if [ $cnt -eq 0 ]; then 
#        echo "ERROR: not entry found for 'ops_manager_ssh_public_key_name' in the $TERRAFORM_TFSTATE" 
#        echo "       something probably wrong with the terraform deployment"
#      fi
#    fi

    ver=`$JQ -r '.terraform_version' $TERRAFORM_TFSTATE 2>/dev/null`
    if [ "${ver}" == "" ]; then
      echo ""
      echo "ERROR: $0 $TERRAFORM_TFSTATE is not a terraform state file"; exit 1
    fi

    if [ "${cloud}" == "GCP" -a "${GCP_CLI_ENABLED}" -eq 1 ]; then
      OPSMAN_CONFIG="opsmen_gcp.yml"
      GCP_DNS_SUFFIX=$(egrep "^dns_suffix" $TERRAFORM_VARS | sed 's/"//g' | awk '{ print $NF }')
      GCP_DNS_PREFIX=$(egrep "^env_name" $TERRAFORM_VARS | sed 's/"//g' | awk '{ print $NF }')
      GCP_PROJECT_ID=$(egrep "^project" $TERRAFORM_VARS | sed 's/"//g' | awk '{ print $NF }')
      GCP_DNS_SUBDOMAIN="${GCP_DNS_PREFIX}.${GCP_DNS_SUFFIX}"
      GCP_REGION=$(egrep "^region" $TERRAFORM_VARS | sed 's/"//g' | awk '{ print $NF }')
      GCP_OPS_MANAGER_URL=$(egrep "^opsman_image_url" $TERRAFORM_VARS | sed 's/"//g' | awk '{ print $NF }')
      GCP_AVAILABILITY_ZONES=$(egrep "^zones" $TERRAFORM_VARS | \
        sed -e 's/^.*= //g' -e 's/"//g' -e 's/\[//g' -e 's/\]//g')
      OPSMAN_VERSION=guguseli
      #OPSMAN_VERSION=$(egrep ",${GCP_OPS_MANAGER_URL}," $PCFCONFIG_PATH/files/opsman-release-notes.txt | \
      #  head -1 | awk -F',' '{ print $1}')
      OPSMAN_MINOR_VERSION=$(echo $OPSMAN_VERSION | awk -F'.' '{ printf("%d.%d\n", $1, $2)}')
      DNS_SUFFIX=$GCP_DNS_SUFFIX
      DNS_PREFIX=$GCP_DNS_PREFIX
      AVAILABILITY_ZONES="$(egrep "^zones" $TERRAFORM_VARS | sed -e 's/^.*\[//g' -e 's/"//g' -e 's/,//g' -e 's/\]//g')"
      AVAILABILITY_ZONE1=$(echo "${AVAILABILITY_ZONES}" | awk '{ print $1 }')
      AVAILABILITY_ZONE2=$(echo "${AVAILABILITY_ZONES}" | awk '{ print $2 }')
      AVAILABILITY_ZONE3=$(echo "${AVAILABILITY_ZONES}" | awk '{ print $3 }')

      # --- CHECK THE AVAILABILITY_ZONE ---
      for n in $AVAILABILITY_ZONE1 $AVAILABILITY_ZONE2 $AVAILABILITY_ZONE3; do
        cnt=$($GCLOUD compute zones list | grep "${GCP_REGION}" | grep -c "${n}")
        if [ $cnt -eq 0 ]; then 
          echo "ERROR: GCP Availability Region: ${GCP_REGION} does not have a Availability Zone: $n"
          echo "       => gcloud compute zones list"
          echo ""
          $GCLOUD compute zones list | egrep "NAME|$GCP_REGION" | sed 's/^/       /g'
          echo ""
          exit 1
        fi
      done

      GCP_SVC_NAME=$(sed -n '/^service_account_key/,/^SERVICE_ACCOUNT_KEY/p' $TERRAFORM_VARS | grep "client_email" | \
         sed -e 's/"//g' -e 's/,//g' | awk '{ print $NF }')
      GCP_SVC_PRJID=$(sed -n '/^service_account_key/,/^SERVICE_ACCOUNT_KEY/p' $TERRAFORM_VARS | grep "project_id" | \
         sed -e 's/"//g' -e 's/,//g' | awk '{ print $NF }')

      if [ "${GCP_PROJECT_ID}" != "${GCP_SVC_PRJID}" ]; then 
        echo "ERROR: GCP ProjectID ($GCP_PROJECT_ID) in $TERRAFORM_VARS does not match the Project ID ($GCP_SVC_PRJID)"
        echo "       in the Service Account definition"; exit 1
      fi

      echo "Verify $cloud configuration:"
      messagePrint " - GCP ServiceAccount" "$GCP_SVC_NAME"
      messagePrint " - GCP ServiceAccount ProjectID" "$GCP_SVC_PRJID"
      messagePrint " - GCP Region" "$GCP_REGION"
      messagePrint " - GCP Availability Zone" "$GCP_AVAILABILITY_ZONES"
      messagePrint " - DNS Domain Suffix" "$GCP_DNS_SUFFIX"
      messagePrint " - DNS Domain Prefix" "$GCP_DNS_PREFIX"
      messagePrint " - DNS SubDomain" "$GCP_DNS_SUBDOMAIN"
      messagePrint " - OPS Manager AMI" "$GCP_OPS_MANAGER_URL - $OPSMAN_VERSION"

      # --- TEST ACCESS TO AWS ---
      gcloud projects list > /dev/null 2>&1
      if [ $? -ne 0 ]; then
        echo "ERROR: Accessing GCP with the gcloud utility has been failed"
        exit
      fi

      echo "Verify $cloud Ops Manager instance"
      $TF output > /dev/null 2>&1; ret=$?
      if [ $ret -eq 0 ]; then
        OPS_MANAGER_DNS=$($TF output | egrep "^ops_manager_dns" | awk '{ print $NF }')
        OPS_MANAGER_PUBLIC_IP=$($TF output | egrep "^ops_manager_public_ip" | awk '{ print $NF }')
        OPS_MANAGER_PRIVATE_IP=$($TF output | egrep "ops_manager_private_ip" | awk '{ print $NF }')
        DNS_SERVERS=$(terraform output | sed -n '/^env_dns_zone_name_servers/,/]/p' | \
          sed -e 1d -e '$d' -e 's/,//g' -e 's/  *//g' -e 's/    //g' | paste -s -d " " - - - -)
        DNS1=$(echo $DNS_SERVERS | awk '{ print $1 }')
        DNS2=$(echo $DNS_SERVERS | awk '{ print $2 }')
        DNS3=$(echo $DNS_SERVERS | awk '{ print $3 }')
        DNS4=$(echo $DNS_SERVERS | awk '{ print $4 }')
      else
        OPS_MANAGER_DNS=$($JQ -r '.modules[].outputs.dns.value' $TERRAFORM_TFSTATE | grep -v null)
        OPS_MANAGER_PUBLIC_IP=$($JQ -r '.modules[].outputs.public_ip.value' $TERRAFORM_TFSTATE | grep -v null)
        OPS_MANAGER_PRIVATE_IP=$($JQ -r '.modules[].outputs.ops_manager_private_ip.value' $TERRAFORM_TFSTATE | grep -v null)
        DNS_SERVERS=$($JQ -r '.modules[].outputs.ops_manager_private_ip.value' $TERRAFORM_TFSTATE | grep -v null)

        DNS1=$($JQ -r '.modules[2].outputs.name_servers.value[0]' $TERRAFORM_TFSTATE)
        DNS2=$($JQ -r '.modules[2].outputs.name_servers.value[1]' $TERRAFORM_TFSTATE)
        DNS3=$($JQ -r '.modules[2].outputs.name_servers.value[2]' $TERRAFORM_TFSTATE)
        DNS4=$($JQ -r '.modules[2].outputs.name_servers.value[3]' $TERRAFORM_TFSTATE)
        DNS_SERVERS="${DNS1} ${DNS2} ${DNS3} ${DNS4}"
      fi

      #gcloud compute instances describe gcp-ops-manager --zone europe-west3-b
      instance_status=$(gcloud compute instances list --filter="name=('${GCP_DNS_PREFIX}-ops-manager')" | \
            grep "${GCP_DNS_PREFIX}-ops-manager" | awk '{ print $NF }')
      
      messagePrint " - Ops Manager VM Name" "${GCP_DNS_PREFIX}-ops-manager"
      messagePrint " - Ops Manager Instance" "$instance_status"
      messagePrint " - DNS Servers" "$DNS_SERVERS"
      messagePrint " - Ops Manager DNS Name" "$OPS_MANAGER_DNS"

      # --- DNS PRECHECK ---
      nslookup -timeout=10 $OPS_MANAGER_DNS 8.8.8.8 > /dev/null 2>&1; ret=$?
      if [ "${ROUTE53_TOKEN}" != "" -a $ret -ne 0 ]; then
        # --- CHECK IF ZONE RECORDS ARE AVAILABLE ---
        aws route53 list-hosted-zones-by-name --dns-name $DNS_SUFFIX --hosted-zone-id $ROUTE53_TOKEN > /dev/null 2>&1
        if [ $? -eq 0 ]; then
          ROUTE53_STAT="zone managed by route53"
        else
          ROUTE53_STAT="no dns zone found"
          ROUTE53_ZONEID=""
        fi

        echo "Updating AWS Route53 DNS records:"
        messagePrint " - Validating AWS Route53 ZoneID" "$ROUTE53_TOKEN"
        messagePrint " - Validating AWS Route53 Zone: (${GCP_DNS_SUFFIX})" "$ROUTE53_STAT"
        messagePrint " - Define DNS Record for (${GCP_DNS_SUBDOMAIN})" ""
        sublen=$(echo $GCP_DNS_SUBDOMAIN | wc -c | sed 's/ *//g')

        printf "      %${sublen}s    NS     $DNS1\n" "$GCP_DNS_SUBDOMAIN"
        printf "      %${sublen}s           $DNS2\n" ""
        printf "      %${sublen}s           $DNS3\n" ""
        printf "      %${sublen}s           $DNS4\n" ""

        TMPROUTE53=/tmp/$$_tmp_route53.json
        echo "{"                                                   >  $TMPROUTE53
        echo "  \"Comment\": \"CREATE/DELETE/UPSERT a record \","  >> $TMPROUTE53
        echo "  \"Changes\": [{"                                   >> $TMPROUTE53
        echo "  \"Action\": \"UPSERT\","                           >> $TMPROUTE53
        echo "  \"ResourceRecordSet\": {"                          >> $TMPROUTE53
        echo "    \"Name\": \"${GCP_DNS_SUBDOMAIN}\","             >> $TMPROUTE53
        echo "    \"Type\": \"NS\","                               >> $TMPROUTE53
        echo "    \"TTL\": 300,"                                   >> $TMPROUTE53
        echo "    \"ResourceRecords\": [ "                         >> $TMPROUTE53
        echo "      { \"Value\": \"${DNS1}\" },"                   >> $TMPROUTE53
        echo "      { \"Value\": \"${DNS2}\" },"                   >> $TMPROUTE53
        echo "      { \"Value\": \"${DNS3}\" },"                   >> $TMPROUTE53
        echo "      { \"Value\": \"${DNS4}\" }"                    >> $TMPROUTE53
        echo "    ]"                                               >> $TMPROUTE53
        echo "}}]"                                                 >> $TMPROUTE53
        echo "}"                                                   >> $TMPROUTE53

        # --- GET AWS INSTANCE ---
        if [ $DEBUG -gt 0 ]; then
          echo "# -------------------------- DEBUGGING START -----------------------------"
          cat $TMPROUTE53
          echo "# -------------------------- DEBUGGING END -------------------------------"
        fi

        aws route53 change-resource-record-sets --hosted-zone-id $ROUTE53_TOKEN \
            --change-batch file://${TMPROUTE53} > /dev/null 2>&1
        if [ $? -eq 0 ]; then
          messagePrint " - Updating AWS Route53 Record for (${GCP_DNS_SUBDOMAIN})" "succeeded"
        else
          messagePrint " - Updating AWS Route53 Record for (${GCP_DNS_SUBDOMAIN})" "failed"
          echo "WARNING: Unable to update AWS Route53 record $GCP_DNS_SUBDOMAIN for zone $GCP_DNS_SUFFIX"
          echo "         please try manually"
        fi

        wait_loop 60 "Waiting for DNS records to be pushed"

        # --- GCP CHEKING DNS ---
        echo "Validating GCP OPS Manager DNS records ($OPS_MANAGER_DNS)"
        nslookup -timeout=10 $OPS_MANAGER_DNS 8.8.8.8 > /dev/null 2>&1; ret=$?
        if [ $ret -ne 0 ]; then 
          i=1; ret="failed"; dns_google_stat="failed"
           while [ $i -lt 10 -a ${ret} == "failed" ]; do
            sleep 10
            nslookup $OPS_MANAGER_DNS 8.8.8.8 > /dev/null 2>&1; ret=$?
            if [ $ret -eq 0 ]; then dns_google_stat="successful"; fi
            messagePrint "   => Verify DNS lookup Google (8.8.8.8)" "$dns_google_stat"
            let i=i+1
          done
        else
          messagePrint "   => Verify DNS lookup Google (8.8.8.8)" "successful"
        fi

        for n in $DNS_SERVERS; do
          nslookup $OPS_MANAGER_DNS $n > /dev/null 2>&1; ret=$?
          if [ $ret -eq 0 ]; then dns_stat="successful"; else dns_stat="failed"; fi
          messagePrint "   => Verify DNS lookup ($n)" "$dns_stat"
        done

        localdns=$(nslookup localhost | grep Server:  | awk '{ print $2 }')
        i=1; ret="failed"; dns_google_stat="failed"
         while [ $i -lt 30 -a ${ret} == "failed" ]; do
          sleep 10
          nslookup $OPS_MANAGER_DNS > /dev/null 2>&1; ret=$?
          if [ $ret -eq 0 ]; then dns_google_stat="successful"; fi
          messagePrint "   => Verify DNS lookup localhost ($localdns)" "$dns_google_stat"
          let i=i+1
        done

        messagePrint " - Ops Manager Public IP" "$OPS_MANAGER_PUBLIC_IP"
        messagePrint " - Ops Manager Private IP" "$OPS_MANAGER_PRIVATE_IP"

#hullu
        if [ "${dns_google_stat}" == "failed" ]; then
          messagePrint "   Verify DNS lookup Google (8.8.8.8)" "$dns_stat"
          subdomain=$(echo $OPS_MANAGER_DNS | sed -e 's/\./<1>/' -e 's/^.*<1>//g')
          sublen=$(echo $subdomain | wc -c | sed 's/ *//g')

          echo ""
          echo "ERROR: DNS entry for $OPS_MANAGER_DNS external to AWS seams not to be working."
          echo "       Make sure you add a NS entry for your subdomain $subdomain on your DNS zone"
          echo "       for $AWS_DNS_SUFFIX."
          echo ""
          printf "      %${sublen}s    NS     $DNS1\n" "$subdomain"
          printf "      %${sublen}s           $DNS2\n" ""
          printf "      %${sublen}s           $DNS3\n" ""
          printf "      %${sublen}s           $DNS4\n" ""

          echo ""

          echo "Manager Name can not be resolved through DNS"
          exit 1
        else
          OPS_MANAGER=OPS_MANAGER_DNS
        fi
      fi
    fi

    if [ "${cloud}" == "AWS" -a "${AWS_CLI_ENABLED}" -eq 1 ]; then
      OPSMAN_CONFIG="opsmen_aws.yml"
      AWS_ACCESS_KEY=$(egrep "^access_key" $TERRAFORM_VARS | sed 's/"//g' | awk '{ print $NF }')
      AWS_SECRET_KEY=$(egrep "^secret_key" $TERRAFORM_VARS | sed 's/"//g' | awk '{ print $NF }')
      AWS_DNS_SUFFIX=$(egrep "^dns_suffix" $TERRAFORM_VARS | sed 's/"//g' | awk '{ print $NF }')
      AWS_DNS_PREFIX=$(egrep "^env_name" $TERRAFORM_VARS | sed 's/"//g' | awk '{ print $NF }')
      AWS_DNS_SUBDOMAIN="${AWS_DNS_PREFIX}.${AWS_DNS_SUFFIX}"
      AWS_REGION=$(egrep "^region" $TERRAFORM_VARS | sed 's/"//g' | awk '{ print $NF }')
      AWS_OPS_MANAGER_AMI=$(egrep "^ops_manager_ami" $TERRAFORM_VARS | sed 's/"//g' | awk '{ print $NF }')
      AWS_AVAILABILITY_ZONES=$(egrep "^availability_zones" $TERRAFORM_VARS | \
        sed -e 's/^.*= //g' -e 's/"//g' -e 's/\[//g' -e 's/\]//g')
      OPSMAN_VERSION="guguseli"
      #OPSMAN_VERSION=$(egrep ",${AWS_OPS_MANAGER_AMI}," $PCFCONFIG_PATH/files/old/opsman-release-notes.txt | \
      #  head -1 | awk -F',' '{ print $1}')
      OPSMAN_MINOR_VERSION=$(echo $OPSMAN_VERSION | awk -F'.' '{ printf("%d.%d\n", $1, $2)}')
      DNS_SUFFIX=$AWS_DNS_SUFFIX
      DNS_PREFIX=$AWS_DNS_PREFIX
      AVAILABILITY_ZONES="$(egrep "^availability_zones" $TERRAFORM_VARS | sed -e 's/^.*\[//g' -e 's/"//g' -e 's/,//g' -e 's/\]//g')"
      AVAILABILITY_ZONE1=$(echo "${AVAILABILITY_ZONES}" | awk '{ print $1 }') 
      AVAILABILITY_ZONE2=$(echo "${AVAILABILITY_ZONES}" | awk '{ print $2 }') 
      AVAILABILITY_ZONE3=$(echo "${AVAILABILITY_ZONES}" | awk '{ print $3 }') 

      echo "Verify $cloud configuration:"
      messagePrint " - AWS AccessKey" "$AWS_ACCESS_KEY"
      messagePrint " - AWS SecretKey" "$AWS_SECRET_KEY"
      messagePrint " - AWS Region" "$AWS_REGION"
      messagePrint " - AWS Availabilit Zone" "$AWS_AVAILABILITY_ZONES"
      messagePrint " - DNS Domain Suffix" "$AWS_DNS_SUFFIX"
      messagePrint " - DNS Domain Prefix" "$AWS_DNS_PREFIX"
      messagePrint " - DNS SubDomain" "$AWS_DNS_SUBDOMAIN"
      messagePrint " - OPS Manager AMI" "$AWS_OPS_MANAGER_AMI - $OPSMAN_VERSION"

      # --- TEST ACCESS TO AWS ---
      aws iam get-user > /dev/null 2>&1
      if [ $? -ne 0 ]; then
        echo "ERROR: Accessing AWS failed, please perform aws configure"
        exit
      fi

      echo "Verify $cloud Ops Manager instance"
      $TF output > /dev/null 2>&1; ret=$?
      if [ $ret -eq 0 ]; then 
        OPS_MANAGER_INSTANCE=$($TF output | egrep "^ops_manager_iam_instance_profile_name" | awk '{ print $NF }')
        OPS_MANAGER_DNS=$($TF output | egrep "^ops_manager_dns" | awk '{ print $NF }')
        OPS_MANAGER_PUBLIC_IP=$($TF output | egrep "^ops_manager_public_ip" | awk '{ print $NF }')
        OPS_MANAGER_PRIVATE_IP=$($TF output | egrep "ops_manager_private_ip" | awk '{ print $NF }')
        DNS_SERVERS=$(terraform output | sed -n '/^env_dns_zone_name_servers/,/]/p' | \
          sed -e 1d -e '$d' -e 's/,//g' -e 's/  *//g' -e 's/	//g' | paste -s -d " " - - - -)
        DNS1=$(echo $DNS_SERVERS | awk '{ print $1 }')
        DNS2=$(echo $DNS_SERVERS | awk '{ print $2 }')
        DNS3=$(echo $DNS_SERVERS | awk '{ print $3 }')
        DNS4=$(echo $DNS_SERVERS | awk '{ print $4 }')
      else
        OPS_MANAGER_INSTANCE=$($JQ -r '.modules[].outputs.ops_manager_iam_instance_profile_name.value' $TERRAFORM_TFSTATE | grep -v null)
        OPS_MANAGER_DNS=$($JQ -r '.modules[].outputs.dns.value' $TERRAFORM_TFSTATE | grep -v null)
        OPS_MANAGER_PUBLIC_IP=$($JQ -r '.modules[].outputs.public_ip.value' $TERRAFORM_TFSTATE | grep -v null)
        OPS_MANAGER_PRIVATE_IP=$($JQ -r '.modules[].outputs.ops_manager_private_ip.value' $TERRAFORM_TFSTATE | grep -v null)
        DNS_SERVERS=$($JQ -r '.modules[].outputs.ops_manager_private_ip.value' $TERRAFORM_TFSTATE | grep -v null)

        DNS1=$($JQ -r '.modules[2].outputs.name_servers.value[0]' $TERRAFORM_TFSTATE)
        DNS2=$($JQ -r '.modules[2].outputs.name_servers.value[1]' $TERRAFORM_TFSTATE)
        DNS3=$($JQ -r '.modules[2].outputs.name_servers.value[2]' $TERRAFORM_TFSTATE)
        DNS4=$($JQ -r '.modules[2].outputs.name_servers.value[3]' $TERRAFORM_TFSTATE)
        DNS_SERVERS="${DNS1} ${DNS2} ${DNS3} ${DNS4}"
      fi

      # --- GET AWS INSTANCE ---
      if [ $DEBUG -gt 0 ]; then
        echo "# -------------------------- DEBUGGING START -----------------------------"
        echo "aws ec2 --region $AWS_REGION describe-instances --filters 'Name=tag:Name,Values=${AWS_DNS_PREFIX}-ops-manager'"
        aws ec2 --region $AWS_REGION describe-instances --filters 'Name=tag:Name,Values=${AWS_DNS_PREFIX}-ops-manager'
        echo "# -------------------------- DEBUGGING END -------------------------------"
      fi

      OPS_MANAGER_ID=$($AWSCLI ec2 --region $AWS_REGION describe-instances \
         --filters "Name=tag:Name,Values=${AWS_DNS_PREFIX}-ops-manager" "Name=instance-state-name,Values=running"| \
         $JQ '.Reservations[0].Instances[0].InstanceId' | sed 's/"//g')

      INSTANCE_STATUS=$($AWSCLI ec2 --region $AWS_REGION describe-instance-status --instance-ids $OPS_MANAGER_ID | \
      $JQ '.InstanceStatuses[0].InstanceState.Name' | sed 's/"//g')

      messagePrint " - Ops Manager VM Name" "${AWS_DNS_PREFIX}-ops-manager"
      messagePrint " - Ops Manager Instance" "$OPS_MANAGER_ID - $INSTANCE_STATUS"
      messagePrint " - DNS Servers" "$DNS_SERVERS"
      messagePrint " - Ops Manager DNS Name" "$OPS_MANAGER_DNS"

      # --- DNS PRECHECK ---
      nslookup $OPS_MANAGER_DNS 8.8.8.8 > /dev/null 2>&1; ret=$?

      if [ "${ROUTE53_TOKEN}" != "" -a $ret -ne 0 ]; then 
        # --- CHECK IF ZONE RECORDS ARE AVAILABLE ---
        aws route53 list-hosted-zones-by-name --dns-name $AWS_DNS_SUFFIX --hosted-zone-id $ROUTE53_TOKEN > /dev/null 2>&1
        if [ $? -eq 0 ]; then 
          ROUTE53_STAT="zone managed by route53"
        else
          ROUTE53_STAT="no zone found"
          ROUTE53_ZONEID=""
        fi

        echo "Updating AWS Route53 DNS records:"
        messagePrint " - Validating AWS Route53 ZoneID" "$ROUTE53_TOKEN"
        messagePrint " - Validating AWS Route53 Zone: (${AWS_DNS_SUFFIX})" "$ROUTE53_STAT"
        messagePrint " - Define DNS Record for (${AWS_DNS_SUBDOMAIN})" ""
        sublen=$(echo $AWS_DNS_SUBDOMAIN | wc -c | sed 's/ *//g')

        printf "      %${sublen}s    NS     $DNS1\n" "$AWS_DNS_SUBDOMAIN"
        printf "      %${sublen}s           $DNS2\n" ""
        printf "      %${sublen}s           $DNS3\n" ""
        printf "      %${sublen}s           $DNS4\n" ""

        TMPROUTE53=/tmp/$$_tmp_route53.json
        echo "{"                                                   >  $TMPROUTE53
        echo "  \"Comment\": \"CREATE/DELETE/UPSERT a record \","  >> $TMPROUTE53
        echo "  \"Changes\": [{"                                   >> $TMPROUTE53
        echo "  \"Action\": \"UPSERT\","                           >> $TMPROUTE53
        echo "  \"ResourceRecordSet\": {"                          >> $TMPROUTE53
        echo "    \"Name\": \"${AWS_DNS_SUBDOMAIN}\","             >> $TMPROUTE53
        echo "    \"Type\": \"NS\","                               >> $TMPROUTE53
        echo "    \"TTL\": 300,"                                   >> $TMPROUTE53
        echo "    \"ResourceRecords\": [ "                         >> $TMPROUTE53
        echo "      { \"Value\": \"${DNS1}\" },"                   >> $TMPROUTE53
        echo "      { \"Value\": \"${DNS2}\" },"                   >> $TMPROUTE53
        echo "      { \"Value\": \"${DNS3}\" },"                   >> $TMPROUTE53
        echo "      { \"Value\": \"${DNS4}\" }"                    >> $TMPROUTE53
        echo "    ]"                                               >> $TMPROUTE53
        echo "}}]"                                                 >> $TMPROUTE53
        echo "}"                                                   >> $TMPROUTE53

        # --- GET AWS INSTANCE ---
        if [ $DEBUG -gt 0 ]; then
          echo "# -------------------------- DEBUGGING START -----------------------------"
          cat $TMPROUTE53
          echo "# -------------------------- DEBUGGING END -------------------------------"
        fi
echo "xxxx aws route53 change-resource-record-sets --hosted-zone-id $ROUTE53_TOKEN --change-batch file://${TMPROUTE53}"
        aws route53 change-resource-record-sets --hosted-zone-id $ROUTE53_TOKEN \
            --change-batch file://${TMPROUTE53} > /dev/null 2>&1
        if [ $? -eq 0 ]; then 
          messagePrint " - Updating AWS Route53 Record for (${AWS_DNS_SUBDOMAIN})" "succeeded"
        else
          messagePrint " - Updating AWS Route53 Record for (${AWS_DNS_SUBDOMAIN})" "failed"
          echo "WARNING: Unable to update AWS Route53 record $AWS_DNS_SUBDOMAIN for zone $AWS_DNS_SUFFIX"
          echo "         please try manually"
        fi

        wait_loop 60 "Waiting for DNS records to be pushed"

        # --- AWS CHEKING DNS ---
        echo "Validating OPS Manager DNS records ($OPS_MANAGER_DNS)"
        i=1; ret="failed"; dns_google_stat="failed"
         while [ $i -lt 10 -a ${ret} == "failed" ]; do
          sleep 10
          nslookup $OPS_MANAGER_DNS 8.8.8.8 > /dev/null 2>&1; ret=$?
          if [ $ret -eq 0 ]; then dns_google_stat="successful"; fi
          messagePrint "   Verify DNS lookup Google (8.8.8.8)" "$dns_google_stat"
          let i=i+1
        done

        for n in $DNS_SERVERS; do
          nslookup $OPS_MANAGER_DNS $n > /dev/null 2>&1; ret=$?
          if [ $ret -eq 0 ]; then dns_stat="successful"; else dns_stat="failed"; fi
          messagePrint "   => Verify DNS lookup ($n)" "$dns_stat"
        done

        localdns=$(nslookup localhost | grep Server:  | awk '{ print $2 }')
        i=1; ret="failed"; dns_google_stat="failed"
         while [ $i -lt 30 -a ${ret} == "failed" ]; do
          sleep 10
          nslookup $OPS_MANAGER_DNS > /dev/null 2>&1; ret=$?
          if [ $ret -eq 0 ]; then dns_google_stat="successful"; fi
          messagePrint "   => Verify DNS lookup localhost ($localdns)" "$dns_google_stat"
          let i=i+1
        done

        messagePrint " - Ops Manager Public IP" "$OPS_MANAGER_PUBLIC_IP"
        messagePrint " - Ops Manager Private IP" "$OPS_MANAGER_PRIVATE_IP"

        if [ "${dns_google_stat}" == "failed" ]; then
          messagePrint "   Verify DNS lookup Google (8.8.8.8)" "$dns_stat"
          subdomain=$(echo $OPS_MANAGER_DNS | sed -e 's/\./<1>/' -e 's/^.*<1>//g')
          sublen=$(echo $subdomain | wc -c | sed 's/ *//g')

          echo ""
          echo "ERROR: DNS entry for $OPS_MANAGER_DNS external to AWS seams not to be working."
          echo "       Make sure you add a NS entry for your subdomain $subdomain on your DNS zone"
          echo "       for $AWS_DNS_SUFFIX."
          echo ""
          printf "      %${sublen}s    NS     $DNS1\n" "$subdomain"
          printf "      %${sublen}s           $DNS2\n" ""
          printf "      %${sublen}s           $DNS3\n" ""
          printf "      %${sublen}s           $DNS4\n" ""

          echo ""

          echo "Manager Name can not be resolved through DNS"
          exit 1
        else
          OPS_MANAGER=OPS_MANAGER_DNS
        fi
      fi

#NOT WORKING WITH TWO VM's NOE 'running' and one 'rerminated'
#      if [ "${INSTANCE_STATUS}" != "running" ]; then
#        echo ""
#        echo "ERROR: OpsManager Instance: $OPS_MANAGER_ID is not in status 'running'."
#        echo "       Please manually verify status on AWS Console and start it if necessary"; exit 0
#      fi
    fi

    if [ "${cloud}" == "Azure" -a "${AZURE_CLI_ENABLED}" -eq 1 ]; then
      OPSMAN_CONFIG="ops_Imen_aws.yml"
      AZURE_SUBSCRIPTION=$(egrep "^subscription_id" $TERRAFORM_VARS | sed 's/"//g' | awk '{ print $NF }')
      AZURE_TENNENT=$(egrep "^tenant_id" $TERRAFORM_VARS | sed 's/"//g' | awk '{ print $NF }')
      AZURE_CLIENT=$(egrep "^client_id" $TERRAFORM_VARS | sed 's/"//g' | awk '{ print $NF }')
      AZURE_SECRET=$(egrep "^client_secret" $TERRAFORM_VARS | sed 's/"//g' | awk '{ print $NF }')
      AZURE_DNS_SUFFIX=$(egrep "^dns_suffix" $TERRAFORM_VARS | sed 's/"//g' | awk '{ print $NF }')
      AZURE_DNS_PREFIX=$(egrep "^env_name" $TERRAFORM_VARS | sed 's/"//g' | awk '{ print $NF }')
      AZURE_DNS_SUBDOMAIN="${AZURE_DNS_PREFIX}.${AZURE_DNS_SUFFIX}"
      AZURE_REGION=$(egrep "^location" $TERRAFORM_VARS | sed 's/"//g' | awk '{ print $NF }')
      AZURE_OPS_MANAGER_IMAGE=$(egrep "^ops_manager_image_uri" $TERRAFORM_VARS | sed 's/"//g' | awk '{ print $NF }')
      DNS_SUFFIX=$AZURE_DNS_SUFFIX
      DNS_PREFIX=$AZURE_DNS_PREFIX

      echo "Verify $cloud configuration:"
      messagePrint " - Azure SubscriptionId" "$AZURE_SUBSCRIPTION"
      messagePrint " - Azure TennandId" "$AZURE_TENNENT"
      messagePrint " - Azure ClientId" "$AZURE_CLIENT"
      messagePrint " - Azure ClientSecret" "$AZURE_SECRET"
      messagePrint " - Azure Location" "$AZURE_REGION"
      messagePrint " - DNS Domain Suffix" "$AZURE_DNS_SUFFIX"
      messagePrint " - DNS Domain Prefix" "$AZURE_DNS_PREFIX"
      messagePrint " - DNS SubDomain" "$AZURE_DNS_SUBDOMAIN"
      messagePrint " - OPS Manager Image" "$AZURE_OPS_MANAGER_IMAGE"

      # --- TEST ACCESS TO AWS ---
      az group list > /dev/null 2>&1
      if [ $? -ne 0 ]; then
        echo "ERROR: Accessing Azure failed, please perform aws configure"
        exit
      fi

      echo "Verify $cloud Ops Manager instance"
      $TF output > /dev/null 2>&1; ret=$?
      if [ $ret -eq 0 ]; then 
        OPS_MANAGER_INSTANCE="${AZURE_DNS_PREFIX}-ops-manager-vm"
        OPS_MANAGER_DNS=$($TF output | egrep "^ops_manager_dns" | awk '{ print $NF }')
        OPS_MANAGER_PUBLIC_IP=$($TF output | egrep "^ops_manager_public_ip" | awk '{ print $NF }')
        OPS_MANAGER_PRIVATE_IP=$($TF output | egrep "ops_manager_private_ip" | awk '{ print $NF }')
        DNS_SERVERS=$(terraform output | sed -n '/^env_dns_zone_name_servers/,/]/p' | \
          sed -e 1d -e '$d' -e 's/,//g' -e 's/  *//g' -e 's/    //g' | paste -s -d " " - - - -)
        DNS1=$(echo $DNS_SERVERS | awk '{ print $1 }')
        DNS2=$(echo $DNS_SERVERS | awk '{ print $2 }')
        DNS3=$(echo $DNS_SERVERS | awk '{ print $3 }')
        DNS4=$(echo $DNS_SERVERS | awk '{ print $4 }')
      else
        OPS_MANAGER_INSTANCE="${AZURE_DNS_PREFIX}-ops-manager-vm"
        OPS_MANAGER_DNS=$($JQ -r '.modules[].outputs.ops_manager_dns.value' $TERRAFORM_TFSTATE | grep -v null | sort -u)
        OPS_MANAGER_PUBLIC_IP=$($JQ -r '.modules[].outputs.ops_manager_ip.value' $TERRAFORM_TFSTATE | grep -v null | sort -u)
        OPS_MANAGER_PRIVATE_IP=$($JQ -r '.modules[].outputs.ops_manager_private_ip.value' $TERRAFORM_TFSTATE | \
          grep -v null | sort -u)
        DNS1=$($JQ -r '.modules[].outputs.dns_zone_name_servers.value[0]' $TERRAFORM_TFSTATE | grep -v null)
        DNS2=$($JQ -r '.modules[].outputs.dns_zone_name_servers.value[1]' $TERRAFORM_TFSTATE | grep -v null)
        DNS3=$($JQ -r '.modules[].outputs.dns_zone_name_servers.value[2]' $TERRAFORM_TFSTATE | grep -v null)
        DNS4=$($JQ -r '.modules[].outputs.dns_zone_name_servers.value[3]' $TERRAFORM_TFSTATE | grep -v null)
        DNS_SERVERS="${DNS1} ${DNS2} ${DNS3} ${DNS4}"
      fi

      messagePrint " - Ops Manager VM Name" "${OPS_MANAGER_INSTANCE}"
      messagePrint " - AWS DNS Servers" "$DNS_SERVERS"
      messagePrint " - Ops Manager DNS Name" "$OPS_MANAGER_DNS"

      # --- DNS PRECHECK ---
      nslookup $OPS_MANAGER_DNS 8.8.8.8 > /dev/null 2>&1; ret=$?

      #az vm show --resource-group az --name az-ops-manager-vm

      if [ "${ROUTE53_TOKEN}" != "" -a $ret -ne 0 ]; then
        # --- CHECK IF ZONE RECORDS ARE AVAILABLE ---
        aws route53 list-hosted-zones-by-name --dns-name $AZURE_DNS_SUFFIX --hosted-zone-id $ROUTE53_TOKEN > /dev/null 2>&1
        if [ $? -eq 0 ]; then
          ROUTE53_STAT="zone managed by route53"
#          ROUTE53_ZONEID=$(aws route53 list-hosted-zones-by-name --dns-name $AZURE_DNS_SUFFIX \
#                           --hosted-zone-id $ROUTE53_TOKEN | jq -r '.HostedZoneId')
#
#          i=0
#          ROUTE53_ZONES=$(aws route53 list-hosted-zones-by-name --dns-name pcfsdu.com \
#            --hosted-zone-id Z1X9T7571BMHB5 | egrep  "/hostedzone/" | sed -e 's/"//g' -e 's/,//g' | awk '{ print $NF }')
#
#          for zone in $ROUTE53_ZONES; do
#            aws route53 get-hosted-zone --id "${zone}" > /tmp/$$_route53_zone
#            name=$(jq -r '.HostedZone.Name' /tmp/$$_route53_zone)
#            if [ "${name}" = "${AZURE_DNS_SUBDOMAIN}." ]; then
#              ROUTE53_DNS1=$($(jq -r '.DelegationSet.NameServers.[0]' /tmp/$$_route53_zone))
#            fi
#          done
        else
          ROUTE53_STAT="no zone found"
          ROUTE53_ZONEID=""
        fi

        echo "Updating AWS Route53 DNS records:"
        messagePrint " - Validating AWS Route53 ZoneID" "$ROUTE53_TOKEN"
        messagePrint " - Validating AWS Route53 Zone: (${DNS_SUFFIX})" "$ROUTE53_STAT"
        messagePrint " - Define DNS Record for (${AZURE_DNS_SUBDOMAIN})" ""
        sublen=$(echo $AZURE_DNS_SUBDOMAIN | wc -c | sed 's/ *//g')

        printf "      %${sublen}s    NS     $DNS1\n" "$AZURE_DNS_SUBDOMAIN"
        printf "      %${sublen}s           $DNS2\n" ""
        printf "      %${sublen}s           $DNS3\n" ""
        printf "      %${sublen}s           $DNS4\n" ""

        TMPROUTE53=/tmp/$$_tmp_route53.json
        echo "{"                                                   >  $TMPROUTE53
        echo "  \"Comment\": \"CREATE/DELETE/UPSERT a record \","  >> $TMPROUTE53
        echo "  \"Changes\": [{"                                   >> $TMPROUTE53
        echo "  \"Action\": \"UPSERT\","                           >> $TMPROUTE53
        echo "  \"ResourceRecordSet\": {"                          >> $TMPROUTE53
        echo "    \"Name\": \"${AZURE_DNS_SUBDOMAIN}\","           >> $TMPROUTE53
        echo "    \"Type\": \"NS\","                               >> $TMPROUTE53
        echo "    \"TTL\": 300,"                                   >> $TMPROUTE53
        echo "    \"ResourceRecords\": [ "                         >> $TMPROUTE53
        echo "      { \"Value\": \"${DNS1}\" },"                   >> $TMPROUTE53
        echo "      { \"Value\": \"${DNS2}\" },"                   >> $TMPROUTE53
        echo "      { \"Value\": \"${DNS3}\" },"                   >> $TMPROUTE53
        echo "      { \"Value\": \"${DNS4}\" }"                    >> $TMPROUTE53
        echo "    ]"                                               >> $TMPROUTE53
        echo "}}]"                                                 >> $TMPROUTE53
        echo "}"                                                   >> $TMPROUTE53

        # --- GET AZURE INSTANCE ---
        if [ $DEBUG -gt 0 ]; then
          echo "# -------------------------- DEBUGGING START -----------------------------"
          cat $TMPROUTE53
          echo "# -------------------------- DEBUGGING END -------------------------------"
        fi

        aws route53 change-resource-record-sets --hosted-zone-id $ROUTE53_TOKEN \
            --change-batch file://${TMPROUTE53} > /dev/null 2>&1
        if [ $? -eq 0 ]; then
          messagePrint " - Updating AZURE Route53 Record for (${AZURE_DNS_SUBDOMAIN})" "succeeded"
        else
          messagePrint " - Updating AZURE Route53 Record for (${AZURE_DNS_SUBDOMAIN})" "failed"
          echo "WARNING: Unable to update AWS Route53 record $AWS_DNS_SUBDOMAIN for zone $AWS_DNS_SUFFIX"
          echo "         please try manually"
        fi

        wait_loop 60 "Waiting for DNS records to be pushed"

        # --- AZURE CHEKING DNS ---
        echo "Validating OPS Manager DNS records ($OPS_MANAGER_DNS)"
        i=1; ret="failed"
         while [ $i -lt 10 -a ${ret} == "failed" ]; do
          sleep 10
          nslookup $OPS_MANAGER_DNS 8.8.8.8 > /dev/null 2>&1; ret=$?
          if [ $ret -eq 0 ]; then dns_google_stat="successful"; fi
          messagePrint "   Verify DNS lookup Google (8.8.8.8)" "$dns_google_stat"
          let i=i+1
        done

        for n in $DNS_SERVERS; do
          nslookup $OPS_MANAGER_DNS $n > /dev/null 2>&1; ret=$?
          if [ $ret -eq 0 ]; then dns_stat="successful"; else dns_stat="failed"; fi
          messagePrint "   => Verify DNS lookup ($n)" "$dns_stat"
        done

        messagePrint " - Ops Manager Public IP" "$OPS_MANAGER_PUBLIC_IP"
        messagePrint " - Ops Manager Private IP" "$OPS_MANAGER_PRIVATE_IP"

        if [ "$dns_google_stat" == "failed" ]; then
          messagePrint "   Verify DNS lookup Google (8.8.8.8)" "$dns_stat"
          subdomain=$(echo $OPS_MANAGER_DNS | sed -e 's/\./<1>/' -e 's/^.*<1>//g')
          sublen=$(echo $subdomain | wc -c | sed 's/ *//g')

          echo ""
          echo "ERROR: DNS entry for $OPS_MANAGER_DNS external to AWS seams not to be working."
          echo "       Make sure you add a NS entry for your subdomain $subdomain on your DNS zone"
          echo "       for $AWS_DNS_SUFFIX."
          echo ""
          printf "      %${sublen}s    NS     $DNS1\n" "$subdomain"
          printf "      %${sublen}s           $DNS2\n" ""
          printf "      %${sublen}s           $DNS3\n" ""
          printf "      %${sublen}s           $DNS4\n" ""

          echo ""

          echo "Manager Name can not be resolved through DNS"
          exit 1
        else
          OPS_MANAGER=OPS_MANAGER_DNS
        fi
      fi
    fi
  else
    echo "ERROR: Please chagnge to the CF_TERRAFORM/terraforming-pks or CF_TERRAFORM/terraforming-pks"
    echo "       directory to proceede with the installation"; exit 1
  fi
}

##############################################################################################
######################################## MAIN PROGRAMM #######################################
##############################################################################################

if [ "${PCFCONFIG_BASE}" == "pcfconfig-terraform" ]; then
  if [ "${PIVNET_TOKEN}" == "" -o "${TF_WORKDIR}" == "" -o \
       "${TF_DEPLOYMENT}" == "" -o "${PCF_VERSION}" == "" ]; then
    usage_terraform
    echo ""
    echo "ERROR: $PCFCONFIG_BASE requires the options --pivnet-token <token> --workdir <directory>"
    echo "       --pks-tfvars | --pas-tfvars <terraform.tfvars> --cf-version <version>"
    echo "       --deployment <aws|gcp|azure>"; exit 1
  else
    if [ "${TF_PKS_VARFILE}" == "" -a "${TF_PAS_VARFILE}" == "" ]; then
      echo "ERROR: ether --pks-tfvars or --pas-tfvars needs to be set"; exit 1
    fi
  fi

  if [ "${TF_DIR_MODE}" != "" ]; then
    if [ "${TF_DIR_MODE}" != "delete" -a "${TF_DIR_MODE}" != "preserve" -a "${TF_DIR_MODE}" != "clean" ]; then
      echo "ERROR: --install-mode has arguments (delete or preserve or clean)"; exit 1
    fi
  fi
fi

if [ "${PCFCONFIG_BASE}" == "pcfconfig-opsman" ]; then
  if [ "${USER}" == "" -o "${PASS}" == "" -o "${DCRY}" == "" -o "${DCRY}" == "" ]; then
    usage_opsman
    echo ""
    echo "ERROR: $PCFCONFIG_BASE requires the options -u <admin> -p <admin> --decryption-key) <phrase>"; exit 1
  fi
fi

if [ "${PCFCONFIG_BASE}" == "pcfconfig-pks-setup" ]; then
  if [ "${PKS_ADMIN_USER}" == "" -o "${PKS_ADMIN_PASS}" == "" -o "${PKS_ADMIN_MAIL}" == "" ]; then
    usage_pks_setup
    echo ""
    echo "ERROR: $PCFCONFIG_BASE requires the options --pks-admin-user <user> --pks-admin-pass <pass> --pks-admin-mail <mail>"; exit 1
  fi
fi

if [ "${PCFCONFIG_BASE}" == "pcfconfig-pks" ]; then
  if [ "${USER}" == "" -o "${PASS}" == "" -o "${PIVNET_TOKEN}" == "" -o "${PKS_VERSION}" == "" ]; then
    usage_pks
    echo ""
    echo "ERROR: $PCFCONFIG_BASE requires the options -u <admin> -p <admin> --pivnet-token <token> --pks-version <version>"; exit 1
  fi
fi

JQ=$(which jq)
OM=$(which om)
TF=$(which terraform)

if [ "${PCFCONFIG_BASE}" == "pcfconfig-terraform" ]; then
  #checkOpsMantools
  #checkPKStools
  #checkCloudCLI

#gagadu
#  if [ "${PCF_CLOUD_NAME}" = "aws" ]; then
#    if [ "$TF_WORKDIR/${TF_PREFIX}-${TF_DEPLOYMENT}/" = "aws" ]; then
#    AWS_INSTANCE_ID=$(cat terraform.tfstate | jq -r '.modules[].resources."aws_eip.ops_manager_attached".primary.attributes.instance' | grep -v null) 
#  fi

  OM_LOGIN="--skip-ssl-validation --target ${OPS_MANAGER_URL}"

  # --- DOWNLOAD TERRAFORM ---
  echo "Download Terraform Configuration"
  messagePrint " - Terraform Template Name" "$PCF_DEPLOYMENT_CLOUD Terraform Templates"
  messagePrint " - Terraform Template Version" "$TF_TEMPLATE"
  messagePrint " - Terraform Instalation Directory" "$TF_WORKDIR/${TF_PREFIX}-${TF_DEPLOYMENT}"

  if [ "$TF_PKS_VARFILE" != "" -a -f "$TF_PKS_VARFILE" ]; then
    TERRAFORM_VARS_ORIG=$TF_PKS_VARFILE
  else
    TERRAFORM_VARS_ORIG=$TF_PAS_VARFILE
  fi

  # --- CHECK OPSMANAGER VERSION ---
  #opsman=$(egrep "^(ops_manager_image_uri|ops_manager_ami|opsman_image_url)" $TERRAFORM_VARS_ORIG | \
  #         awk '{ print $NF }' | sed 's/"//g')
  region=$(egrep "^(region|location)" $TERRAFORM_VARS_ORIG | awk '{ print $NF }' | sed 's/"//g')

  PCF_REGION=$region

  # --- REGION FIX ---
  if [ "${TF_DEPLOYMENT}" == "gcp" ]; then
    cnt=$(echo "$region" | grep -c "europe")
    if [ $cnt -gt 0 ]; then PCF_REGION="eu"; fi
    cnt=$(echo "$region" | grep -c "asia")
    if [ $cnt -gt 0 ]; then PCF_REGION="asia"; fi
    cnt=$(echo "$region" | egrep -c "northamerica|us")
    if [ $cnt -gt 0 ]; then PCF_REGION="us"; fi
  fi

  # --- HACK FOR PIVOTAL NAMES THE AZURE LOCATIONS DIFFEREN ---
  if [ "${TF_DEPLOYMENT}" == "azure" ]; then
    case $region in
      eastus) PCF_REGION="east_us";;
      westus) PCF_REGION="west_us";;
      westeurope) PCF_REGION="west_europe";;
      southeastasia) PCF_REGION="wsoutheast_asia";;
    esac
  fi

#  if [ "${TF_DEPLOYMENT}" == "azure" ]; then
#    cnt=$(echo "${opsman}" | grep -c "${region}")
#    if [ "${cnt}" -eq 0 ]; then
#      echo "WARNING: OpsManager Image will be downloaded from another location as your currect"
#      echo "         Installation region: ${region}"
#    fi
#  fi

  TF_HOME=$(eval echo "$TF_WORKDIR/${TF_PREFIX}-${TF_DEPLOYMENT}")
#  idx=$(egrep ":${PCF_VERSION}:" ${PCFCONFIG_PATH}/files/terraform-release-notes.txt | \
#        egrep "\-${TF_DEPLOYMENT}-" | head -1 | awk -F: '{ print $1 }')
#  dat=$(egrep ":${PCF_VERSION}:" ${PCFCONFIG_PATH}/files/terraform-release-notes.txt | \
#        egrep "\-${TF_DEPLOYMENT}-" | head -1 | awk -F: '{ print $5 }')

  if [ -d $TF_HOME ]; then
    if [ $NOASK -eq 0 ]; then
      echo ""
      echo "WARNING: `basename $0` is going to overwrite the ${TF_HOME} directory"
      echo "         Be sure you have executed 'terraform destroy' first"
      while [ 1 ]; do
        echo -e "  => Do you want to proceede ? <y/n>: \c"; read x
        if [ "$x" == "y" -o "$x" == "n" ]; then break; fi
      done
  
      # --- EXIT BEFORE SOMETHIN BREAKES ---
      if [ $x == "n" ]; then
        exit 0
      fi
    fi
  fi

  # --- CHECK IF THERE IS AN EXISTING RESSOURCE GROUP ---
  if [ "${TF_DEPLOYMENT}" == "azure" ]; then
    TF_DEPLOYMENT=1
  fi

  if [ -d "${TF_HOME}" ]; then 
    if [ "${TF_DIR_MODE}" != "" ]; then 
      if [ "${TF_DIR_MODE}" == "delete" ]; then 
        rm -rf "${TF_HOME}"
      fi

      if [ "${TF_DIR_MODE}" == "preserve" ]; then 
        PRESERVE=$(date "+%Y%m%d")
        if [ -d ${TF_HOME}-${PRESERVE} ]; then 
          PRESERVE=$(date "+%Y%m%d%M%S")
        fi
        messagePrint " - Preserving old Instalation Directory" "$TF_WORKDIR/${TF_PREFIX}-${TF_DEPLOYMENT}-${PRESERVE}"
        mv "${TF_HOME}" "${TF_HOME}-${PRESERVE}"
      fi

      if [ "${TF_DIR_MODE}" == "clean" ]; then 
        for n in terraforming-pas terraforming-pks; do
          if [ -d ${TF_HOME}/${n} ]; then 
            rm -rf ${TF_HOME}/${n}/.terraform
            rm -f ${TF_HOME}/${n}/terraform.tfstate
            rm -f ${TF_HOME}/${n}/terraform.tfstate.backup
            rm -f ${TF_HOME}/${n}/plan
            rm -f ${TF_HOME}/${n}/outputs.tf
          fi
        done
      fi
    else
      echo "ERROR: Directory $TF_HOME does already exist, remove or rename it first"; exit 1  
    fi
  else
    # Directory does not exist, clean does not help here, change to delete
    TF_DIR_MODE=delete
  fi

  if [ "${TF_DIR_MODE}" != "clean" ]; then 
    PCF_TERRAFORM_TEMPLATE_FILE=$(getTerraformTemplate $PCF_DEPLOYMENT_CLOUD $PCF_OPSMANAGER_BUNDLE $TF_TEMPLATE) 
    PCF_TERRAFORM_DIRNAME=$(zipinfo $PCF_TERRAFORM_TEMPLATE_FILE | grep pivotal-cf-terraforming | head -1 | \
              awk '{ print $NF }' | awk -F'/' '{ print $1 }')

    messagePrint " - Terraform Template File" "$PCF_TERRAFORM_TEMPLATE_FILE"
    messagePrint " - Terraform Package Name" "$PCF_TERRAFORM_DIRNAME"
    if [ "${PCF_TERRAFORM_DIRNAME}" != "" ]; then
      unzip -oq $PCF_TERRAFORM_TEMPLATE_FILE -d /tmp 
      mkdir -p $TF_HOME
      cd /tmp/${PCF_TERRAFORM_DIRNAME}; tar -cf - . | (cd $TF_HOME; tar -xpf -)
    else
      echo "ERROR: can not determain unzip directory from file $PCF_TERRAFORM_TEMPLATE_FILE"; exit 1
    fi
  fi

  # --- PLACE RELEASE INFORMATION IN TERRAFORM DIRECTORY ---  
  echo "terraform_template:$PCF_TERRAFORM_TEMPLATE_FILE" >> $TF_HOME/RELEASE_INFO
  echo "deployment:$TF_DEPLOYMENT"                       >> $TF_HOME/RELEASE_INFO

  # --- VERIFY TERRAFORM FILES ---
  if [ "$TF_PKS_VARFILE" != "" ]; then
    if [ -f "$TF_PKS_VARFILE" ]; then 
      TERRAFORM_VARS=terraform.tfvars
      TERRAFORM_VARS_ORIG=$TF_PKS_VARFILE
      cp $TF_PKS_VARFILE $TF_HOME/terraforming-pks/$TERRAFORM_VARS
      messagePrint " - Placing Terraform Variable file" "$TF_HOME/terraforming-pks/$TERRAFORM_VARS"
    else
      echo "ERROR: Terraform variable file $TF_PKS_VARFILE not found"; exit 1
    fi
  fi

  # --- VERIFY TERRAFORM FILES ---
  if [ "$TF_PAS_VARFILE" != "" ]; then
    if [ -f "$TF_PAS_VARFILE" ]; then   
      TERRAFORM_VARS=terraform.tfvars
      TERRAFORM_VARS_ORIG=$TF_PKS_VARFILE
      cp $TF_PAS_VARFILE $TF_HOME/terraforming-pas/$TERRAFORM_VARS
      messagePrint " - Placing Terraform Variable file" "$TF_HOME/terraforming-pas/$TERRAFORM_VARS"
    else
      echo "ERROR: Terraform variable file $TF_PAS_VARFILE not found"; exit 1
    fi
  fi

  ##############################################################################################
  ########################################## CLEAN-UP ##########################################
  ##############################################################################################

  echo "-----------------------------------------------------------------------------------------------------------"
  if [ "$TF_PKS_VARFILE" != "" -a -f "$TF_PKS_VARFILE" ]; then
    environmentCleanUp $TF_HOME/terraforming-pks
  else
    environmentCleanUp $TF_HOME/terraforming-pas
  fi

  exit 0
fi

# --- CHECK FOR TEMPLATE ---
if [ "${PCFCONFIG_BASE}" == "pcfconfig-opsman" ]; then

  if [ -f ./main.tf ]; then 
    cnt=$(egrep -c "module \"pas\"" ./main.tf) 
    if [ $cnt -eq 1 ]; then 
      OPSMAN_MODE=pas
    else
      OPSMAN_MODE=pks
    fi
  fi

  checkEnvironment

  OPSMAN_TEMPLATE="$(basename $OPSMAN_TEMPLATE)"

  if [ "$OPSMAN_TEMPLATE" != "" ]; then
    if [ ! -f "$PCFCONFIG_PATH/templates/${OPSMAN_TEMPLATE}" ]; then
      echo "ERROR: OpsMan Configuration file $PCFCONFIG_PATH/templates/${OPSMAN_TEMPLATE}"
      echo "       Could not be found"
      exit 1
    else
      OPSMAN_CONFIG="$PCFCONFIG_PATH/templates/${OPSMAN_TEMPLATE}"
    fi
  else
    opsman=$(egrep "^(ops_manager_image_uri|ops_manager_ami|opsman_image_url)" $TERRAFORM_VARS | awk '{ print $NF }' | sed 's/"//g')
    region=$(egrep "^(region|location)" $TERRAFORM_VARS | awk '{ print $NF }' | sed 's/"//g')

    if [ "${PCF_CLOUD_NAME}" = "azure" ]; then
      bld=$(egrep ",${opsman}," $PCFCONFIG_PATH/files/opsman-release-notes.txt | head -1 | awk -F',' '{ print $2 }')
      ver=$(egrep ",${opsman}," $PCFCONFIG_PATH/files/opsman-release-notes.txt | head -1 | awk -F',' '{ print $1 }')
    fi

    if [ "${PCF_CLOUD_NAME}" = "gcp" ]; then
      bld=$(egrep ",${opsman}," $PCFCONFIG_PATH/files/opsman-release-notes.txt | head -1 | awk -F',' '{ print $2 }')
      ver=$(egrep ",${opsman}," $PCFCONFIG_PATH/files/opsman-release-notes.txt | head -1 | awk -F',' '{ print $1 }')
    fi

    if [ "${PCF_CLOUD_NAME}" = "aws" ]; then
      bld=$(egrep ",${opsman}," $PCFCONFIG_PATH/files/opsman-release-notes.txt | head -1 | awk -F',' '{ print $2 }')
      ver=$(egrep ",${opsman}," $PCFCONFIG_PATH/files/opsman-release-notes.txt | head -1 | awk -F',' '{ print $1 }')
    fi

    cnt=$(egrep -c ":${PCF_CLOUD_NAME}:default:${ver}:" $PCFCONFIG_PATH/files/opsman-${OPSMAN_MODE}-release-notes.txt)
    if [ $cnt -eq 0 ]; then
      vermin=$(echo "${ver}" | awk -F'.' '{ printf("%d.%d\n",$1,$2) }') 
      cfg=$(egrep ":${PCF_CLOUD_NAME}:default:${vermin}:" $PCFCONFIG_PATH/files/opsman-${OPSMAN_MODE}-release-notes.txt | \
          head -1 | awk -F: '{ print $(NF-1) }')
    else
      cfg=$(egrep ":${PCF_CLOUD_NAME}:default:${ver}:" $PCFCONFIG_PATH/files/opsman-${OPSMAN_MODE}-release-notes.txt | \
          head -1 | awk -F: '{ print $(NF-1) }')
    fi

    # --- DEFAULT TEMPLATE ---
    if [ "${cfg}" == "" ]; then 
      OPSMAN_TEMPLATE="opsman_${PCF_CLOUD_NAME}_${OPSMAN_MODE}.yml"
      OPSMAN_CONFIG=$PCFCONFIG_PATH/templates/opsman_${PCF_CLOUD_NAME}_${OPSMAN_MODE}.yml
      bn=$(basename $OPSMAN_TEMPLATE)
    else
      OPSMAN_CONFIG="$PCFCONFIG_PATH/templates/${cfg}"
      bn="${cfg}"
    fi
  fi

  # --- VALIDATE OPSMAN-TEMPLATE ---
  cnt=$(egrep -c "director_configuration:" $OPSMAN_CONFIG)

  if [ ${cnt} -eq 0 ]; then
    echo "ERROR: $OPSMAN_CONFIG is not a valid OpsManager configuration file"; exit 1
  fi

  # --- COLLECT METADATA ---
  cnt=$(egrep -c "director_configuration:" $OPSMAN_CONFIG)
  if [ ${cnt} -eq 0 ]; then
    echo "ERROR: $OPSMAN_CONFIG is not a valid BOSH Director configuration file"
    exit 1
  fi

  # --- COPY JQ FILES FROM THE TEMPLATES ---
  JQ_FILTER=$PCFCONFIG_PATH/filter/opsman_${PCF_CLOUD_NAME}_${OPSMAN_MODE}.jq

  if [ ! -f $JQ_FILTER ]; then 
    echo "ERROR: Filter JQ Script: $JQ_FILTER does not exist"; exit 1
  fi

  # --- GET AWS INSTANCE ---
  if [ $DEBUG -gt 0 ]; then
    echo "# -------------------------- DEBUGGING START -----------------------------"
    $JQ -e -f $JQ_FILTER $TERRAFORM_TFSTATE | sed -e 's/^"//g' -e 's/"$//g' -e 's/<1>/"/g' -e '/: $/d' -e '/""/d' | sort -u
    echo "# -------------------------- DEBUGGING END -------------------------------"
  fi

  VARFILE=./opsman_vars.yml
  echo "# GENERATED BY $0 - $(date)" > $VARFILE
  if [ "${PCF_CLOUD_NAME}" = "gcp" ]; then
    cid_inf=$($JQ -r '.modules[].outputs.infrastructure_subnet_cidr.value' $TERRAFORM_TFSTATE | \
            sed -e '/: $/d' | grep -v null | sort -u | sed -e 's/\// /g' -e 's/\./ /g')
    rng_inf=$(echo "$cid_inf" | awk '{ printf("%d.%d.%d.%d-%d.%d.%d.%s\n",$1,$2,$3,$4,$1,$2,$3,$4+4)}')
#    cid_pks=$($JQ -r '.modules[].outputs.pks_subnet_cidr.value' $TERRAFORM_TFSTATE | \
#            sed -e '/: $/d' | grep -v null | sort -u | sed -e 's/\// /g' -e 's/\./ /g')
#    rng_pks=$(echo "$cid_pks" | awk '{ printf("%d.%d.%d.%d-%d.%d.%d.%s\n",$1,$2,$3,$4,$1,$2,$3,$4+4)}')
    cid_svc=$($JQ -r '.modules[].outputs.services_subnet_cidr.value' $TERRAFORM_TFSTATE | \
            sed -e '/: $/d' | grep -v null | sort -u | sed -e 's/\// /g' -e 's/\./ /g')
    rng_svc=$(echo "$cid_svc" | awk '{ printf("%d.%d.%d.%d-%d.%d.%d.%s\n",$1,$2,$3,$4,$1,$2,$3,$4+4)}')


    if [ "${OPSMAN_MODE}" == "pks" ]; then
      cid_pks=$($JQ -r '.modules[].outputs.pks_subnet_cidr.value' $TERRAFORM_TFSTATE | \
              sed -e '/: $/d' | grep -v null | sort -u | sed -e 's/\// /g' -e 's/\./ /g')
      rng_pks=$(echo "$cid_pks" | awk '{ printf("%d.%d.%d.%d-%d.%d.%d.%s\n",$1,$2,$3,$4,$1,$2,$3,$4+4)}')
      echo "pks_subnet_range: ${rng_pks}"                 >> $VARFILE
    else
      cid_pas=$($JQ -r '.modules[].outputs.pas_subnet_cidr.value' $TERRAFORM_TFSTATE | \
              sed -e '/: $/d' | grep -v null | sort -u | sed -e 's/\// /g' -e 's/\./ /g')
      rng_pas=$(echo "$cid_pas" | awk '{ printf("%d.%d.%d.%d-%d.%d.%d.%s\n",$1,$2,$3,$4,$1,$2,$3,$4+4)}')
      echo "pas_subnet_range: ${rng_pas}"               >> $VARFILE
    fi

#gagaduseli

    echo "infrastructure_subnet_range: ${rng_inf}"      >> $VARFILE
    echo "pks_subnet_range: ${rng_pks}"                 >> $VARFILE
    echo "services_subnet_range: ${rng_svc}"            >> $VARFILE

    # HANDLED NY THE FILTER SCRIPT
    #echo "project: $GCP_SVC_PRJID"                     >> $VARFILE
    echo "default_deployment_tag: $DNS_PREFIX"          >> $VARFILE
    echo "region: ${GCP_REGION}"                        >> $VARFILE
    
    sed -n '/SERVICE_ACCOUNT_KEY/,/SERVICE_ACCOUNT_KEY/p' terraform.tfvars | sed -e '1d' -e '$d' | \
    jq 'tostring' | sed 's/^/pcfconfig_service_account: /g' >> $VARFILE

    sva=$(sed -n '/SERVICE_ACCOUNT_KEY/,/SERVICE_ACCOUNT_KEY/p' terraform.tfvars | sed -e '1d' -e '$d')
    cem=$(echo $sva | jq -r '.client_email')
    echo "associated_service_account: ${cem}" >> $VARFILE
  fi

  if [ "${PCF_CLOUD_NAME}" = "aws" ]; then
    echo "access_key_id: $AWS_ACCESS_KEY"               >> $VARFILE
    echo "secret_access_key: $AWS_SECRET_KEY"           >> $VARFILE
    echo "aws-region: ${AWS_REGION}" >> $VARFILE
  fi

  if [ "${PCF_CLOUD_NAME}" = "azure" ]; then
    cid_inf=$($JQ -r '.modules[].outputs.infrastructure_subnet_cidr.value' $TERRAFORM_TFSTATE | \
            sed -e '/: $/d' | grep -v null | sort -u | sed -e 's/\// /g' -e 's/\./ /g')
    rng_inf=$(echo "$cid_inf" | awk '{ printf("%d.%d.%d.%d-%d.%d.%d.%s\n",$1,$2,$3,$4,$1,$2,$3,$4+4)}')
    cid_svc=$($JQ -r '.modules[].outputs.services_subnet_cidr.value' $TERRAFORM_TFSTATE | \
            sed -e '/: $/d' | grep -v null | sort -u | sed -e 's/\// /g' -e 's/\./ /g')
    rng_svc=$(echo "$cid_svc" | awk '{ printf("%d.%d.%d.%d-%d.%d.%d.%s\n",$1,$2,$3,$4,$1,$2,$3,$4+4)}')

    if [ "${OPSMAN_MODE}" == "pks" ]; then
      cid_pks=$($JQ -r '.modules[].outputs.pks_subnet_cidr.value' $TERRAFORM_TFSTATE | \
              sed -e '/: $/d' | grep -v null | sort -u | sed -e 's/\// /g' -e 's/\./ /g')
      rng_pks=$(echo "$cid_pks" | awk '{ printf("%d.%d.%d.%d-%d.%d.%d.%s\n",$1,$2,$3,$4,$1,$2,$3,$4+4)}')
      echo "pks_subnet_range: ${rng_pks}"                 >> $VARFILE
    else
      cid_pas=$($JQ -r '.modules[].outputs.pas_subnet_cidr.value' $TERRAFORM_TFSTATE | \
              sed -e '/: $/d' | grep -v null | sort -u | sed -e 's/\// /g' -e 's/\./ /g')
      rng_pas=$(echo "$cid_pas" | awk '{ printf("%d.%d.%d.%d-%d.%d.%d.%s\n",$1,$2,$3,$4,$1,$2,$3,$4+4)}')
      echo "pas_subnet_range: ${rng_pas}"               >> $VARFILE
    fi

    echo "infrastructure_subnet_range: ${rng_inf}"      >> $VARFILE
    echo "services_subnet_range: ${rng_svc}"            >> $VARFILE

    echo "subscription_id: $AZURE_SUBSCRIPTION"         >> $VARFILE
    echo "tenant_id: $AZURE_TENNENT"                    >> $VARFILE
    echo "client_id: $AZURE_CLIENT"                     >> $VARFILE
    echo "client_secret: $AZURE_SECRET"                 >> $VARFILE
  fi

  # --- ADD TRUSTED CERTIFICATES ---
  CA=$(awk 'NF {sub(/\r/, ""); printf "%s\\n",$0;}' $HOME/pcfconfig/certificates/ca.pem)
  echo "trusted_certificates: \"$CA\"" >> $VARFILE

  #$JQ -e -f $JQ_FILTER $TERRAFORM_TFSTATE | sed -e 's/^"//g' -e 's/"$//g' -e 's/<1>/"/g' >> $VARFILE
  $JQ -e -f $JQ_FILTER $TERRAFORM_TFSTATE | sed -e 's/^"//g' -e 's/"$//g' -e 's/<1>/"/g' -e '/: $/d' -e '/""/d' | \
      sort -u >> $VARFILE
echo "xxxxxxx JQ_FILTER:$JQ_FILTER"

  # --- CONFIGURE AUTHENTICFICATION ---
  echo "Configure OpsManager Authentification"
  messagePrint " - OpsManager URL" "http://$OPS_MANAGER_DNS"
  messagePrint " - OpsManager Admin User" "$USER"
  messagePrint " - OpsManager Admin Password" "$PASS"
  messagePrint " - OpsManager Decryption Passphrase" "$PASS"

  OPS_MANAGER_URL=https://${OPS_MANAGER_DNS}/setup
  OM_LOGIN="--skip-ssl-validation --target ${OPS_MANAGER_URL}"

  echo "-----------------------------------------------------------------------------------------------------------"
  while [ 1 ]; do
    $OM $OM_LOGIN configure-authentication --username $USER --password $PASS --decryption-passphrase $PASS; ret=$?
    if [ $ret -ne 0 ]; then 
      echo "ERROR: OpsManager configure-authentication failled, try again in 60sec"
      sleep 60
    else
      break
    fi
  done
  echo "-----------------------------------------------------------------------------------------------------------"

  # --- CONFIGURE AUTHENTICFICATION ---
  echo "Configure OpsManager Parameters"
  messagePrint " - OpsManager URL" "http://$OPS_MANAGER_DNS"
  messagePrint " - OpsManager Template" "$OPSMAN_CONFIG"
  messagePrint " - OpsManager Variable File" "$VARFILE"

  # --- DO FIRST ONLY IAAS-CONFIGURATION (TWO-STEPS-REQUIRED) --
  OM_LOGIN="--skip-ssl-validation --target ${OPS_MANAGER_URL} --username $USER --password $PASS"
  sed -n '1,/^#END-STAGE-1/p' $OPSMAN_CONFIG | sed '$d' > /tmp/$$_tmpcfg.yml

  pending=$($OM $OM_LOGIN pending-changes | grep "p-bosh" | awk '{ print $4 }')
  if [ "${pending}" != "unchanged" -a "${pending}" != "install" ]; then
    echo "WARNING: Your have pending changes '${pending}' for the OpsManager:"
    $OM $OM_LOGIN pending-changes

    echo ""
    echo "Applying Changes to OpsManager"
    if [ $DEBUG -gt 0 ]; then
      echo "-----------------------------------------------------------------------------------------------------------"
      $OM $OM_LOGIN apply-changes
      if [ $? -ne 0 ]; then 
        echo "ERROR: OpsManager apply changes failed, please try again"; exit 1
      fi
      echo "-----------------------------------------------------------------------------------------------------------"
    else
      $OM $OM_LOGIN apply-changes > /dev/null 2>&1
      if [ $? -ne 0 ]; then 
        echo "ERROR: OpsManager apply changes failed, please try again"; exit 1
      fi
    fi
  else
    echo "--------------------------------- CONFIGURING OPSMANAGER STAGE-1 ------------------------------------------"
    $OM $OM_LOGIN configure-director --ignore-verifier-warnings --config /tmp/$$_tmpcfg.yml --vars-file $VARFILE
    #$OM $OM_LOGIN configure-director --config /tmp/$$_tmpcfg.yml --vars-file $VARFILE
    if [ $? -ne 0 ]; then 
      echo "ERROR: OpsManager configure-direcotr failed, please try again"; exit 1
    fi

    echo "--------------------------------- CONFIGURING OPSMANAGER STAGE-2 ------------------------------------------"
echo "$OM $OM_LOGIN configure-director --ignore-verifier-warnings --config $OPSMAN_CONFIG --vars-file $VARFILE"
    $OM $OM_LOGIN configure-director --ignore-verifier-warnings --config $OPSMAN_CONFIG --vars-file $VARFILE; ret=$?
    #$OM $OM_LOGIN configure-director --config $OPSMAN_CONFIG --vars-file $VARFILE; ret=$?
    if [ $? -ne 0 ]; then 
      echo "ERROR: OpsManager configure-direcotr failed, please try again"; exit 1
    fi
    echo "-----------------------------------------------------------------------------------------------------------"

    # --- CLEANUP ---
    rm -f /tmp/$$_tmpcfg.yml

    if [ $ret -ne 0 ]; then
      echo "ERROR: Updating OpsManager via API failed"; exit 1
    fi

#ppppppppppp
    if [ "${PCF_CLOUD_NAME}" = "aws" ]; then
      messagePrint "Configure Security Groups" ""
      messagePrint "Security Group:" "web-lb-security-groups"

      $OM $OM_LOGIN -k create-vm-extension --name "web-lb-security-groups" \
        --cloud-properties '{ "security_groups": ["web_lb_security_group", "vms_security_group"], "target_groups":["web-lb-target-groups"] }' > /dev/null 2>&1

      messagePrint "Security Group:" "ssh-lb-security-groups"
      $OM $OM_LOGIN -k create-vm-extension --name "ssh-lb-security-groups" \
        --cloud-properties '{ "security_groups": ["ssh_lb_security_group", "vms_security_group"], "target_groups":["ssh-lb-target-groups"] }' > /dev/null 2>&1

      messagePrint "Security Group:" "tcp-lb-security-groups"
      $OM $OM_LOGIN -k create-vm-extension --name "tcp-lb-security-groups" \
        --cloud-properties '{ "security_groups": ["tcp_lb_security_group", "vms_security_group"], "target_groups":["tcp-lb-target-groups"] }' > /dev/null 2>&1
    fi

    if [ $NO_APPLY -eq 0 ]; then
      echo "Applying Changes to OpsManager"
      i=1; ret=1; 
      while [ $i -le 3 -a $ret -ne 0 ]; do
        if [ $DEBUG -gt 0 ]; then
          $OM $OM_LOGIN apply-changes; ret=$?
        else
          $OM $OM_LOGIN apply-changes > /dev/null 2>&1; ret=$?
        fi
  
        let i=i+1
      done

      if [ $ret -ne 0 ]; then 
        echo "ERROR: Applying Changes failed, try manual"
        echo "       => $OM $OM_LOGIN apply-changes "
        exit 1
      fi
    fi
  fi

  echo ""
  echo "Configuration of the OpsManager completed. You may proceede with pcfconfig-pks / pcfconfig-pas"
  exit 0
fi

if [ "${PCFCONFIG_BASE}" == "pcfconfig-pks" -o "${PCFCONFIG_BASE}" == "pcfconfig-pas" ]; then
  checkEnvironment

  OPS_MANAGER_URL=https://${OPS_MANAGER_DNS}/setup
  OM_LOGIN="--skip-ssl-validation --target ${OPS_MANAGER_URL} --username $USER --password $PASS"

#  pending=$($OM $OM_LOGIN pending-changes | grep "p-bosh" | awk '{ print $4 }')
#  if [ "${pending}" != "unchanged" ]; then
#     echo "WARNING: Your have pending changes '${pending}' for the OpsManager:"
#     $OM $OM_LOGIN pending-changes
#     echo "Please run 'Apply Changes' in the OpsManager Web Interface or run pcfconfig-opsman"
#     echo "without the -noapply option"; exit 0
#  fi

  if [ "${PCF_CLOUD_NAME}" = "gcp" ]; then
    GCP_INSTANCE_OPSMAN=$(gcloud compute instances list --filter="name:${GCP_DNS_SUFFIX}-ops-manager" 2>/dev/null | \
       grep -v "NAME" | awk '{ print $NF }')
    GCP_INSTANCE_BOSH0=$(gcloud compute instances list --filter="labels:bosh-0" 2>/dev/null | \
       grep -v "NAME" | awk '{ print $1 }')
    GCP_BOSH0_INSTANCE_STATE=$(gcloud compute instances list --filter="labels:bosh-0" 2>/dev/null | \
       grep -v "NAME" | awk '{ print $NF }')
    GCP_BOSH0_INSTANCE_ZONE=$(gcloud compute instances list --filter="labels:bosh-0" 2>/dev/null | \
       grep -v "NAME" | awk '{ print $2 }')

    echo "Verify Bosh/0 Instance"
    messagePrint " - BOSH Director (Bosh/0) InstanceID" "$GCP_INSTANCE_BOSH0"
    messagePrint " - BOSH Director (Bosh/0) Zone" "$GCP_BOSH0_INSTANCE_ZONE"
    messagePrint " - BOSH Director (Bosh/0) Instance State" "$GCP_BOSH0_INSTANCE_STATE"
  fi

  if [ "${PCF_CLOUD_NAME}" = "aws" ]; then
    AWS_INSTANCE_OPSMAN=$(aws ec2 --region $AWS_REGION  describe-instances \
       --query 'Reservations[].Instances[].{id: InstanceId, tagvalue: Tags[*][?Key==`Name`].Value}' \
       --filters "Name=tag:Name,Values=${AWS_DNS_PREFIX}-ops-manager" --output text)
    AWS_INSTANCE_BOSH0=$(aws ec2 --region $AWS_REGION  describe-instances \
       --query 'Reservations[].Instances[].{id: InstanceId, tagvalue: Tags[*][?Key==`Name`].Value}' \
       --filters "Name=tag:Name,Values=bosh/0" --output text)

    AWS_BOSH0_INSTANCE_STATE=$(aws ec2 --region $AWS_REGION describe-instance-status --instance-ids $AWS_INSTANCE_BOSH0 | \
      jq -r '.InstanceStatuses[0].InstanceState.Name')
    AWS_BOSH0_SYSTEM_STATUS=$(aws ec2 --region $AWS_REGION describe-instance-status --instance-ids $AWS_INSTANCE_BOSH0 | \
      jq -r '.InstanceStatuses[0].SystemStatus.Details[0].Status')
    AWS_BOSH0_INSTANCE_STATUS=$(aws ec2 --region $AWS_REGION describe-instance-status --instance-ids $AWS_INSTANCE_BOSH0 | \
      jq -r '.InstanceStatuses[0].InstanceStatus.Details[0].Status')

    echo "Verify Bosh/0 Instance"
    messagePrint " - BOSH Director (Bosh/0) InstanceID" "$AWS_INSTANCE_BOSH0"
    messagePrint " - BOSH Director (Bosh/0) Instance State" "$AWS_BOSH0_INSTANCE_STATE"
    messagePrint " - BOSH Director (Bosh/0) Instance Status" "$AWS_BOSH0_INSTANCE_STATUS"
    messagePrint " - BOSH Director (Bosh/0) System Status" "$AWS_BOSH0_SYSTEM_STATUS"
  fi

  # --- USE OPS-MANAGER AS JUMPHOST ---
  if [ $OPS_UPLOAD -eq 1 ]; then 
    TMP_OPSMAN=/tmp/opsman.pem; TMP_OPSMAN_PUB=/tmp/opsman.pub; TMP_SCRIPT=/tmp/opsman.sh; rm -f $TMP_OPSMAN
    $JQ -r '.modules[].outputs.ssh_private_key.value' $TERRAFORM_TFSTATE | grep -v null >> $TMP_OPSMAN
    $JQ -r '.modules[].outputs.ops_manager_ssh_private_key.value' $TERRAFORM_TFSTATE | grep -v null >> $TMP_OPSMAN
    touch $TMP_SCRIPT
    [ "$TMP_OPSMAN" != "" ] && chmod 600 $TMP_OPSMAN
    [ "$TMP_SCRIPT" != "" ] && chmod 777 $TMP_SCRIPT

    echo "#!/bin/bash"                                                                                                                 >  $TMP_SCRIPT
    echo "wget -q -O - https://raw.githubusercontent.com/starkandwayne/homebrew-cf/master/public.key | apt-key add - > /dev/null 2>&1" >> $TMP_SCRIPT
    echo "echo "deb http://apt.starkandwayne.com stable main" > /etc/apt/sources.list.d/starkandwayne.list"                            >> $TMP_SCRIPT
    echo "apt-get -qq update > /dev/null 2>&1"                                                                                         >> $TMP_SCRIPT
    echo "apt-get -qq install om > /dev/null 2>&1"                                                                                     >> $TMP_SCRIPT

    # --- CLEANUP OLD ENTRIES FROM KNOWN_HOSTS FILE ---
    if [ -f ~/.ssh/known_hosts ]; then 
      ssh-keygen -f "$HOME/.ssh/known_hosts" -R $OPS_MANAGER_DNS  > /dev/null 2>&1
    fi

#xxxxxxx
    scp -o StrictHostKeyChecking=no -qi $TMP_OPSMAN $TMP_SCRIPT ubuntu@${OPS_MANAGER_DNS}:/tmp/om-install.sh; ret=$?
    if [ ${ret} -ne 0 ]; then 
      echo "ERROR: Copying script /tmp/om-install.sh to ubuntu@${OPS_MANAGER_DNS} has been failed"
      echo "       Please try manually:"
      echo "       => scp -o StrictHostKeyChecking=no -i $TMP_OPSMAN $TMP_SCRIPT ubuntu@${OPS_MANAGER_DNS}:/tmp/om-install.sh"
      exit 1
    fi

    ssh -qi $TMP_OPSMAN ubuntu@${OPS_MANAGER_DNS} -n "sudo /tmp/om-install.sh"; ret=$?
    if [ ${ret} -ne 0 ]; then 
      echo "ERROR: executing remote-script: /tmp/om-install.sh on ubuntu@${OPS_MANAGER_DNS} has been failed"
      echo "       Please try manually:"
      echo "       => ssh -i $TMP_OPSMAN ubuntu@${OPS_MANAGER_DNS} -n \"sudo /tmp/om-install.sh\""
      exit 1
    fi
  fi

  if [ "${PCFCONFIG_BASE}" == "pcfconfig-pks" ]; then
#gaga12
    PIVNET_SLUG=pivotal-container-service
    PIVNET_SLUG_NAME="Pivotal Container Service"
    if [ "${PCF_TILE_PKS_VERSION}" == "" ]; then
      PCF_TILE_PKS_VERSION=$(getProductVersion $PCF_TILE_PKS_BUNDLE "$PIVNET_SLUG_NAME" $PIVNET_SLUG)
    fi

#getProductSlug 1.5.0 pivotal-container-service"

    echo "Looking for PKS Product Image ($PCF_TILE_PKS_VERSION)"
    PIVNET_GLOB=$(getProductSlug $PCF_TILE_PKS_VERSION "$PIVNET_SLUG_NAME" $PIVNET_SLUG)
    if [ "${PIVNET_GLOB}" == "" ]; then PIVNET_GLOB="no product file found"; fi

    # --- LOOK ID FILE IS ALREADY DOWNLOADED ---
    messagePrint " - PKS Product Version requested" "$PCF_TILE_PKS_VERSION"
    messagePrint " - PIVNET Product Name" "$PIVNET_SLUG_NAME"
    messagePrint " - PIVNET Product SLUG" "$PIVNET_SLUG"
    messagePrint " - PIVNET Product GLOB" "$PIVNET_GLOB"

    PXS_VERSION=$PKS_VERSION
  else
    if [ "${PCF_CLOUD_NAME}" == "aws" ]; then
      max_instances=$(aws ec2 describe-account-attributes --region $AWS_REGION --attribute-names max-instances | \
          jq -r '.AccountAttributes[0].AttributeValues[0].AttributeValue')
      echo "max_instances:$max_instances"
    fi

    echo "Looking for PAS Product Image ($PAS_VERSION)"
    if [ "$PCF_TILE_PAS_SLUG" == "srt" ]; then
      PIVNET_SLUG=elastic-runtime
      PIVNET_SLUG_SHORT=srt
      PIVNET_SLUG_NAME="Small Footprint PAS"
    else
      PIVNET_SLUG=elastic-runtime
      PIVNET_SLUG_SHORT=cf
      PIVNET_SLUG_NAME="Pivotal Application Service"
    fi

#gaga12
    PIVNET_GLOB=$(getProductSlug $PAS_VERSION "$PIVNET_SLUG_NAME" elastic-runtime)
    if [ "${PIVNET_GLOB}" == "" ]; then PIVNET_GLOB="no product file found"; fi

    # --- LOOK ID FILE IS ALREADY DOWNLOADED ---
    messagePrint " - PAS Product Version requested" "$PAS_VERSION"
    messagePrint " - PIVNET Product Name" "$PIVNET_SLUG_NAME"
    messagePrint " - PIVNET Product SLUG" "$PIVNET_SLUG"
    messagePrint " - PIVNET Product GLOB" "$PIVNET_GLOB"

    PXS_VERSION=$PAS_VERSION
  fi

  # --- VERIFY IF PKS PRODUCT TILE HAS BEEN UPDLOADED ALREADY --- 
  OM_LOGIN="--skip-ssl-validation --target ${OPS_MANAGER_URL} --username $USER --password $PASS"
  OPSMAN_AVAILABLE_PRODUCT=$($OM $OM_LOGIN available-products | grep "$PIVNET_SLUG" | awk '{ print $4 }')

  if [ "$OPSMAN_AVAILABLE_PRODUCT" == "" ]; then 
    if [ $OPS_UPLOAD -eq 0 ]; then 
      if [ -f "/tmp/$PIVNET_GLOB" ]; then
        messagePrint " - Verify download and caching options" "local-cache"
      else
        messagePrint " - Verify download and caching options" "download-from-pivnet"
        echo "-----------------------------------------------------------------------------------------------------------"
        $OM $OM_LOGIN download-product --output-directory=/tmp --pivnet-file-glob $PIVNET_GLOB \
          --pivnet-product-slug $PIVNET_SLUG --pivnet-api-token "${PIVNET_TOKEN}" \
          --product-version "${PXS_VERSION}"; ret=$?
        echo "-----------------------------------------------------------------------------------------------------------"
        if [ $ret -ne 0 ]; then
          echo "ERROR: Download Product $PIVNET_GLOB failed"; exit 1 
        fi
      fi

      echo "Uploading Product Image ($PXS_VERSION)"
      messagePrint " - Product Image" "/tmp/$PIVNET_GLOB"
      ver=$($OM $OM_LOGIN available-products | grep "$PIVNET_SLUG" | awk '{ print $4 }')
      if [ "${ver}" != "" ]; then PXS_UPLOAD="${ver}"; else PXS_UPLOAD="not uploaded"; fi
      messagePrint " - Product Uplodad Status" "$PXS_UPLOAD"
    else
#gaga
      messagePrint " - Verify download and caching options" "ops-manager"
      echo "if [ -f /tmp/$PIVNET_GLOB ]; then"                                                                  >  $TMP_SCRIPT
      echo "  zipinfo /tmp/$PIVNET_GLOB > /dev/null 2>&1"                                                       >> $TMP_SCRIPT
      echo "  if [ \$? -ne 0 ]; then"                                                                           >> $TMP_SCRIPT
      echo "    echo \"validation of /tmp/$PIVNET_GLOB failed\""                                                >> $TMP_SCRIPT
      echo "    rm -f /tmp/$PIVNET_GLOB"                                                                        >> $TMP_SCRIPT
      echo "  fi"                                                                                               >> $TMP_SCRIPT
      echo "fi"                                                                                                 >> $TMP_SCRIPT
      echo ""                                                                                                   >> $TMP_SCRIPT
      echo "if [ ! -f /tmp/$PIVNET_GLOB ]; then"                                                                >> $TMP_SCRIPT
      echo "  while [ 1 ]; do"                                                                                  >> $TMP_SCRIPT
      echo "    om --request-timeout=60 --skip-ssl-validation --target ${OPS_MANAGER_URL} \\"                   >> $TMP_SCRIPT
      echo "       --username $USER --password $PASS \\"                                                      >> $TMP_SCRIPT
      echo "       download-product --output-directory=/tmp --pivnet-file-glob $PIVNET_GLOB \\"                 >> $TMP_SCRIPT
      echo "       --pivnet-product-slug $PIVNET_SLUG --pivnet-api-token '${PIVNET_TOKEN}' \\"                  >> $TMP_SCRIPT
      echo "       --product-version \"${PXS_VERSION}\""                                               >> $TMP_SCRIPT
      echo ""                                                                                                   >> $TMP_SCRIPT
      echo "    if [ \$? -eq 0 ]; then"                                                                         >> $TMP_SCRIPT
      echo "      if [ -f /tmp/$PIVNET_GLOB ]; then"                                                            >> $TMP_SCRIPT
      echo "        zipinfo /tmp/$PIVNET_GLOB > /dev/null 2>&1"                                                 >> $TMP_SCRIPT
      echo "        if [ \$? -eq 0 ]; then break; fi"                                                           >> $TMP_SCRIPT
      echo "      fi"                                                                                           >> $TMP_SCRIPT
      echo "    fi"                                                                                             >> $TMP_SCRIPT
      echo ""                                                                                                   >> $TMP_SCRIPT
      echo "  echo \"download failed, retrying\""                                                               >> $TMP_SCRIPT
      echo "  sleep 10"                                                                                         >> $TMP_SCRIPT
      echo "  done"                                                                                             >> $TMP_SCRIPT
      echo "fi"                                                                                                 >> $TMP_SCRIPT
      echo ""                                                                                                   >> $TMP_SCRIPT
      echo "om --skip-ssl-validation --target ${OPS_MANAGER_URL} --username $USER --password $PASS\\"           >> $TMP_SCRIPT
      echo "   upload-product --product /tmp/$PIVNET_GLOB"                                                      >> $TMP_SCRIPT

      scp -o StrictHostKeyChecking=no -qi $TMP_OPSMAN $TMP_SCRIPT ubuntu@${OPS_MANAGER_DNS}:/tmp/om-install.sh; ret=$?
      if [ ${ret} -ne 0 ]; then
        echo "ERROR: Copying script /tmp/om-install.sh to ubuntu@${OPS_MANAGER_DNS} has been failed"
        echo "       Please try manually:"
        echo "       => scp -o StrictHostKeyChecking=no -i $TMP_OPSMAN $TMP_SCRIPT ubuntu@${OPS_MANAGER_DNS}:/tmp/om-install.sh"
        exit 1
      fi

#uuuuuuuuuuuuuuuuuuuuu
      i=1
      while [ $i -le 3 ]; do 
        echo "-----------------------------------------------------------------------------------------------------------"
        #ssh -qi $TMP_OPSMAN ubuntu@${OPS_MANAGER_DNS} -n "sudo /tmp/om-install.sh"; ret=$?
        SSH_OPTIONS="-o StrictHostKeyChecking=no -o RequestTTY=yes -o ServerAliveInterval=30"
        ssh -q $SSH_OPTIONS -i $TMP_OPSMAN ubuntu@${OPS_MANAGER_DNS} -n "sudo /tmp/om-install.sh"; ret=$?
        if [ ${ret} -eq 0 ]; then break; fi
        if [ ${ret} -ne 0 -a $i -eq 3 ]; then
          echo "ERROR: executing remote-script: /tmp/om-install.sh on ubuntu@${OPS_MANAGER_DNS} has been failed"
          echo "       Please try manually:"
          echo "       => ssh -i $TMP_OPSMAN ubuntu@${OPS_MANAGER_DNS} -n \"sudo /tmp/om-install.sh\""
          exit 1
        fi
        let i=i+1
        sleep 300
      done
      echo "-----------------------------------------------------------------------------------------------------------"
    fi
  fi

  if [ "${PCFCONFIG_BASE}" == "pcfconfig-pas" ]; then
    VARFILE=./pas_vars.yml; rm -rf $VARFILE; touch $VARFILE
    if [ "$PAS_SRT" -eq 1 ]; then PAS_PRODUCT="pas-srt"; else PAS_PRODUCT="pas"; fi

    PAS_TEMPLATE=$PCF_TILE_PAS_CONFIG

    echo "Configuring PAS Tile (${PAS_VERSION})"
    messagePrint " - PAS YAML Configuration Template" "\$PCFCONFIG_PATH/templates/${PCF_TILE_PAS_CONFIG}"

echo "kkkkk TLS_CERTIFICATE:$TLS_CERTIFICATE"
echo "kkkkk TLS_PRIVATE_KEY:$TLS_PRIVATE_KEY"

    if [ "${TLS_CERTIFICATE}" == "" -a "${TLS_PRIVATE_KEY}" == "" ]; then
      TLS_HOST_NAME=*.pas.${DNS_PREFIX}.${DNS_SUFFIX}
      API_HOST_NAME=api.pas.${DNS_PREFIX}.${DNS_SUFFIX}
      TLS_HOST_NAME="*.sys.${DNS_PREFIX}.${DNS_SUFFIX}.,*.apps.${DNS_PREFIX}.${DNS_SUFFIX}.,*.${DNS_SUFFIX}.,${DNS_SUFFIX}.,${DNS_PREFIX}.${DNS_SUFFIX}"
      TLS_HOST_NAME="*.sys.${DNS_PREFIX}.${DNS_SUFFIX},*.apps.${DNS_PREFIX}.${DNS_SUFFIX},*.${DNS_SUFFIX},${DNS_SUFFIX},${DNS_PREFIX}.${DNS_SUFFIX}"

      messagePrint " - Generating Self-Signed TLS Certificate" "${TLS_HOST_NAME}"

      TLS_TEMP_CERT=/tmp/$$_cert
      OM_LOGIN="--skip-ssl-validation --target ${OPS_MANAGER_URL} --username $USER --password $PASS"
      $OM $OM_LOGIN generate-certificate --domains $TLS_HOST_NAME > $TLS_TEMP_CERT
      if [ $? -ne 0 ]; then
        echo "ERROR: Generating Certificate for $TLS_HOST_NAME failed"; exit 1 
      fi

      TLS_CERTIFICATE_STRING=$(jq '.certificate' $TLS_TEMP_CERT)
      TLS_PRIVATE_KEY_STRING=$(jq '.key' $TLS_TEMP_CERT)
      TLS_ROOT_CERT_STRING=$($OM $OM_LOGIN curl --path /api/v0/certificate_authorities| jq '.certificate_authorities[].cert_pem')

      echo "container_service_pas_tls_cert_pem: $TLS_CERTIFICATE_STRING" >> $VARFILE
      echo "container_service_pas_tls_private_key_pem: $TLS_PRIVATE_KEY_STRING" >> $VARFILE
      echo "routing_custom_ca_certificates: $TLS_ROOT_CERT_STRING" >> $VARFILE

      echo "skip_cert_verify: false" >> $VARFILE
      echo "skip_cert_verify: true" >> $VARFILE
    else
#gagapas
      TLS_HOST_NAME=*.pas.${DNS_PREFIX}.${DNS_SUFFIX}
      API_HOST_NAME=api.pas.${DNS_PREFIX}.${DNS_SUFFIX}
      messagePrint " - Verify Customer TLS Certificate for hosts" "${TLS_HOST_NAME}"
      dif=$((openssl x509 -in $TLS_CERTIFICATE -noout -modulus; openssl rsa -in $TLS_PRIVATE_KEY -noout -modulus) | uniq -c | awk '{ print $1 }')
      if [ "$dif" == "" ]; then dif=0; fi
      if [ $dif -ne 2 ]; then 
        echo "ERROR: Certificate modulus of $TLS_CERTIFICATE does not match with the private_key $TLS_PRIVATE_KEY"
        echo "       => openssl x509 -in $TLS_CERTIFICATE -noout -modulus"
        echo "       => openssl rsa -in $TLS_PRIVATE_KEY -noout -modulus"
        exit 1
      fi

      TLS_CERTIFICATE_STRING=$(awk 'NF {sub(/\r/, ""); printf "%s\\n",$0;}' $TLS_CERTIFICATE)
      TLS_PRIVATE_KEY_STRING=$(awk 'NF {sub(/\r/, ""); printf "%s\\n",$0;}' $TLS_PRIVATE_KEY)
      TLS_ROOT_CERT_STRING=$(awk 'NF {sub(/\r/, ""); printf "%s\\n",$0;}' $TLS_ROOT_CERT)

      echo "container_service_pas_tls_cert_pem: \"$TLS_CERTIFICATE_STRING\"" >> $VARFILE
      echo "container_service_pas_tls_private_key_pem: \"$TLS_PRIVATE_KEY_STRING\"" >> $VARFILE
      echo "routing_custom_ca_certificates: \"$TLS_ROOT_CERT_STRING\"" >> $VARFILE
      echo "skip_cert_verify: true" >> $VARFILE
    fi

    if [ "${PCF_CLOUD_NAME}" == "azure" ]; then
      tg1=$($JQ -r '.modules[].outputs.web_lb_name.value' $TERRAFORM_TFSTATE | grep -v null | sort -u)
      tg2=$($JQ -r '.modules[].outputs.diego_ssh_lb_name.value[1]' $TERRAFORM_TFSTATE | grep -v null | sort -u)

      #echo "pas_api_lb: alb:${tg1},alb:${tg2}" >> $VARFILE
      echo "web_lb: ${tg1}" >> $VARFILE
      echo "diego_ssh_lb_name: ${tg2}" >> $VARFILE
      echo "apps_domain: apps.${DNS_PREFIX}.${DNS_SUFFIX}" >> $VARFILE
      echo "system_domain: sys.${DNS_PREFIX}.${DNS_SUFFIX}" >> $VARFILE
      echo "availability_zone_1: $AVAILABILITY_ZONE1" >> $VARFILE
      echo "availability_zone_2: $AVAILABILITY_ZONE2" >> $VARFILE
      echo "availability_zone_3: $AVAILABILITY_ZONE3" >> $VARFILE
    fi

    if [ "${PCF_CLOUD_NAME}" == "aws" ]; then
      tg1=$($JQ -r '.modules[].outputs.web_target_groups.value[0]' $TERRAFORM_TFSTATE | grep -v null | sort -u)
      tg2=$($JQ -r '.modules[].outputs.web_target_groups.value[1]' $TERRAFORM_TFSTATE | grep -v null | sort -u)
      tg3=$($JQ -r '.modules[].outputs.ssh_target_groups.value[0]' $TERRAFORM_TFSTATE | grep -v null | sort -u)
      #PAS FIX-alb LoadBalancer not working
      echo "pas_api_lb: alb:${tg1},alb:${tg2}" >> $VARFILE
      #echo "pas_api_lb: "tcp:elb-api-lb"" >> $VARFILE
      echo "web_target_group_80: alb:${tg1}" >> $VARFILE
      echo "web_target_group_443: alb:${tg2}" >> $VARFILE
      echo "ssh_target_group: alb:${tg3}" >> $VARFILE
      echo "apps_domain: apps.${DNS_PREFIX}.${DNS_SUFFIX}" >> $VARFILE
      echo "system_domain: sys.${DNS_PREFIX}.${DNS_SUFFIX}" >> $VARFILE
      echo "availability_zone_1: $AVAILABILITY_ZONE1" >> $VARFILE
      echo "availability_zone_2: $AVAILABILITY_ZONE2" >> $VARFILE
      echo "availability_zone_3: $AVAILABILITY_ZONE3" >> $VARFILE
    fi

    messagePrint " - OpsManager URL" "http://$OPS_MANAGER_DNS"
    messagePrint " - PAS Variable File" "$VARFILE"

    OPSMAN_STAGED_PRODUCT=$($OM $OM_LOGIN staged-products | grep "cf" | awk '{ print $4 }')
    if [ "${OPSMAN_STAGED_PRODUCT}" == "" ]; then
      wait_loop 10 "Waiting product to be ready to stage"

      # --- CHEKING DNS ---
      i=1; ret=1
       while [ $i -lt 10 -a ${ret} -ne 0 ]; do
        sleep 10
        OPSMAN_AVAILABLE_PRODUCT=$($OM $OM_LOGIN available-products | grep "cf" | awk '{ print $4 }')
        if [ "${OPSMAN_AVAILABLE_PRODUCT}" != "" ]; then ret=0; fi
        let i=i+1
      done

      if [ "${OPSMAN_AVAILABLE_PRODUCT}" != "" ]; then
        echo "Staging PAS Product Tile"
        messagePrint " - Staging PAS Tile:" "$OPSMAN_AVAILABLE_PRODUCT"
        echo "-----------------------------------------------------------------------------------------------------------"
        #$OM $OM_LOGIN stage-product --product-name elastic-runtime --product-version ${OPSMAN_AVAILABLE_PRODUCT}
        $OM $OM_LOGIN stage-product --product-name cf --product-version ${OPSMAN_AVAILABLE_PRODUCT}
        if [ $? -ne 0 ]; then
          echo "ERROR: Staging Product: cf-$TLS_HOST_NAME failed"; exit 1 
        fi
      else
        echo "ERROR: No product to stage found"; exit 0
      fi
    fi

    OPSMAN_STAGED_PRODUCT=$($OM $OM_LOGIN staged-products | grep "cf" | awk '{ print $4 }')
    if [ "${OPSMAN_STAGED_PRODUCT}" == "" ]; then
      echo "ERROR: Product cf could not be staged"; exit 0
    fi

    echo "-----------------------------------------------------------------------------------------------------------"
    $OM $OM_LOGIN configure-product --config $PCFCONFIG_PATH/templates/${PCF_TILE_PAS_CONFIG} --vars-file $VARFILE
    if [ $? -ne 0 ]; then
      echo "ERROR: Configuring Product with"
      echo "       => $OM $OM_LOGIN configure-product --config $PCFCONFIG_PATH/templates/${PCF_TILE_PAS_CONFIG} \\"
      echo "          --vars-file $VARFILE failed"; exit 1 
    fi
    echo "-----------------------------------------------------------------------------------------------------------"

    if [ "${PCF_CLOUD_NAME}" == "aws1" ]; then
      # --- CREATE ELB LOADBALANCER ---
      SUB1=$($JQ -r '.modules[].outputs.public_subnet_ids.value[0]' $TERRAFORM_TFSTATE | grep -v null | sed '/: $/d' | sort -u)
      SUB2=$($JQ -r '.modules[].outputs.public_subnet_ids.value[1]' $TERRAFORM_TFSTATE | grep -v null | sed '/: $/d' | sort -u)
      SUB3=$($JQ -r '.modules[].outputs.public_subnet_ids.value[2]' $TERRAFORM_TFSTATE | grep -v null | sed '/: $/d' | sort -u)
      SECG=$($JQ -r '.modules[].resources."aws_security_group.pks_api_lb_security_group".primary.id' $TERRAFORM_TFSTATE | \
         grep -v null | sed '/: $/d' | sort -u)

      echo "Creating ELB Loadbalancer (elb-api-lb)"
      messagePrint " - Subnet-1:" "$SUB1"
      messagePrint " - Subnet-2:" "$SUB2"
      messagePrint " - Subnet-3:" "$SUB3"
      messagePrint " - Security Group:" "$SECG"

      aws elb --region $AWS_REGION describe-load-balancers --load-balancer-names "elb-api-lb" > /dev/null 2>&1; ret=$?
      if [ ${ret} -gt 0 ]; then
        aws elb create-load-balancer --region $AWS_REGION  --load-balancer-name "elb-api-lb" \
        --listeners "Protocol=TCP,LoadBalancerPort=8443,InstanceProtocol=TCP,InstancePort=8443" \
                    "Protocol=TCP,LoadBalancerPort=9021,InstanceProtocol=TCP,InstancePort=9021" \
        --subnet $SUB1 $SUB2 $SUB3 --security-groups $SECG
      fi

      ELBDNS=$(aws elb --region $AWS_REGION describe-load-balancers --load-balancer-names "elb-api-lb" | \
          $JQ -r '.LoadBalancerDescriptions[0].DNSName')
      messagePrint " - DNS Name:" "$ELBDNS"

      #aws route53 list-hosted-zones-by-name --dns-name aws.pcfsdu.com
      #aws route53 list-resource-record-sets --hosted-zone-id "/hostedzone/Z13IRYE50CCEFL"

      # --- ROUTE53 TOKEN SPECIDIED ---
      if [ "${ROUTE53_TOKEN}" != "" ]; then 
        DNSLB=$(aws elb --region $AWS_REGION describe-load-balancers --load-balancer-names "elb-api-lb" | \
          jq -r '.LoadBalancerDescriptions[0].DNSName')
        DNSLB_ZONEID=$(aws elb --region $AWS_REGION describe-load-balancers --load-balancer-names "elb-api-lb" | \
          jq -r '.LoadBalancerDescriptions[0].CanonicalHostedZoneNameID')

        #aws route53 list-resource-record-sets --hosted-zone-id "/hostedzone/Z13IRYE50CCEFL" --query "ResourceRecordSets[?Name == 'api.pks.aws.pcfsdu.com.']" | jq -r '.[].AliasTarget.HostedZoneId'


        ZONE_ID=$(aws route53 list-hosted-zones-by-name --dns-name ${AWS_DNS_PREFIX}.${AWS_DNS_SUFFIX} | jq -r '.HostedZones[0].Id')
        ZONE_ID_STR=$(echo "${ZONE_ID}" | awk -F'/' '{ print $NF }')
        #RECORD_ID=$(aws route53 list-resource-record-sets --hosted-zone-id "${ZONE_ID}" \
        #    --query "ResourceRecordSets[?Name == '${TLS_HOST_NAME}.']" | jq -r '.[].AliasTarget.HostedZoneId')
        messagePrint " - DNS Zone (${AWS_DNS_PREFIX}.${AWS_DNS_SUFFIX}:" "zone managed by route53"
        messagePrint " - Updating Zone Record:" "$TLS_HOST_NAME" 

        if [ "${ZONE_ID}" != "" ]; then 
          list=$(echo $TLS_HOST_NAME | sed 's/,/ /g')

          for n in $list; do
    cat << EOF | sed -e "s/FQHN/$n/g" -e "s/AAAA/$DNSLB/g" -e "s/ZZID/$ZONEID/g" > /tmp/$$_zone_record
{
            "Comment": "CREATE/DELETE/UPSERT a record ",
            "Changes": [{
            "Action": "UPSERT",
                        "ResourceRecordSet": {
                                    "Name": "FQHN.",
                                    "Type": "A",
                                    "AliasTarget": {
                                                    "HostedZoneId": "ZZID",
                                                    "DNSName": "dualstack.AAAA.",
                                                    "EvaluateTargetHealth": true
                                                }
}}]
}
EOF

            echo "-----------------------------------------------------------------------------------------------------------"
            aws route53 change-resource-record-sets --hosted-zone-id "${ZONE_ID}" --change-batch file:///tmp/$$_zone_record
            echo "-----------------------------------------------------------------------------------------------------------"

            cp /tmp/$$_zone_record /tmp/aws_zone_record
            rm -f /tmp/$$_zone_record
          done
        fi

      fi
#    else
#      echo "INFO: Pleae set an alias in the DNS Record of your domain ${DNS_PREFIX}.${DNS_SUFFIX} in the record"
#      echo "      of the $TLS_HOST_NAME with ALIAS: $DNSLB"
    fi

    # --- GET STEMCEL-VERSION ---
    if [ "${PCF_DEPLOYMENT_CLOUDID}" == "aws" ]; then SLUG_STR="Ubuntu Xenial Stemcell for AWS"; fi
    if [ "${PCF_DEPLOYMENT_CLOUDID}" == "azure" ]; then SLUG_STR="Ubuntu Xenial Stemcell for Azure"; fi
    if [ "${PCF_DEPLOYMENT_CLOUDID}" == "gcp" ]; then SLUG_STR="Ubuntu Xenial Stemcell for Google Cloud Platform"; fi

    STEMCELL_GLOB=$(getProductSlug $PCF_TILE_STEMCELL_VERSION "$SLUG_STR" $PCF_TILE_STEMCELL_TYPE)

#xxxx
    echo "Uploading Stemcell for PAS"
    messagePrint " - Staging Stemcell Version:" "$PCF_TILE_STEMCELL_VERSION"
    messagePrint " - Staging Stemcell Type:" "$PCF_TILE_STEMCELL_TYPE"
    messagePrint " - Staging Stemcell Description:" "$SLUG_STR $PCF_TILE_STEMCELL_VERSION"
    messagePrint " - Staging Stemcell Glob:" "$STEMCELL_GLOB"

    echo "-----------------------------------------------------------------------------------------------------------"
    $OM $OM_LOGIN download-product --output-directory=/tmp --pivnet-product-slug $PCF_TILE_STEMCELL_TYPE \
      --pivnet-file-glob ${STEMCELL_GLOB} --pivnet-api-token  "$PIVNET_TOKEN" --product-version ${PCF_TILE_STEMCELL_VERSION}
    echo "-----------------------------------------------------------------------------------------------------------"
    $OM $OM_LOGIN upload-stemcell --stemcell /tmp/${STEMCELL_GLOB}
    echo "-----------------------------------------------------------------------------------------------------------"

    if [ $NO_APPLY -eq 0 ]; then
      echo ""
      echo "Applying Changes to PAS"
      if [ $DEBUG -gt 0 ]; then
        echo "-----------------------------------------------------------------------------------------------------------"
        $OM $OM_LOGIN --request-timeout=60 apply-changes
        if [ $? -ne 0 ]; then
          echo "ERROR: Applying changes failed"; exit 1 
        fi
        echo "-----------------------------------------------------------------------------------------------------------"
      else
        $OM $OM_LOGIN --request-timeout=60 apply-changes > /dev/null 2>&1
        if [ $? -ne 0 ]; then
          echo "ERROR: Applying changes failed"; exit 1 
        fi
      fi
    fi

    echo ""
    echo "Configuration of the PAS Tile is completed."
    exit 0
  else
    VARFILE=./pks_vars.yml; rm -rf $VARFILE; touch $VARFILE

    # --- COPY JQ FILES FROM THE TEMPLATES ---
    PKS_TEMPLATE=$PCF_TILE_PKS_CONFIG

    echo "Configuring PKS Tile (${PCF_TILE_PKS_CONFIG})"
    messagePrint " - PKS YAML Configuration Template" "\$PCFCONFIG_PATH/templates/${PCF_TILE_PKS_CONFIG}"

    if [ "${TLS_CERTIFICATE}" == "" -a "${TLS_PRIVATE_KEY}" == "" ]; then 
      API_HOST_NAME=api.pks.${DNS_PREFIX}.${DNS_SUFFIX}
      TLS_HOST_NAME=*.pks.${DNS_PREFIX}.${DNS_SUFFIX}
      messagePrint " - Generating Customer TLS Certificate" "${TLS_HOST_NAME}"

      TLS_TEMP_CERT=/tmp/$$_cert
      OM_LOGIN="--skip-ssl-validation --target ${OPS_MANAGER_URL} --username $USER --password $PASS"
      $OM $OM_LOGIN generate-certificate --domains $TLS_HOST_NAME > $TLS_TEMP_CERT
      if [ $? -ne 0 ]; then
        echo "ERROR: Generating Certificate for $TLS_HOST_NAME failed"; exit 1 
      fi

      TLS_CERTIFICATE=$(jq '.certificate' $TLS_TEMP_CERT)
      TLS_PRIVATE_KEY=$(jq '.key' $TLS_TEMP_CERT)

      echo "container_service_pks_tls_cert_pem: $TLS_CERTIFICATE" >> $VARFILE
      echo "container_service_pks_tls_private_key_pem: $TLS_PRIVATE_KEY" >> $VARFILE
    else
#gagapks
      API_HOST_NAME=api.pks.${DNS_PREFIX}.${DNS_SUFFIX}
      TLS_HOST_NAME=*.pks.${DNS_PREFIX}.${DNS_SUFFIX}
      messagePrint " - Verify Customer TLS Certificate for hosts" "${TLS_HOST_NAME}"
      verifyTLScertificate $TLS_CERTIFICATE $TLS_PRIVATE_KEY

      #dif=$((openssl x509 -in $TLS_CERTIFICATE -noout -modulus; openssl rsa -in $TLS_PRIVATE_KEY -noout -modulus) | \
      #    uniq -c | awk '{ print $1 }')
      #if [ "$dif" == "" ]; then dif=0; fi
      #if [ $dif -ne 2 ]; then
      #  echo "ERROR: Certificate modulus of $TLS_CERTIFICATE does not match with the private_key $TLS_PRIVATE_KEY"
      #  echo "       => openssl x509 -in $TLS_CERTIFICATE -noout -modulus"
      #  echo "       => openssl rsa -in $TLS_PRIVATE_KEY -noout -modulus"
      #  exit 1
      #fi

      TLS_CERTIFICATE_STRING=$(awk 'NF {sub(/\r/, ""); printf "%s\\n",$0;}' $TLS_CERTIFICATE)
      TLS_PRIVATE_KEY_STRING=$(awk 'NF {sub(/\r/, ""); printf "%s\\n",$0;}' $TLS_PRIVATE_KEY)
      TLS_ROOT_CERT_STRING=$(awk 'NF {sub(/\r/, ""); printf "%s\\n",$0;}' $TLS_ROOT_CERT)

      echo "container_service_pks_tls_cert_pem: \"$TLS_CERTIFICATE_STRING\"" >> $VARFILE
      echo "container_service_pks_tls_private_key_pem: \"$TLS_PRIVATE_KEY_STRING\"" >> $VARFILE
    fi

    $JQ -r '"pks_api_hostname: " + .modules[].outputs.domain.value' \
    $TERRAFORM_TFSTATE | sed '/: $/d' | sort -u >> $VARFILE
    $JQ -r '"pks_master_iam_instance_profile_name: " + .modules[].outputs.pks_master_iam_instance_profile_name.value' \
    $TERRAFORM_TFSTATE | sed '/: $/d' | sort -u >> $VARFILE
    $JQ -r '"pks_worker_iam_instance_profile_name: " + .modules[].outputs.pks_worker_iam_instance_profile_name.value' \
    $TERRAFORM_TFSTATE | sed '/: $/d' | sort -u >> $VARFILE
 
    if [ "${PCF_CLOUD_NAME}" == "aws" ]; then
      tg1=$($JQ -r '.modules[].outputs.pks_api_target_groups.value[0]' $TERRAFORM_TFSTATE | grep -v null | sort -u)
      tg2=$($JQ -r '.modules[].outputs.pks_api_target_groups.value[1]' $TERRAFORM_TFSTATE | grep -v null | sort -u)
      #PKS FIX-alb LoadBalancer not working
      #echo "pks_api_lb: alb:${tg1},alb:${tg2}" >> $VARFILE
      echo "pks_api_lb: "elb-api-lb"" >> $VARFILE
      echo "availability_zone_1: $AVAILABILITY_ZONE1" >> $VARFILE
      echo "availability_zone_2: $AVAILABILITY_ZONE2" >> $VARFILE
      echo "availability_zone_3: $AVAILABILITY_ZONE3" >> $VARFILE
    fi

    if [ "${PCF_CLOUD_NAME}" == "azure" ]; then
      #echo "pks_api_lb: az-pks-lb" >> $VARFILE
      echo "pks_api_lb: ${DNS_PREFIX}-pks-lb" >> $VARFILE
      #echo "pks_api_hostname: api.pks.az.pcfsdu.com/#@pivotalio.onmicrosoft.com/res" >> $VARFILE
      echo "pks_api_hostname:  api.pks.${DNS_PREFIX}.${DNS_SUFFIX}" >> $VARFILE
      echo "location: $AZURE_REGION" >> $VARFILE
      echo "resource_group_name: $DNS_PREFIX" >> $VARFILE
      $JQ -r '"network_name: " + .modules[].outputs.network_name.value' $TERRAFORM_TFSTATE | \
         sed '/: $/d' | grep -v null | sort -u >> $VARFILE
      $JQ -r '"vms_security_group: " + .modules[].outputs.bosh_deployed_vms_security_group_name.value' $TERRAFORM_TFSTATE | \
         sed '/: $/d' | grep -v null | sort -u >> $VARFILE

      echo "subscription_id: $AZURE_SUBSCRIPTION" >> $VARFILE
      echo "tenant_id: $AZURE_TENNENT" >> $VARFILE
      echo "primary_availability_set: ${DNS_PREFIX}-pks-as" >> $VARFILE

      echo "Verify $cloud configuration:"
      messagePrint " - Azure SubscriptionId" "$AZURE_SUBSCRIPTION"
      messagePrint " - Azure TennandId" "$AZURE_TENNENT"
      messagePrint " - Azure ClientId" "$AZURE_CLIENT"
      messagePrint " - Azure ClientSecret" "$AZURE_SECRET"
      messagePrint " - Azure Location" "$AZURE_REGION"
      messagePrint " - DNS Domain Suffix" "$AZURE_DNS_SUFFIX"
      messagePrint " - DNS Domain Prefix" "$AZURE_DNS_PREFIX"
      messagePrint " - DNS SubDomain" "$AZURE_DNS_SUBDOMAIN"
      messagePrint " - OPS Manager Image" "$AZURE_OPS_MANAGER_IMAGE"
    fi

#ggggg

    if [ "${PCF_CLOUD_NAME}" == "gcp" ]; then
      $JQ -r '"worker_node_service_account: " + .modules[].resources."google_service_account.pks_worker_node_service_account".primary.attributes.email' \
      $TERRAFORM_TFSTATE | sed '/: $/d' | grep -v null | sort -u >> $VARFILE
      $JQ -r '"master_node_service_account: " + .modules[].resources."google_service_account.pks_master_node_service_account".primary.attributes.email' \
      $TERRAFORM_TFSTATE | sed '/: $/d' | grep -v null | sort -u >> $VARFILE

      $JQ -r '"pks_api_hostname: " + .modules[].outputs.pks_api_endpoint.value' $TERRAFORM_TFSTATE | \
          sed '/: $/d' | grep -v null | sort -u >> $VARFILE
      $JQ -r '"network_name: " + .modules[].outputs.network_name.value' $TERRAFORM_TFSTATE | \
          sed '/: $/d' | grep -v null | sort -u >> $VARFILE
      $JQ -r '"pks_api_lb: " + .modules[].outputs.pks_lb_backend_name.value' $TERRAFORM_TFSTATE | \
          sed '/: $/d' | grep -v null | sort -u >> $VARFILE
    
      #echo "pks_api_lb: tcp:pks-api" >> $VARFILE
      echo "zone-1: $AVAILABILITY_ZONE1" >> $VARFILE
      echo "zone-2: $AVAILABILITY_ZONE2" >> $VARFILE
      echo "zone-3: $AVAILABILITY_ZONE3" >> $VARFILE
      echo "master_service_account: $GCP_SVC_NAME" >> $VARFILE
      echo "project: $GCP_SVC_PRJID" >> $VARFILE
    fi

    messagePrint " - OpsManager URL" "http://$OPS_MANAGER_DNS"
    messagePrint " - PKS Variable File" "$VARFILE"

    OPSMAN_STAGED_PRODUCT=$($OM $OM_LOGIN staged-products | grep "pivotal-container-service" | awk '{ print $4 }')
    if [ "${OPSMAN_STAGED_PRODUCT}" == "" ]; then
      wait_loop 10 "Waiting product to be ready to stage"

      # --- CHEKING DNS ---
      i=1; ret=1
       while [ $i -lt 10 -a ${ret} -ne 0 ]; do
        sleep 10
        OPSMAN_AVAILABLE_PRODUCT=$($OM $OM_LOGIN available-products | grep "pivotal-container-service" | awk '{ print $4 }')
        if [ "${OPSMAN_AVAILABLE_PRODUCT}" != "" ]; then ret=0; fi
        let i=i+1
      done

      if [ "${OPSMAN_AVAILABLE_PRODUCT}" != "" ]; then
        echo "Staging PKS Product Tile"
        messagePrint " - Staging PKS Tile:" "$OPSMAN_AVAILABLE_PRODUCT"
        echo "-----------------------------------------------------------------------------------------------------------"
        $OM $OM_LOGIN stage-product --product-name pivotal-container-service --product-version ${OPSMAN_AVAILABLE_PRODUCT}
        if [ $? -ne 0 ]; then 
          echo "ERROR: Staging of pivotal-container-service has been failed, please retry"; exit 1
        fi
      else
        echo "ERROR: No product to stage found"; exit 0
      fi
    fi
  
    OPSMAN_STAGED_PRODUCT=$($OM $OM_LOGIN staged-products | grep "pivotal-container-service" | awk '{ print $4 }')
    if [ "${OPSMAN_STAGED_PRODUCT}" == "" ]; then
      echo "ERROR: Product pivotal-container-service could not be staged"; exit 1
    fi

    echo "-----------------------------------------------------------------------------------------------------------"
echo "$OM $OM_LOGIN configure-product --config $PCFCONFIG_PATH/templates/${PCF_TILE_PKS_CONFIG} --vars-file $VARFILE"
    $OM $OM_LOGIN configure-product --config $PCFCONFIG_PATH/templates/${PCF_TILE_PKS_CONFIG} --vars-file $VARFILE
    if [ $? -ne 0 ]; then 
      echo "ERROR: Configuring PKS tile has been failed, please retry"; exit 1
    fi
    echo "-----------------------------------------------------------------------------------------------------------"

    if [ "${PCF_CLOUD_NAME}" == "aws" ]; then
      # --- CREATE ELB LOADBALANCER ---
      SUB1=$($JQ -r '.modules[].outputs.public_subnet_ids.value[0]' $TERRAFORM_TFSTATE | grep -v null | sed '/: $/d' | sort -u)
      SUB2=$($JQ -r '.modules[].outputs.public_subnet_ids.value[1]' $TERRAFORM_TFSTATE | grep -v null | sed '/: $/d' | sort -u)
      SUB3=$($JQ -r '.modules[].outputs.public_subnet_ids.value[2]' $TERRAFORM_TFSTATE | grep -v null | sed '/: $/d' | sort -u)
      SECG=$($JQ -r '.modules[].resources."aws_security_group.pks_api_lb_security_group".primary.id' $TERRAFORM_TFSTATE | \
         grep -v null | sed '/: $/d' | sort -u)

      echo "Creating ELB Loadbalancer (elb-api-lb)"
      messagePrint " - Subnet-1:" "$SUB1"
      messagePrint " - Subnet-2:" "$SUB2"
      messagePrint " - Subnet-3:" "$SUB3"
      messagePrint " - Security Group:" "$SECG"

#steve
      aws elb --region $AWS_REGION describe-load-balancers --load-balancer-names "elb-api-lb" > /dev/null 2>&1; ret=$?
      if [ ${ret} -gt 0 ]; then
        aws elb create-load-balancer --region $AWS_REGION  --load-balancer-name "elb-api-lb" --tags "Key=Environment,Value=$AWS_DNS_PREFIX" \
        --listeners "Protocol=TCP,LoadBalancerPort=8443,InstanceProtocol=TCP,InstancePort=8443" \
                    "Protocol=TCP,LoadBalancerPort=9021,InstanceProtocol=TCP,InstancePort=9021" \
        --subnet $SUB1 $SUB2 $SUB3 --security-groups $SECG
      fi

      ELBDNS=$(aws elb --region $AWS_REGION describe-load-balancers --load-balancer-names "elb-api-lb" | \
          $JQ -r '.LoadBalancerDescriptions[0].DNSName')
      messagePrint " - DNS Name:" "$ELBDNS"

      #aws route53 list-hosted-zones-by-name --dns-name aws.pcfsdu.com
      #aws route53 list-resource-record-sets --hosted-zone-id "/hostedzone/Z13IRYE50CCEFL"

      # --- ROUTE53 TOKEN SPECIDIED ---
      if [ "${ROUTE53_TOKEN}" != "" ]; then 
        DNSLB=$(aws elb --region $AWS_REGION describe-load-balancers --load-balancer-names "elb-api-lb" | \
          jq -r '.LoadBalancerDescriptions[0].DNSName')
        DNSLB_ZONEID=$(aws elb --region $AWS_REGION describe-load-balancers --load-balancer-names "elb-api-lb" | \
          jq -r '.LoadBalancerDescriptions[0].CanonicalHostedZoneNameID')

        #aws route53 list-resource-record-sets --hosted-zone-id "/hostedzone/Z13IRYE50CCEFL" --query "ResourceRecordSets[?Name == 'api.pks.aws.pcfsdu.com.']" | jq -r '.[].AliasTarget.HostedZoneId'


        ZONE_ID=$(aws route53 list-hosted-zones-by-name --dns-name ${AWS_DNS_PREFIX}.${AWS_DNS_SUFFIX} | jq -r '.HostedZones[0].Id')
        ZONE_ID_STR=$(echo "${ZONE_ID}" | awk -F'/' '{ print $NF }')
        #RECORD_ID=$(aws route53 list-resource-record-sets --hosted-zone-id "${ZONE_ID}" \
        #    --query "ResourceRecordSets[?Name == '${TLS_HOST_NAME}.']" | jq -r '.[].AliasTarget.HostedZoneId')
        messagePrint " - DNS Zone (${AWS_DNS_PREFIX}.${AWS_DNS_SUFFIX}:" "zone managed by route53"
        messagePrint " - 1Updating Zone Record:" "$API_HOST_NAME" 

#pppp
        if [ "${ZONE_ID}" != "" ]; then 
    cat << EOF | sed -e "s/FQHN/$API_HOST_NAME/g" -e "s/AAAA/$DNSLB/g" -e "s/ZZID/$DNSLB_ZONEID/g" > /tmp/$$_zone_record
{
            "Comment": "CREATE/DELETE/UPSERT a record ",
            "Changes": [{
            "Action": "UPSERT",
                        "ResourceRecordSet": {
                                    "Name": "FQHN.",
                                    "Type": "A",
                                    "AliasTarget": {
                                                    "HostedZoneId": "ZZID",
                                                    "DNSName": "dualstack.AAAA.",
                                                    "EvaluateTargetHealth": true
                                                }
}}]
}
EOF

          echo "-----------------------------------------------------------------------------------------------------------"
          aws route53 change-resource-record-sets --hosted-zone-id "${ZONE_ID}" --change-batch file:///tmp/$$_zone_record
          if [ $? -ne 0 ]; then
            echo "ERROR: Updating DNS record"
            echo "       aws route53 change-resource-record-sets --hosted-zone-id \"${ZONE_ID}\" --change-batch file:///tmp/$$_zone_record"
            exit 1
          fi
          echo "-----------------------------------------------------------------------------------------------------------"

          cp /tmp/$$_zone_record /tmp/aws_zone_record
          rm -f /tmp/$$_zone_record
        fi

      fi
#    else
#      echo "INFO: Pleae set an alias in the DNS Record of your domain ${DNS_PREFIX}.${DNS_SUFFIX} in the record"
#      echo "      of the $TLS_HOST_NAME with ALIAS: $DNSLB"
    fi

    # --- GET STEMCEL-VERSION ---
    if [ "${PCF_DEPLOYMENT_CLOUDID}" == "aws" ]; then SLUG_STR="Ubuntu Xenial Stemcell for AWS"; fi
    if [ "${PCF_DEPLOYMENT_CLOUDID}" == "azure" ]; then SLUG_STR="Ubuntu Xenial Stemcell for Azure"; fi
    if [ "${PCF_DEPLOYMENT_CLOUDID}" == "gcp" ]; then SLUG_STR="Ubuntu Xenial Stemcell for Google Cloud Platform"; fi

    STEMCELL_GLOB=$(getProductSlug $PCF_TILE_STEMCELL_VERSION "$SLUG_STR" $PCF_TILE_STEMCELL_TYPE)

    echo "Uploading Stemcell for PKS"
    messagePrint " - Staging Stemcel Version:" "$PCF_TILE_STEMCELL_VERSION"
    messagePrint " - Staging Stemcel Type:" "$PCF_TILE_STEMCELL_TYPE"
    messagePrint " - Staging Stemcel Description:" "$SLUG_STR $PCF_TILE_STEMCELL_VERSION"
    messagePrint " - Staging Stemcel Glob:" "$STEMCELL_GLOB"

    # --- CHECK IF ALREADY THERE ---
    if [ -f /tmp/${scf} ]; then 
      gzip -l /tmp/${scf} > /dev/null 2>&1
      if [ $? -ne 0 ]; then rm -f /tmp/${scf}; fi
    fi
 
    i=0
    if [ ! -f /tmp/${STEMCELL_GLOB} ]; then 
      while [ 1 ]; do
        echo "-----------------------------------------------------------------------------------------------------------"
        $OM $OM_LOGIN --request-timeout=60 download-product --output-directory=/tmp --pivnet-product-slug $PCF_TILE_STEMCELL_TYPE \
                      --pivnet-file-glob ${STEMCELL_GLOB} --pivnet-api-token  "$PIVNET_TOKEN" \
                      --product-version ${PCF_TILE_STEMCELL_VERSION}; ret=$?
        if [ $ret -eq 0 ]; then 
          gzip -l /tmp/${STEMCELL_GLOB} > /dev/null 2>&1
          if [ $? -eq 0 ]; then 
            break
          else
            rm -f /tmp/${STEMCELL_GLOB}
          fi
        fi
          
        if [ $i -ge 3 ]; then
          echo "ERROR: Downloading Product: ${PCF_TILE_STEMCELL_VERSION} failed"; exit 1
        fi
        let i=i+1
      done
    fi

    echo "-----------------------------------------------------------------------------------------------------------"
    $OM $OM_LOGIN upload-stemcell --stemcell /tmp/${STEMCELL_GLOB} 
    echo "-----------------------------------------------------------------------------------------------------------"

    if [ $NO_APPLY -eq 0 ]; then
      echo ""
      echo "Applying Changes to PKS"
      if [ $DEBUG -gt 0 ]; then
        echo "-----------------------------------------------------------------------------------------------------------"
        $OM $OM_LOGIN --request-timeout=60 apply-changes
        echo "-----------------------------------------------------------------------------------------------------------"
      else
        $OM $OM_LOGIN --request-timeout=60 apply-changes > /dev/null 2>&1
        if [ $? -ne 0 ]; then 
          echo "ERROR: Applying Changes has been failed, please try manual"
          echo "       $OM $OM_LOGIN apply-changes"; exit 1
        fi
      fi
    fi

    echo ""
    echo "Configuration of the PKS Tile is completed."
    exit 0
  fi
fi

if [ "${PCFCONFIG_BASE}" == "pcfconfig-pas-setup" ]; then
  checkEnvironment
  OPS_MANAGER_URL=https://${OPS_MANAGER_DNS}/setup
  OM_LOGIN="--skip-ssl-validation --target ${OPS_MANAGER_URL} --username $USER --password $PASS"

  # GET CREDENTIALS
  TMP_JQ=/tmp/$$_jq; TMP_SEC=/tmp/$$_sec;
  $OM $OM_LOGIN curl --path /api/v0/deployed/products > $TMP_JQ 2>/dev/null; ret=$?
  if [ $ret -eq 0 ]; then
    director_ip=$($OM $OM_LOGIN curl --path /api/v0/deployed/director/manifest 2>/dev/null | \
                  jq -r '.instance_groups[].properties.director.address')
    director_cd=$($OM $OM_LOGIN curl --path /api/v0/deployed/director/credentials/uaa_admin_user_credentials 2>/dev/null | \
                  jq -r '.credential.value.password')

    prd="xxx"; i=0
    while [ "${prd}" != "null" ]; do
      prd=$(jq -r ".[$i].type" $TMP_JQ)
      if [ "${prd}" == "cf" ]; then
        inm=$(jq -r ".[$i].installation_name" $TMP_JQ)
        str="/api/v0/deployed/products/${inm}/credentials/.uaa.admin_credentials"
        $OM $OM_LOGIN curl --path ${str} > $TMP_SEC 2>/dev/null; ret=$?
        if [ $ret -eq 0 ]; then
          sec=$(jq -r '.credential.value.password' $TMP_SEC)
        else
          echo "ERROR: 1Can not connect to $OPS_MANAGER_URL"; exit 1
        fi
      fi

      let i=i+1
    done

    rm -f $$TMP_JQ
  else
    echo "ERROR: Can not connect to $OPS_MANAGER_URL"; exit 1
  fi

  TMP_OPSMAN=./opsman.pem; TMP_OPSMAN_PUB=./opsman.pub; TMP_SCRIPT=/tmp/opsman.sh; rm -f $TMP_OPSMAN
  $JQ -r '.modules[].outputs.ssh_private_key.value' $TERRAFORM_TFSTATE | grep -v null >> $TMP_OPSMAN
  $JQ -r '.modules[].outputs.ops_manager_ssh_private_key.value' $TERRAFORM_TFSTATE | grep -v null >> $TMP_OPSMAN
  touch $TMP_SCRIPT
  [ "$TMP_OPSMAN" != "" ] && chmod 600 $TMP_OPSMAN
  [ "$TMP_SCRIPT" != "" ] && chmod 777 $TMP_SCRIPT

  ##############################################################################################
  ######################################## DEBUG INFOS #########################################
  ##############################################################################################
  TMP_LBSCRIPT=/tmp/tmp_lb_script_$$; rm -f $TMP_LBSCRIPT
  echo "cert=/var/tempest/workspaces/default/root_ca_certificate"                                          >  $TMP_LBSCRIPT
  echo "bosh alias-env $DNS_PREFIX -e $director_ip --ca-cert \$cert >/dev/null 2>&1"                       >> $TMP_LBSCRIPT
  echo "echo -e \"admin\n${director_cd}\" | bosh -e $DNS_PREFIX login >/dev/null 2>&1"                     >> $TMP_LBSCRIPT
  echo "bosh -e $DNS_PREFIX vms"                                                                           >> $TMP_LBSCRIPT
  echo "bosh -e $DNS_PREFIX tasks"                                                                         >> $TMP_LBSCRIPT

  scp -o StrictHostKeyChecking=no -qi $TMP_OPSMAN $TMP_LBSCRIPT ubuntu@${OPS_MANAGER_DNS}:/tmp/debug.sh; ret=$?
  if [ ${ret} -ne 0 ]; then
    echo "ERROR: Copying script /tmp/debug.sh to ubuntu@${OPS_MANAGER_DNS} has been failed"
    echo "       Please try manually:"
    echo "       => scp -o StrictHostKeyChecking=no -i $TMP_OPSMAN $TMP_LBSCRIPT ubuntu@${OPS_MANAGER_DNS}:/tmp/debug.sh"
    exit 1
  fi

  # --- CREATE USERS ---
  cf login --skip-ssl-validation -a api.sys.${DNS_PREFIX}.${DNS_SUFFIX} -u admin -p $sec -s system > /dev/null 2>&1
  if [ ${ret} -ne 0 ]; then
    echo "ERROR: failled to login to api.sys.${DNS_PREFIX}.${DNS_SUFFIX}"
    echo "       => cf login --skip-ssl-validation -a api.sys.${DNS_PREFIX}.${DNS_SUFFIX} -u admin -p $sec -s system"
    exit 1
  fi

  # --- CREATE USER ---
  echo "Configuring PCF"

  messagePrint " - Creating Organization:" "pivotal"
  cf create-org pivotal > /dev/null 2>&1; ret=$?
  if [ ${ret} -ne 0 ]; then
    echo "ERROR: failled to create org"
    echo "       => cf create-org pivotal"
    exit 1
  fi

  messagePrint " - Creating Space:" "demo"
  cf create-space -o pivotal demo > /dev/null 2>&1; ret=$?
  if [ ${ret} -ne 0 ]; then
    echo "ERROR: failled to create space"
    echo "       => cf create-space -o pivotal demo"
    exit 1
  fi

  messagePrint " - Creating User:" "$PAS_ADMIN_USER"
  cf create-user $PAS_ADMIN_USER $PAS_ADMIN_PASS > /dev/null 2>&1; ret=$?
  if [ ${ret} -ne 0 ]; then
    echo "ERROR: failled to add user"
    echo "       => cf create-user $PAS_ADMIN_USER $PAS_ADMIN_PASS"
    exit 1
  fi

  messagePrint " - Add User $PAS_ADMIN_USER to Orgs (pivotal) with role" "OrgManager"
  cf set-org-role sadubois pivotal OrgManager > /dev/null 2>&1; ret=$?
  if [ ${ret} -ne 0 ]; then
    echo "ERROR: failed to add user $PAS_ADMIN_USER to org pivotal"
    echo "       => cf create-user $PAS_ADMIN_USER $PAS_ADMIN_PASS"
    exit 1
  fi

  messagePrint " - Add User $PAS_ADMIN_USER to space (demo) with role:" "SpaceManager"
  cf set-space-role $PAS_ADMIN_USER pivotal demo SpaceDeveloper > /dev/null 2>&1; ret=$?
  if [ ${ret} -ne 0 ]; then
    echo "ERROR: failed to add user $PAS_ADMIN_USER to space demo"
    echo "       => cf cf set-space-role $PAS_ADMIN_USER pivotal demo SpaceDeveloper"
    exit 1
  fi

fi

if [ "${PCFCONFIG_BASE}" == "pcfconfig-pks-ingress" ]; then
  checkEnvironment
fi


#gaga
if [ "${PCFCONFIG_BASE}" == "pcfconfig-pks-setup" ]; then
  checkEnvironment
  OPS_MANAGER_URL=https://${OPS_MANAGER_DNS}/setup
  OM_LOGIN="--skip-ssl-validation --target ${OPS_MANAGER_URL} --username $USER --password $PASS"

  # GET CREDENTIALS
  TMP_JQ=/tmp/$$_jq; TMP_SEC=/tmp/$$_sec;
  $OM $OM_LOGIN curl --path /api/v0/deployed/products > $TMP_JQ 2>/dev/null; ret=$?
  if [ $ret -eq 0 ]; then 
    director_ip=$($OM $OM_LOGIN curl --path /api/v0/deployed/director/manifest 2>/dev/null | \
                  jq -r '.instance_groups[].properties.director.address')
    director_cd=$($OM $OM_LOGIN curl --path /api/v0/deployed/director/credentials/uaa_admin_user_credentials 2>/dev/null | \
                  jq -r '.credential.value.password')

    prd="xxx"; i=0
    while [ "${prd}" != "null" ]; do
      prd=$(jq -r ".[$i].type" $TMP_JQ)
      if [ "${prd}" == "pivotal-container-service" ]; then
        inm=$(jq -r ".[$i].installation_name" $TMP_JQ)
        str="/api/v0/deployed/products/${inm}/credentials/.properties.pks_uaa_management_admin_client"
        $OM $OM_LOGIN curl --path ${str} > $TMP_SEC 2>/dev/null; ret=$?
        if [ $ret -eq 0 ]; then 
          sec=$(jq -r '.credential.value.secret' $TMP_SEC) 
        else
          echo "ERROR: 1Can not connect to $OPS_MANAGER_URL"; exit 1
        fi

        # --- UAA-ADMIN-PASSWORD ---
        str="/api/v0/deployed/products/${inm}/credentials/.properties.uaa_admin_password"
        $OM $OM_LOGIN curl --path ${str} > $TMP_SEC 2>/dev/null; ret=$?
        if [ $ret -eq 0 ]; then
          admin_sec=$(jq -r '.credential.value.secret' $TMP_SEC)
        else
          echo "ERROR: 2Can not connect to $OPS_MANAGER_URL"; exit 1
        fi
      fi 

      let i=i+1
    done

    rm -f $$TMP_JQ
  else
    echo "ERROR: Can not connect to $OPS_MANAGER_URL"; exit 1
  fi

  API_HOST_NAME=api.pks.${DNS_PREFIX}.${DNS_SUFFIX}
  TMP_OPSMAN=./opsman.pem; TMP_OPSMAN_PUB=./opsman.pub; TMP_SCRIPT=/tmp/opsman.sh; rm -f $TMP_OPSMAN
  $JQ -r '.modules[].outputs.ssh_private_key.value' $TERRAFORM_TFSTATE | grep -v null >> $TMP_OPSMAN
  $JQ -r '.modules[].outputs.ops_manager_ssh_private_key.value' $TERRAFORM_TFSTATE | grep -v null >> $TMP_OPSMAN
  touch $TMP_SCRIPT
  [ "$TMP_OPSMAN" != "" ] && chmod 600 $TMP_OPSMAN
  [ "$TMP_SCRIPT" != "" ] && chmod 777 $TMP_SCRIPT

  ##############################################################################################
  ######################################## DEBUG INFOS #########################################
  ##############################################################################################
  TMP_LBSCRIPT=/tmp/tmp_lb_script_$$; rm -f $TMP_LBSCRIPT
  echo "cert=/var/tempest/workspaces/default/root_ca_certificate"                                          >  $TMP_LBSCRIPT
  echo "bosh alias-env $DNS_PREFIX -e $director_ip --ca-cert \$cert >/dev/null 2>&1"                       >> $TMP_LBSCRIPT
  echo "echo -e \"admin\n${director_cd}\" | bosh -e $DNS_PREFIX login >/dev/null 2>&1"                     >> $TMP_LBSCRIPT
  echo "bosh -e $DNS_PREFIX vms"                                                                           >> $TMP_LBSCRIPT
  echo "bosh -e $DNS_PREFIX tasks"                                                                         >> $TMP_LBSCRIPT

  scp -o StrictHostKeyChecking=no -qi $TMP_OPSMAN $TMP_LBSCRIPT ubuntu@${OPS_MANAGER_DNS}:/tmp/debug.sh; ret=$?
  if [ ${ret} -ne 0 ]; then
    echo "ERROR: Copying script /tmp/debug.sh to ubuntu@${OPS_MANAGER_DNS} has been failed"
    echo "       Please try manually:"
    echo "       => scp -o StrictHostKeyChecking=no -i $TMP_OPSMAN $TMP_LBSCRIPT ubuntu@${OPS_MANAGER_DNS}:/tmp/debug.sh"
    exit 1
  fi

  #echo ""
  #echo "# --- DIRECTOR LOGINFOR DEBUGGING ---"
  #echo "ssh -qi $TMP_OPSMAN ubuntu@${OPS_MANAGER_DNS} "
  #echo "ubuntu@${DNS_PREFIX}-ops-manager:~$ sh /tmp/debug.sh"
  #echo ""

  # --- SET PKS-API LB DNS ENTRY ---
  if [ "${PCF_CLOUD_NAME}" == "azure" ]; then
    ipa=$(az network public-ip show -g ${DNS_PREFIX} --name ${DNS_PREFIX}-pks-lb-ip 2>/dev/null | jq -r '.ipAddress')
    if [ "$ipa" == "" ]; then 
      echo "ERROR: Can not optaion PKS-API LB IP-Address"
      echo "       => az network public-ip show -g ${DNS_PREFIX} --name ${DNS_PREFIX}-pks-lb-ip"; exit 1
    fi

    # --- CHECK IF ENTRY EXISTS --- 
    rec=$(az network dns record-set list -g ${DNS_PREFIX} --zone-name ${DNS_PREFIX}.${DNS_SUFFIX} \
       --query "[?fqdn=='api.pks.${DNS_PREFIX}.${DNS_SUFFIX}.']" | jq -r '.[].fqdn')
    if [ "${rec}" == "" ]; then 
      messagePrint " - Creating DNS Record for (api.pks.${DNS_PREFIX}.${DNS_SUFFIX})" "$ipa"
      az network dns record-set a add-record -g ${DNS_PREFIX} --zone-name ${DNS_PREFIX}.${DNS_SUFFIX} \
         --record-set-name api.pks --ipv4-address $ipa > /dev/null 2>&1
      if [ "$?" -ne 0 ]; then 
        echo "ERROR: Can not create DNS record for  PKS-API (api.pks.${DNS_PREFIX}.${DNS_SUFFIX})"
        echo "       => az network dns record-set a add-record -g ${DNS_PREFIX} \\"
        echo "             --zone-name ${DNS_PREFIX}.${DNS_SUFFIX} --record-set-name api.pks \\"
        echo "             --ipv4-address $ipa"; exit 1
      fi
    else
      messagePrint " - Updating DNS Record for (api.pks.${DNS_PREFIX}.${DNS_SUFFIX})" "$ipa"
      #az network dns record-set a delete -g ${DNS_PREFIX} --zone-name ${DNS_PREFIX}.${DNS_SUFFIX} --name "api.pks" -y > /dev/null 2>&1
      az network dns record-set a update -g ${DNS_PREFIX} --zone-name ${DNS_PREFIX}.${DNS_SUFFIX} \
         --name api.pks --set arecords[0].ipv4Address=$ipa > /dev/null 2>&1
      if [ "$?" -ne 0 ]; then 
        echo "ERROR: Can not update DNS record for  PKS-API (api.pks.${DNS_PREFIX}.${DNS_SUFFIX})"
        echo "       => az network dns record-set a update -g ${DNS_PREFIX} \\"
        echo "          --zone-name ${DNS_PREFIX}.${DNS_SUFFIX} \\"
        echo "          --name api.pks --set arecords[0].ipv4Address=$ipa \\"; exit 1
      fi
    fi
  fi


  # --- CHEKING DNS ---
  echo "Validating PKS API gateway ($API_HOST_NAME)"
  nslookup -timeout=10 $API_HOST_NAME 8.8.8.8 > /dev/null 2>&1; ret=$?
  if [ $ret -ne 0 ]; then
    i=1; ret="failed"; dns_google_stat="failed"
     while [ $i -lt 10 -a ${ret} == "failed" ]; do
      sleep 10
      nslookup $API_HOST_NAME 8.8.8.8 > /dev/null 2>&1; ret=$?
      if [ $ret -eq 0 ]; then dns_google_stat="successful"; fi
      messagePrint "   => Verify DNS lookup Google (8.8.8.8)" "$dns_google_stat"
      let i=i+1
    done
  else
    messagePrint "   => Verify DNS lookup Google (8.8.8.8)" "successful"
  fi

  localdns=$(nslookup localhost | grep Server:  | awk '{ print $2 }')
  i=1; ret="failed"; dns_google_stat="failed"
   while [ $i -lt 30 -a ${ret} == "failed" ]; do
    sleep 10
    nslookup $API_HOST_NAME > /dev/null 2>&1; ret=$?
    if [ $ret -eq 0 ]; then dns_google_stat="successful"; fi
    messagePrint "   => Verify DNS lookup localhost ($localdns)" "$dns_google_stat"
    let i=i+1
  done

  nslookup $API_HOST_NAME 8.8.8.8 > /dev/null 2>&1; ret=$?
  if [ $ret -eq 0 ]; then 
    # --- HACK - OPEN FW PORT 8443/9021 ON PKS VM ---
    if [ "${PCF_CLOUD_NAME}" == "azure" ]; then
      port_8443=$(az network nsg rule list -g $DNS_PREFIX --nsg-name $DNS_PREFIX-bosh-deployed-vms-security-group \
         --query "[?destinationPortRange=='8443']" | jq -r '.[].destinationPortRange') 
      if [ "${port_8443}" == "" ]; then
        messagePrint " - Configure PKS LB Security Group for API Rule" "port 8443 is open"
        az network nsg rule create --name "Port 8443" --access Allow --source-port-ranges '*' \
          --destination-port-ranges 8443 --destination-address-prefixes '*' --source-address-prefixes '*' \
          -g $DNS_PREFIX --nsg-name "$DNS_PREFIX-bosh-deployed-vms-security-group" --priority 120 > /dev/null 2>&1
        if [ $? -ne 0 ]; then
          echo "ERROR: failled to add port 8443 to security group $DNS_PREFIX-bosh-deployed-vms-security-group"
          echo "       => az network nsg rule create --name "Port 8443" --access Allow --source-port-ranges '*' \\"
          echo "          --destination-port-ranges 8443 --destination-address-prefixes '*' --source-address-prefixes '*' \\"
          echo "-g $DNS_PREFIX --nsg-name "$DNS_PREFIX-bosh-deployed-vms-security-group" --priority 120"
          exit 1
        fi
      else
        messagePrint " - Verify PKS LB Security Group for API Rule" "port 8443 is open"
      fi

      port_9021=$(az network nsg rule list -g $DNS_PREFIX --nsg-name $DNS_PREFIX-bosh-deployed-vms-security-group \
         --query "[?destinationPortRange=='9021']" | jq -r '.[].destinationPortRange') 
      if [ "${port_9021}" == "" ]; then
        messagePrint " - Configure PKS LB Security Group for API Rule" "port 9021 is open"
        az network nsg rule create --name "Port 9021" --access Allow --source-port-ranges '*' \
          --destination-port-ranges 9021 --destination-address-prefixes '*' --source-address-prefixes '*' \
          -g $DNS_PREFIX --nsg-name "$DNS_PREFIX-bosh-deployed-vms-security-group" --priority 121 > /dev/null 2>&1
        if [ $? -ne 0 ]; then
          echo "ERROR: failled to add port 9021 to security group $DNS_PREFIX-bosh-deployed-vms-security-group"
          echo "       => az network nsg rule create --name "Port 9021" --access Allow --source-port-ranges '*' \\"
          echo "          --destination-port-ranges 9021 --destination-address-prefixes '*' --source-address-prefixes '*' \\"
          echo "-g $DNS_PREFIX --nsg-name "$DNS_PREFIX-bosh-deployed-vms-security-group" --priority 121"
          exit 1
        fi
      else
        messagePrint " - Verify PKS LB Security Group for API Rule" "port 9021 is open"
      fi

      #echo "Open Network Ports (8443/9021) for $API_HOST_NAME on PKS VM"
      #pksvm=$(az vm list --query "[?starts_with(to_string(tags.deployment), 'pivotal-container')]|[?location == '$AZURE_REGION']" | \
      #       jq -r '.[].name' | head -1)
      #if [ "${pksvm}" != "" ]; then
      #  az vm open-port -g $DNS_PREFIX -n $pksvm --priority 102 --port 8443 > /dev/null 2>&1
      #  az vm open-port -g $DNS_PREFIX -n $pksvm --priority 101 --port 9021 > /dev/null 2>&1
      #else
      #  echo "ERROR: PKS VM can not be found"; exit 1
      #fi
    fi

    ##############################################################################################
    ############################### CONFIGURE PKS AUTHENTIFICATION ###############################
    ##############################################################################################

    # --- CHECK IF AUTHENTIFICATION HAS ALREADY BEEN CONFIGURED ---
    pks login -u ${PKS_ADMIN_USER} -p ${PKS_ADMIN_PASS} -a ${API_HOST_NAME} --skip-ssl-validation > /dev/null 2>&1; ret=$?
    if [ $ret -ne 0 ]; then 
      echo "Creating PKS Authentification"
      messagePrint " - PKS Administration User:" "$PKS_ADMIN_USER"
      messagePrint " - PKS Administration Password:" "$PKS_ADMIN_PASS"
      messagePrint " - PKS Administration Email:" "$PKS_ADMIN_MAIL"
      messagePrint " - PKS Administration Role:" "pks.clusters.admin"

      # SLEEP AS CRACE PERIOD 
      sleep 240

      # --- UAAC LOGIN SCRIPT ---
      TMP_SCRIPT=/tmp/tmp_script_$$; rm -f $TMP_SCRIPT
      echo "echo '# Connecting to ${API_HOST_NAME}'"                                                          >  $TMP_SCRIPT
      #echo "uaac target ${API_HOST_NAME}:8443 --ca-cert /var/tempest/workspaces/default/root_ca_certificate" >> $TMP_SCRIPT
      echo "uaac target ${API_HOST_NAME}:8443 --skip-ssl-validation 2>/dev/null"                              >> $TMP_SCRIPT
      echo "if [ \$? -ne 0 ]; then"                                                                           >> $TMP_SCRIPT
      echo "  exit 1"                                                                                         >> $TMP_SCRIPT
      echo "fi"                                                                                               >> $TMP_SCRIPT
      echo "echo '# Grant Enterprise PKS Access to a User'"                                                   >> $TMP_SCRIPT
      echo "uaac token client get admin -s ${sec} 2>/dev/null"                                                >> $TMP_SCRIPT
      echo "echo '# Add User: ${PKS_ADMIN_USER} / ${PKS_ADMIN_MAIL}'"                                         >> $TMP_SCRIPT
      echo "sudo uaac user get ${PKS_ADMIN_USER} 2>/dev/null"                                                 >> $TMP_SCRIPT
      echo "if [ \$? -ne 0 ]; then"                                                                           >> $TMP_SCRIPT
      echo "  uaac user add ${PKS_ADMIN_USER} --emails ${PKS_ADMIN_MAIL} -p ${PKS_ADMIN_PASS} 2>/dev/null"    >> $TMP_SCRIPT
      echo "  uaac member add pks.clusters.admin ${PKS_ADMIN_USER} 2>/dev/null"                               >> $TMP_SCRIPT
      echo "fi"                                                                                               >> $TMP_SCRIPT

      cp $TMP_OPSMAN ~/opsman.pem
      echo "ssh -qi ~/opsman.pem ubuntu@${OPS_MANAGER_DNS}" > ~/ssh-opsman.sh
  
      scp -o StrictHostKeyChecking=no -qi $TMP_OPSMAN $TMP_SCRIPT ubuntu@${OPS_MANAGER_DNS}:/tmp/om-install.sh; ret=$?
      if [ ${ret} -ne 0 ]; then
        echo "ERROR: Copying script /tmp/om-install.sh to ubuntu@${OPS_MANAGER_DNS} has been failed"
        echo "       Please try manually:"
        echo "       => scp -o StrictHostKeyChecking=no -i $TMP_OPSMAN $TMP_SCRIPT ubuntu@${OPS_MANAGER_DNS}:/tmp/om-install.sh"
        exit 1
      fi

      echo "-----------------------------------------------------------------------------------------------------------"
      (ssh -qi $TMP_OPSMAN ubuntu@${OPS_MANAGER_DNS} -n "sudo /tmp/om-install.sh"; ret=$?) | sed '/^$/d'
      echo "-----------------------------------------------------------------------------------------------------------"
      if [ ${ret} -ne 0 ]; then
        echo "ERROR: executing remote-script: /tmp/om-install.sh on ubuntu@${OPS_MANAGER_DNS} has been failed"
        echo "       Please try manually:"
        echo "       => ssh -i $TMP_OPSMAN ubuntu@${OPS_MANAGER_DNS} -n \"sudo /tmp/om-install.sh\""
        exit 1
      fi

      pks login -u ${PKS_ADMIN_USER} -p ${PKS_ADMIN_PASS} -a ${API_HOST_NAME} --skip-ssl-validation > /dev/null 2>&1; ret=$?
      if [ $ret -ne 0 ]; then
        echo "ERROR: Accessing API gateway $OPS_MANAGER_DNS failed"; exit 1
      fi
    fi

    ##############################################################################################
    ################################ CONFIGURE PKS LOADBALANCERS #################################
    ##############################################################################################

    if [ "${PCF_CLOUD_NAME}" == "azure" ]; then
      vmid=$(az vm list -g $DNS_PREFIX --query "[?tags.instance_group=='pivotal-container-service']" | jq -r '.[].name')
      for n in $PKS_CLUSTER_1_NAME $PKS_CLUSTER_2_NAME $PKS_CLUSTER_3_NAME; do
        echo "Creating Workload LoadBalancer (${DNS_PREFIX}-$n)"

        # --- CREATE PULIC IP FOR LOADBALANCER ---
        ipa=$(az network public-ip list -g azpks --query "[?name=='${DNS_PREFIX}-${n}-lb-ip']" | jq -r '.[].ipAddress')
        if [ "${ipa}" == "" ]; then
          az network public-ip create -g $DNS_PREFIX -n ${DNS_PREFIX}-${n}-lb-ip --allocation-method Static --sku Standard > /dev/null 2>&1
          if [ $? -ne 0 ]; then
            echo "ERROR: failled to create publicip"
            echo "       => az network public-ip create -g $DNS_PREFIX -n ${DNS_PREFIX}-${n} --allocation-method Static"
            exit 1
          fi

          ipa=$(az network public-ip list -g azpks --query "[?name=='${DNS_PREFIX}-${n}-lb-ip']" | jq -r '.[].ipAddress')
          messagePrint " - Create LB Public IP ($ipa)" "${DNS_PREFIX}-${n}-lb-ip"
        else
          messagePrint " - Verify LB Public IP ($ipa)" "${DNS_PREFIX}-${n}-lb-ip"
        fi

        # --- CHECK IF ENTRY EXISTS ---
        rec=$(az network dns record-set list -g ${DNS_PREFIX} --zone-name ${DNS_PREFIX}.${DNS_SUFFIX} \
           --query "[?fqdn=='${n}.${DNS_PREFIX}.${DNS_SUFFIX}.']" | jq -r '.[].fqdn')
        if [ "${rec}" == "" ]; then
          messagePrint " - Creating DNS entry (${n}.${DNS_PREFIX}.${DNS_SUFFIX})" "$ipa"
          az network dns record-set a add-record -g ${DNS_PREFIX} --zone-name ${DNS_PREFIX}.${DNS_SUFFIX} \
             --record-set-name ${n} --ipv4-address $ipa > /dev/null 2>&1
          if [ "$?" -ne 0 ]; then
            echo "ERROR: Can not create DNS record for  PKS-API (${n}.${DNS_PREFIX}.${DNS_SUFFIX})"
            echo "       => az network dns record-set a add-record -g ${DNS_PREFIX} \\"
            echo "             --zone-name ${DNS_PREFIX}.${DNS_SUFFIX} --record-set-name $n \\"
            echo "             --ipv4-address $ipa"; exit 1
          fi
        else
          messagePrint " - Verify DNS entry for (${n}.${DNS_PREFIX}.${DNS_SUFFIX})" "$ipa"
        fi

        # --- CHECK IF LB EXISTS ---
        lbn=$(az network lb list -g ${DNS_PREFIX} --query "[?name == '${n}-lb']" | jq -r '.[].name')
        if [ "${lbn}" == "" ]; then
          messagePrint " - Creating loadbalancer" "${n}-lb"
          az network lb create -g ${DNS_PREFIX}  -n ${n}-lb --sku Standard \
             --public-ip-address "${DNS_PREFIX}-${n}-lb-ip" --location $AZURE_REGION --backend-pool-name ${n}-pool > /dev/null 2>&1
          if [ "$?" -ne 0 ]; then
            echo "ERROR: Can not create DNS record for  PKS-API (${n}.${DNS_PREFIX}.${DNS_SUFFIX})"
            echo "       => az network lb create -g ${DNS_PREFIX} -n ${n}-lb --sku Standard \\"
            echo "           --public-ip-address ${DNS_PREFIX}-${n}-lb-ip --location $AZURE_REGION i\\"
            echo "           --backend-pool-name ${n}-pool"
            exit 1
          fi
        else
          messagePrint " - Verify loadbalancer" "${n}-lb"
        fi

        # --- CREATE LB HEALTH PROBE ---
        prb=$(az network lb probe show -g ${DNS_PREFIX} --lb-name ${n}-lb -n ${n}-probe 2>/dev/null | jq -r '.name')
        if [ "${prb}" == "" ]; then
          messagePrint " - Creating LB Health Probe for port 8443" "${n}-probe"
          az network lb probe create -g ${DNS_PREFIX} --lb-name ${n}-lb -n ${n}-probe --protocol tcp --port 8443 > /dev/null 2>&1
          if [ "$?" -ne 0 ]; then
            echo "ERROR: Can not create address-pool"
            echo "       => az network lb probe create -g ${DNS_PREFIX} --lb-name ${n}-lb -n ${n}-probe --protocol tcp --port 8443"
            exit 1
          fi
        else
          messagePrint " - Verify LB Health Proble for port 8443" "${n}-probe"
        fi

        # --- CREATE LB RULE ---
        rul=$(az network lb rule show -g ${DNS_PREFIX} --lb-name ${n}-lb -n ${n}-rule 2>/dev/null | jq -r '.name')
        if [ "${rul}" == "" ]; then
          messagePrint " - Creating LB Rule for port 8443" "${n}-rule"
          az network lb rule create -g ${DNS_PREFIX} --lb-name ${n}-lb -n ${n}-rule --protocol tcp \
             --frontend-port 8443 --backend-port 8443 --backend-pool-name ${n}-pool --probe-name ${n}-probe > /dev/null 2>&1
          if [ "$?" -ne 0 ]; then
            echo "ERROR: Can not create address-pool"
            echo "       => az network lb rule create -g ${DNS_PREFIX} --lb-name ${n}-lb -n ${n}-rule --protocol tcp \\"
            echo "          --frontend-port 8443 --backend-port 8443 --backend-pool-name ${n}-pool --probe-name ${n}-probe"
            exit 1
          fi
        else
          messagePrint " - Verify LB Rule for port 8443" "${n}-rule"
        fi
      done
    fi

    if [ "${PCF_CLOUD_NAME}" == "gcp" ]; then
      for n in $PKS_CLUSTER_1_NAME $PKS_CLUSTER_2_NAME $PKS_CLUSTER_3_NAME; do
        gcloud compute target-pools describe ${GCP_DNS_PREFIX}-${n} --region=$GCP_REGION > /dev/null 2>&1; ret=$?
        if [ ${ret} -gt 0 ]; then
          # --- CREATE TARGET POOL ---
          echo "Creating Target Pool (${GCP_DNS_PREFIX}-$n)"
          gcloud compute target-pools create ${GCP_DNS_PREFIX}-${n} --region=$GCP_REGION > /dev/null 2>&1; ret=$?
          if [ ${ret} -ne 0 ]; then
            echo "ERROR: Creating target-pools (${GCP_DNS_PREFIX}-$n)"
            echo "gcloud compute target-pools create ${GCP_DNS_PREFIX}-${n} --region=$GCP_REGION"
            exit 1
          fi
        fi

        gcloud compute forwarding-rules describe ${GCP_DNS_PREFIX}-${n} --region=$GCP_REGION > /dev/null 2>&1; ret=$?
        if [ ${ret} -gt 0 ]; then
          # --- CREATE LOAD BALANCER ---
          echo "Creating LoadBalancer (${GCP_DNS_PREFIX}-$n) for cluster: $n"
	  gcloud compute forwarding-rules create ${GCP_DNS_PREFIX}-${n} --ports 8443 \
            --target-pool ${GCP_DNS_PREFIX}-${n} --region=$GCP_REGION > /dev/null 2>&1; ret=$?
          if [ ${ret} -ne 0 ]; then
            echo "ERROR: Creating forwarding-rules (${GCP_DNS_PREFIX}-$n)"
            echo "gcloud compute target-pools create ${GCP_DNS_PREFIX}-${n} --region=$GCP_REGION"
            exit 1
          fi
        fi

        cnt=$(gcloud dns record-sets list -z ${GCP_DNS_PREFIX}-zone --name "${n}.${GCP_DNS_PREFIX}.${GCP_DNS_SUFFIX}." \
                --type=A 2> /dev/null | wc -l | sed 's/ //g')
        if [ ${cnt} -eq 0 ]; then
          echo "Creating DNS Entry ${n}.${GCP_DNS_PREFIX}.${GCP_DNS_SUFFIX}. for (${GCP_DNS_PREFIX}-zone)"
          ipa=$(gcloud compute forwarding-rules describe ${GCP_DNS_PREFIX}-${n} --region=$GCP_REGION | \
              grep IPAddress | awk '{ print $NF }')
          gcloud dns record-sets transaction start -z ${GCP_DNS_PREFIX}-zone
          gcloud dns record-sets transaction add "$ipa" --name ${n}.${GCP_DNS_PREFIX}.${GCP_DNS_SUFFIX}. \
             --type A -z ${GCP_DNS_PREFIX}-zone --ttl=300
          gcloud dns record-sets transaction execute -z ${GCP_DNS_PREFIX}-zone > /dev/null 2>&1; ret=$?
          if [ ${ret} -ne 0 ]; then
            echo "ERROR: Creating DNS record-sets for zone (${GCP_DNS_PREFIX}-zone)"
            exit 1
          fi
        fi
      done
    fi

    if [ "${PCF_CLOUD_NAME}" == "aws" ]; then
      # --- CREATE ELB LOADBALANCER ---
      SUB1=$($JQ -r '.modules[].outputs.public_subnet_ids.value[0]' $TERRAFORM_TFSTATE | grep -v null | sed '/: $/d' | sort -u)
      SUB2=$($JQ -r '.modules[].outputs.public_subnet_ids.value[1]' $TERRAFORM_TFSTATE | grep -v null | sed '/: $/d' | sort -u)
      SUB3=$($JQ -r '.modules[].outputs.public_subnet_ids.value[2]' $TERRAFORM_TFSTATE | grep -v null | sed '/: $/d' | sort -u)
      SECG=$($JQ -r '.modules[].resources."aws_security_group.pks_api_lb_security_group".primary.id' $TERRAFORM_TFSTATE | \
         grep -v null | sed '/: $/d' | sort -u)

      echo "Creating ELB Loadbalancer (k8s-master-$n)"
      messagePrint " - Subnet-1:" "$SUB1"
      messagePrint " - Subnet-2:" "$SUB2"
      messagePrint " - Subnet-3:" "$SUB3"
      messagePrint " - Security Group:" "$SECG"

      #echo "       => scp -o StrictHostKeyChecking=no -i $TMP_OPSMAN $TMP_SCRIPT ubuntu@${OPS_MANAGER_DNS}:/tmp/om-install.sh"
      #echo "       => ssh -i $TMP_OPSMAN ubuntu@${OPS_MANAGER_DNS} -n \"sudo /tmp/om-install.sh\""

      for n in $PKS_CLUSTER_1_NAME $PKS_CLUSTER_2_NAME $PKS_CLUSTER_3_NAME; do
        aws elb --region $AWS_REGION describe-load-balancers --load-balancer-names "k8s-master-$n" > /dev/null 2>&1; ret=$?
        if [ ${ret} -gt 0 ]; then
          echo "Creating LoadBalancer (k8s-master-$n) for cluster: $n"

          aws elb create-load-balancer --region $AWS_REGION  --load-balancer-name "k8s-master-$n" \
             --tags "Key=Environment,Value=$AWS_DNS_PREFIX" \
             --listeners "Protocol=TCP,LoadBalancerPort=8443,InstanceProtocol=TCP,InstancePort=8443" \
             --subnet $SUB1 $SUB2 $SUB3 --security-groups $SECG > /dev/null 2>&1; ret=$?
          if [ ${ret} -ne 0 ]; then
            echo "ERROR: Creating LoadBalancer"
            echo "aws elb create-load-balancer --region $AWS_REGION  --load-balancer-name \"k8s-master-$n\" \\"
            echo "  --tags \"Key=Environment,Value=$AWS_DNS_PREFIX\" \\"
            echo "  --listeners \"Protocol=TCP,LoadBalancerPort=8443,InstanceProtocol=TCP,InstancePort=8443\" \\"
            echo "  --subnet $SUB1 $SUB2 $SUB3 --security-groups $SECG"
            exit 1
          fi

          aws elb configure-health-check --region $AWS_REGION --load-balancer-name k8s-master-$n \
             --health-check "Target=TCP:8443,Interval=30,UnhealthyThreshold=2,HealthyThreshold=2,Timeout=3" > /dev/null 2>&1; ret=$?
          if [ ${ret} -ne 0 ]; then
            echo "ERROR: Configure Healhcheck"
            echo "aws elb configure-health-check --region $AWS_REGION --load-balancer-name k8s-master-$n \\"
            echo "  --health-check \"Target=TCP:8443,Interval=30,UnhealthyThreshold=2,HealthyThreshold=2,Timeout=3\""
            exit 1
          fi
        fi

        if [ "${ROUTE53_TOKEN}" != "" ]; then
          DNSLB=$(aws elb --region $AWS_REGION describe-load-balancers --load-balancer-names "k8s-master-$n" | \
            jq -r '.LoadBalancerDescriptions[0].DNSName')
          DNSLB_ZONEID=$(aws elb --region $AWS_REGION describe-load-balancers --load-balancer-names "k8s-master-$n" | \
            jq -r '.LoadBalancerDescriptions[0].CanonicalHostedZoneNameID')

          ZONE_ID=$(aws route53 list-hosted-zones-by-name --dns-name ${AWS_DNS_PREFIX}.${AWS_DNS_SUFFIX} | jq -r '.HostedZones[0].Id')
          ZONE_ID_STR=$(echo "${ZONE_ID}" | awk -F'/' '{ print $NF }')

#ppppp
          if [ "${ZONE_ID}" != "" ]; then
            ZONE="${n}.${AWS_DNS_PREFIX}.${AWS_DNS_SUFFIX}"

    cat << EOF | sed -e "s/FQHN/${ZONE}/g" -e "s/AAAA/$DNSLB/g" -e "s/ZZID/$DNSLB_ZONEID/g" > /tmp/$$_zone_record
{
            "Comment": "CREATE/DELETE/UPSERT a record ",
            "Changes": [{
            "Action": "UPSERT",
                        "ResourceRecordSet": {
                                    "Name": "FQHN.",
                                    "Type": "A",
                                    "AliasTarget": {
                                                    "HostedZoneId": "ZZID",
                                                    "DNSName": "dualstack.AAAA.",
                                                    "EvaluateTargetHealth": true
                                                }
}}]
}
EOF


            echo "-----------------------------------------------------------------------------------------------------------"
            aws route53 change-resource-record-sets --hosted-zone-id ${ZONE_ID} --change-batch file:///tmp/$$_zone_record
            echo "-----------------------------------------------------------------------------------------------------------"

            cp /tmp/$$_zone_record /tmp/aws_zone_record
            rm -f /tmp/$$_zone_record
          fi
        fi
      done
    fi

    ##############################################################################################
    ######################################## DEBUG INFOS #########################################
    ##############################################################################################
    TMP_LBSCRIPT=/tmp/tmp_lb_script_$$; rm -f $TMP_LBSCRIPT
    echo "cert=/var/tempest/workspaces/default/root_ca_certificate"                                          >  $TMP_LBSCRIPT
    echo "bosh alias-env $DNS_PREFIX -e $director_ip --ca-cert \$cert >/dev/null 2>&1"                       >> $TMP_LBSCRIPT
    echo "echo -e \"admin\n${director_cd}\" | bosh -e $DNS_PREFIX login >/dev/null 2>&1"                     >> $TMP_LBSCRIPT
    echo "bosh -e $DNS_PREFIX vms"                                                                           >> $TMP_LBSCRIPT
    echo "bosh -e $DNS_PREFIX tasks"                                                                         >> $TMP_LBSCRIPT

    scp -o StrictHostKeyChecking=no -qi $TMP_OPSMAN $TMP_LBSCRIPT ubuntu@${OPS_MANAGER_DNS}:/tmp/debug.sh; ret=$?
    if [ ${ret} -ne 0 ]; then
      echo "ERROR: Copying script /tmp/masters.sh to ubuntu@${OPS_MANAGER_DNS} has been failed"
      echo "       Please try manually:"
      echo "       => scp -o StrictHostKeyChecking=no -i $TMP_OPSMAN $TMP_LBSCRIPT ubuntu@${OPS_MANAGER_DNS}:/tmp/debug.sh"
      exit 1
    fi

    #echo ""
    #echo "# --- DIRECTOR LOGIN FOR DEBUGGING ---"
    #echo "ssh -qi $TMP_OPSMAN ubuntu@${OPS_MANAGER_DNS} "
    #echo "ubuntu@${DNS_PREFIX}-ops-manager:~$ sh /tmp/debug.sh"
    #echo ""
    #echo "# --- PKS LOGIN ---"
    #echo "pks login -u ${PKS_ADMIN_USER} -p ${PKS_ADMIN_PASS} -a ${API_HOST_NAME} --skip-ssl-validation"
    #echo "pks login -u admin -p ${admin_sec} -a ${API_HOST_NAME} --skip-ssl-validation"

    ##############################################################################################
    #################################### CREATE PKS CLUSTERS #####################################
    ##############################################################################################


    if [ "${PKS_CLUSTER_1_NAME}" != "" -o "${PKS_CLUSTER_2_NAME}" != "" -o "${PKS_CLUSTER_3_NAME}" != "" ]; then 
      pks login -u ${PKS_ADMIN_USER} -p ${PKS_ADMIN_PASS} -a ${API_HOST_NAME} --skip-ssl-validation > /dev/null 2>&1
      if [ $? -ne 0 ]; then
        echo "ERROR: login to pks failled"; exit 1
      fi
  
      if [ "${PKS_CLUSTER_1_NAME}" != "" ]; then 
        pks cluster $PKS_CLUSTER_1_NAME > /dev/null 2>&1
        if [ $? -ne 0 ]; then 
          messagePrint "PKS Cluster 1: $PKS_CLUSTER_1_NAME" "creating"
          messagePrint " - External Hostnama:" "$PKS_CLUSTER_1_NAME.${DNS_PREFIX}.${DNS_SUFFIX}"
          messagePrint " - Plan:" "$PKS_CLUSTER_1_PLAN"
          pks create-cluster $PKS_CLUSTER_1_NAME \
             --external-hostname $PKS_CLUSTER_1_NAME.${DNS_PREFIX}.${DNS_SUFFIX} \
             --plan $PKS_CLUSTER_1_PLAN --wait 
          echo "-----------------------------------------------------------------------------------------------------------"
          if [ $? -ne 0 ]; then 
            echo "ERROR: Creating PKS Cluster $PKS_CLUSTER_1_NAME failed"
            echo "       => pks create-cluster $PKS_CLUSTER_1_NAME --external-hostname ${lbdns} --plan $PKS_CLUSTER_1_PLAN  --wait"
            exit 1
          fi

          stt=$(pks cluster $PKS_CLUSTER_1_NAME | egrep "Last Action State:" | awk '{ print $NF }')
          messagePrint "PKS Cluster 1: $PKS_CLUSTER_1_NAME ($PKS_CLUSTER_1_PLAN)" "$stt"
          if [ "$stt" != "succeeded" ]; then
            echo "ERROR: PKS Cluster ($PKS_CLUSTER_1_NAME) creation failed"; exit 1
          fi
        else
          stt=$(pks cluster $PKS_CLUSTER_1_NAME | egrep "Last Action State:" | awk '{ print $NF }')
          messagePrint "PKS Cluster 1: $PKS_CLUSTER_1_NAME ($PKS_CLUSTER_1_PLAN)" "$stt"

          if [ "$stt" == "failed" ]; then
            echo "ERROR: PKS Cluster ($PKS_CLUSTER_1_NAME) is in failed state, please delete cluster and restart"
            echo "       => pks delete-cluster $PKS_CLUSTER_1_NAME"
            exit 1
          fi
        fi
      fi

      if [ "${PKS_CLUSTER_2_NAME}" != "" ]; then
        pks cluster $PKS_CLUSTER_2_NAME > /dev/null 2>&1
        if [ $? -ne 0 ]; then
          messagePrint "PKS Cluster 2: $PKS_CLUSTER_1_NAME" "creating"
          messagePrint " - External Hostnama:" "$PKS_CLUSTER_2_NAME.${DNS_PREFIX}.${DNS_SUFFIX}"
          messagePrint " - Plan:" "$PKS_CLUSTER_2_PLAN"
          pks create-cluster $PKS_CLUSTER_2_NAME \
             --external-hostname $PKS_CLUSTER_2_NAME.${DNS_PREFIX}.${DNS_SUFFIX} \
             --plan $PKS_CLUSTER_2_PLAN --wait
          echo "-----------------------------------------------------------------------------------------------------------"
          if [ $? -ne 0 ]; then
            echo "ERROR: Creating PKS Cluster $PKS_CLUSTER_2_NAME failed"
            echo "       => pks create-cluster $PKS_CLUSTER_2_NAME --external-hostname ${lbdns} --plan $PKS_CLUSTER_2_PLAN  --wait"
            #exit 1
          fi

          stt=$(pks cluster $PKS_CLUSTER_2_NAME | egrep "Last Action State:" | awk '{ print $NF }')
          messagePrint "PKS Cluster 2: $PKS_CLUSTER_2_NAME ($PKS_CLUSTER_2_PLAN)" "$stt"
          if [ "$stt" != "succeeded" ]; then
            echo "ERROR: PKS Cluster ($PKS_CLUSTER_2_NAME) creation failed"; exit 1
          fi
        else
          stt=$(pks cluster $PKS_CLUSTER_2_NAME | egrep "Last Action State:" | awk '{ print $NF }')
          messagePrint "PKS Cluster 2: $PKS_CLUSTER_2_NAME ($PKS_CLUSTER_2_PLAN)" "$stt"

          if [ "$stt" == "failed" ]; then
            echo "ERROR: PKS Cluster ($PKS_CLUSTER_2_NAME) is in failed state, please delete cluster and restart"
            echo "       => pks delete-cluster $PKS_CLUSTER_2_NAME"
            exit 1
          fi
        fi
      fi
    fi

    TMP_LBSCRIPT=/tmp/tmp_lb_script_$$; rm -f $TMP_LBSCRIPT

    ##############################################################################################
    ######################## SET VLAN TAGS AND INSTANCES OF MASTERNODES ##########################
    ##############################################################################################

    if [ "${PCF_CLOUD_NAME}" == "azure" ]; then
      for n in $PKS_CLUSTER_1_NAME $PKS_CLUSTER_2_NAME $PKS_CLUSTER_3_NAME; do
        uid=$(pks cluster $n | egrep "UUID:" | awk '{ print $NF }')

        ##############################################################################################
        ############################## GET CLUSTER INSTANCES GET INSTANCES ###########################
        ##############################################################################################

        echo "cert=/var/tempest/workspaces/default/root_ca_certificate"                                     >  $TMP_LBSCRIPT
        echo "bosh alias-env $DNS_PREFIX -e $director_ip --ca-cert \$cert >/dev/null 2>&1"                  >> $TMP_LBSCRIPT
        echo "[ \$? -ne 0 ] && exit 1"                                                                      >> $TMP_LBSCRIPT
        echo "echo -e \"admin\n${director_cd}\" | bosh -e $DNS_PREFIX login >/dev/null 2>&1"                >> $TMP_LBSCRIPT
        echo "[ \$? -ne 0 ] && exit 1"                                                                      >> $TMP_LBSCRIPT
        echo "bosh -e $DNS_PREFIX -d service-instance_$uid --column='Instance' --column='VM CID' vms | \\"  >> $TMP_LBSCRIPT
        echo "egrep \"^master/\" | sed -e 's/;/ /g' -e 's/agent_id://g' | awk '{ print \$2 }'"              >> $TMP_LBSCRIPT

        scp -o StrictHostKeyChecking=no -qi $TMP_OPSMAN $TMP_LBSCRIPT ubuntu@${OPS_MANAGER_DNS}:/tmp/masters.sh; ret=$?
        if [ ${ret} -ne 0 ]; then
          echo "ERROR: Copying script /tmp/masters.sh to ubuntu@${OPS_MANAGER_DNS} has been failed"
          echo "       Please try manually:"
          echo "       => scp -o StrictHostKeyChecking=no -i $TMP_OPSMAN $TMP_LBSCRIPT ubuntu@${OPS_MANAGER_DNS}:/tmp/masters.sh"
          exit 1
        fi

        ssh -qi $TMP_OPSMAN ubuntu@${OPS_MANAGER_DNS} -n "bash /tmp/masters.sh" >/dev/null 2>&1; ret=$?
        if [ ${ret} -ne 0 ]; then
          echo "ERROR: executing remote-script: /tmp/masters.sh on ubuntu@${OPS_MANAGER_DNS} has been failed"
          echo "       Please try manually:"
          echo "       => ssh -i $TMP_OPSMAN ubuntu@${OPS_MANAGER_DNS} -n \"bash /tmp/masters.sh\""
          exit 1
        else
          mst=$(ssh -qi $TMP_OPSMAN ubuntu@${OPS_MANAGER_DNS} -n "bash /tmp/masters.sh" 2>/dev/null)
          if [ "${mst}" == "" ]; then 
            echo "ERROR: failed to retrieve the hostname and ip adresses of the master nodes"
            echo "       => ssh -i $TMP_OPSMAN ubuntu@${OPS_MANAGER_DNS} -n \"bash /tmp/masters.sh\""
          fi
        fi

        messagePrint "Adding Master Nodes of PKS Cluster ($n) to LB" "${n}-lb"
        for master in $mst; do
          messagePrint " - Add/update Master Node" "${master}"
          nid=$(az vm get-instance-view -n $master -g ${DNS_PREFIX} 2>/dev/null | jq -r '.networkProfile.networkInterfaces[].id')
          if [ "${nid}" == "" ]; then
            echo "ERROR: failed to get Network id of Instance $master"
            echo "       => az vm get-instance-view -n $master -g ${DNS_PREFIX}"; exit 1
          fi

          nnm=$(az network nic show --ids $nid 2>/dev/null | jq -r '.name')
          if [ "${nnm}" == "" ]; then
            echo "ERROR: failed to get Network Name of Instance $master"
            echo "       => az network nic show --ids $nid"; exit 1
          fi

          ipc=$(az network nic ip-config list -g ${DNS_PREFIX} --nic-name $nnm 2>/dev/null | jq -r '.[].name')
          if [ "${ipc}" == "" ]; then
            echo "ERROR: failed to get IP Config of Instance $master"
            echo "       => az network nic ip-config list -g ${DNS_PREFIX} --nic-name $nnm"
          fi

          az network nic ip-config address-pool add -g ${DNS_PREFIX} --nic-name $nnm --lb-name "${n}-lb" \
             --address-pool "${n}-pool" --ip-config-name $ipc > /dev/null 2>&1
          if [ $? -ne 0 ]; then 
            echo "ERROR: failed to add the master vm $master to backendpool ${n}-pool"
            echo "       => az network nic ip-config address-pool add -g ${DNS_PREFIX} --nic-name $nnm --lb-name ${n}-lb \\"
            echo "          --address-pool "${n}-pool" --ip-config-name $ipc"; exit 1
          fi

        done
      done
    fi

    if [ "${PCF_CLOUD_NAME}" == "gcp" ]; then

        ##############################################################################################
        ############################## GET CLUSTER INSTANCES GET INSTANCES ###########################
        ##############################################################################################

        echo "cert=/var/tempest/workspaces/default/root_ca_certificate"                                          >  $TMP_LBSCRIPT
        echo "bosh alias-env $DNS_PREFIX -e $director_ip --ca-cert \$cert >/dev/null 2>&1"                       >> $TMP_LBSCRIPT
        echo "[ \$? -ne 0 ] && exit 1"                                                                           >> $TMP_LBSCRIPT
        echo "echo -e \"admin\n${director_cd}\" | bosh -e $DNS_PREFIX login >/dev/null 2>&1"                     >> $TMP_LBSCRIPT
        echo "[ \$? -ne 0 ] && exit 1"                                                                           >> $TMP_LBSCRIPT
        echo "bosh -e $DNS_PREFIX -d service-instance_$uid vms | egrep \"^master/\" | awk '{ print \$(NF-2) }'"  >> $TMP_LBSCRIPT

        scp -o StrictHostKeyChecking=no -qi $TMP_OPSMAN $TMP_LBSCRIPT ubuntu@${OPS_MANAGER_DNS}:/tmp/masters.sh; ret=$?
        if [ ${ret} -ne 0 ]; then
          echo "ERROR: Copying script /tmp/masters.sh to ubuntu@${OPS_MANAGER_DNS} has been failed"
          echo "       Please try manually:"
          echo "       => scp -o StrictHostKeyChecking=no -i $TMP_OPSMAN $TMP_LBSCRIPT ubuntu@${OPS_MANAGER_DNS}:/tmp/masters.sh"
          exit 1
        fi

        ssh -qi $TMP_OPSMAN ubuntu@${OPS_MANAGER_DNS} -n "bash /tmp/masters.sh" >/dev/null 2>&1; ret=$?
        if [ ${ret} -ne 0 ]; then
          echo "ERROR: executing remote-script: /tmp/masters.sh on ubuntu@${OPS_MANAGER_DNS} has been failed"
          echo "       Please try manually:"
          echo "       => ssh -i $TMP_OPSMAN ubuntu@${OPS_MANAGER_DNS} -n \"bash /tmp/masters.sh\""
          exit 1
        else
          mst=$(ssh -qi $TMP_OPSMAN ubuntu@${OPS_MANAGER_DNS} -n "bash /tmp/masters.sh" 2>/dev/null)
        fi

    fi

    if [ "${PCF_CLOUD_NAME}" == "aws" ]; then
      for n in $PKS_CLUSTER_1_NAME $PKS_CLUSTER_2_NAME $PKS_CLUSTER_3_NAME; do
        uid=$(pks cluster $n | egrep "UUID:" | awk '{ print $NF }')

        # --- ADD CLUSTER UUID TO AWS SUBNETS AT TAG ---
        for net in $(aws ec2 --region=$AWS_REGION describe-subnets | jq -r '.Subnets[].SubnetId'); do
          cnt=$(aws ec2 --region=$AWS_REGION describe-subnets --subnet-id $net | jq -r '.Subnets[].Tags[].Value' 2>/dev/null | \
              egrep -c "^${DNS_PREFIX}-public-subnet")
          if [ $cnt -gt 0 ]; then
            aws ec2 --region=$AWS_REGION create-tags --resources $net \
                --tags Key="kubernetes.io/cluster/service-instance_$uid",Value=""
          fi
        done

        ##############################################################################################
        ############################## GET CLUSTER INSTANCES GET INSTANCES ###########################
        ##############################################################################################

        echo "cert=/var/tempest/workspaces/default/root_ca_certificate"                                          >  $TMP_LBSCRIPT
        echo "bosh alias-env $DNS_PREFIX -e $director_ip --ca-cert \$cert >/dev/null 2>&1"                       >> $TMP_LBSCRIPT
        echo "[ \$? -ne 0 ] && exit 1"                                                                           >> $TMP_LBSCRIPT
        echo "echo -e \"admin\n${director_cd}\" | bosh -e $DNS_PREFIX login >/dev/null 2>&1"                     >> $TMP_LBSCRIPT
        echo "[ \$? -ne 0 ] && exit 1"                                                                           >> $TMP_LBSCRIPT
        echo "bosh -e $DNS_PREFIX -d service-instance_$uid vms | egrep \"^master/\" | awk '{ print \$(NF-2) }'"  >> $TMP_LBSCRIPT

        scp -o StrictHostKeyChecking=no -qi $TMP_OPSMAN $TMP_LBSCRIPT ubuntu@${OPS_MANAGER_DNS}:/tmp/masters.sh; ret=$?
        if [ ${ret} -ne 0 ]; then
          echo "ERROR: Copying script /tmp/masters.sh to ubuntu@${OPS_MANAGER_DNS} has been failed"
          echo "       Please try manually:"
          echo "       => scp -o StrictHostKeyChecking=no -i $TMP_OPSMAN $TMP_LBSCRIPT ubuntu@${OPS_MANAGER_DNS}:/tmp/masters.sh"
          exit 1
        fi

        ssh -qi $TMP_OPSMAN ubuntu@${OPS_MANAGER_DNS} -n "bash /tmp/masters.sh" >/dev/null 2>&1; ret=$?
        if [ ${ret} -ne 0 ]; then
          echo "ERROR: executing remote-script: /tmp/masters.sh on ubuntu@${OPS_MANAGER_DNS} has been failed"
          echo "       Please try manually:"
          echo "       => ssh -i $TMP_OPSMAN ubuntu@${OPS_MANAGER_DNS} -n \"bash /tmp/masters.sh\""
          exit 1
        else
          mst=$(ssh -qi $TMP_OPSMAN ubuntu@${OPS_MANAGER_DNS} -n "bash /tmp/masters.sh" 2>/dev/null)
        fi

        ##############################################################################################
        ########################## ADD MASTER INSTANCES TO THE PKS CLUSTER ###########################
        ##############################################################################################

        aws elb --region $AWS_REGION describe-load-balancers --load-balancer-names "k8s-master-$n" > /dev/null 2>&1; ret=$?
        if [ ${ret} -eq 0 ]; then
          for ins in $mst; do
            aws elb --region $AWS_REGION register-instances-with-load-balancer \
               --load-balancer-name k8s-master-$n --instances "${ins}" > /dev/null 2>&1; ret=$?
            if [ ${ret} -ne 0 ]; then
              echo "ERROR: Register Instances"
              echo "aws elb --region $AWS_REGION register-instances-with-load-balancer \\"
              echo "  --load-balancer-name k8s-master-$n --instances $ins"
              exit 1
            fi
          done
        fi
      done
    fi

    echo "################################ EOF ################################"
    date +%s 
  else
    echo ""
    echo "ERROR: API Host: $API_HOST_NAME can not be resolved by DNS"; exit 1
  fi

  exit 0
fi

if [ "${PCFCONFIG_BASE}" == "pcfconfig-pas-debug" ]; then
  checkEnvironment 
  OPS_MANAGER_URL=https://${OPS_MANAGER_DNS}/setup
echo "debug7: USER:$USER PASS:$PASS"
  OM_LOGIN="--skip-ssl-validation --target ${OPS_MANAGER_URL} --username $USER --password $PASS"

  # GET CREDENTIALS
  TMP_JQ=/tmp/$$_jq; TMP_SEC=/tmp/$$_sec;
  $OM $OM_LOGIN curl --path /api/v0/deployed/products > $TMP_JQ 2>/dev/null; ret=$?
  if [ $ret -eq 0 ]; then
    director_ip=$($OM $OM_LOGIN curl --path /api/v0/deployed/director/manifest 2>/dev/null | \
                  jq -r '.instance_groups[].properties.director.address')
    director_cd=$($OM $OM_LOGIN curl --path /api/v0/deployed/director/credentials/uaa_admin_user_credentials 2>/dev/null | \
                  jq -r '.credential.value.password')

    prd="xxx"; i=0
    while [ "${prd}" != "null" ]; do
      prd=$(jq -r ".[$i].type" $TMP_JQ)
      if [ "${prd}" == "cf" ]; then
        inm=$(jq -r ".[$i].installation_name" $TMP_JQ)
        str="/api/v0/deployed/products/${inm}/credentials/.uaa.admin_credentials"
        $OM $OM_LOGIN curl --path ${str} > $TMP_SEC 2>/dev/null; ret=$?
        if [ $ret -eq 0 ]; then
          sec=$(jq -r '.credential.value.password' $TMP_SEC)
        else
          echo "ERROR: 1Can not connect to $OPS_MANAGER_URL"; exit 1
        fi
      fi

      let i=i+1
    done

    rm -f $$TMP_JQ
  else
    echo "ERROR: Can not connect to $OPS_MANAGER_URL"; exit 1
  fi

  ##############################################################################################
  ######################################## DEBUG INFOS #########################################
  ##############################################################################################
  TMP_OPSMAN="$(pwd)/opsman.pem"
  #API_HOST_NAME=api.pks.${DNS_PREFIX}.${DNS_SUFFIX}

  echo "-----------------------------------------------------------------------------------------------------------"
  echo "# OPSMANAGER WEB ACCESS"
  echo "http://${OPS_MANAGER_DNS}"
  echo "# OPSMANAGER CONSOLE ACCESS WITH DEBUG ENVIRONMENT"
  echo "ssh -qi $TMP_OPSMAN ubuntu@${OPS_MANAGER_DNS} "
  echo "ubuntu@${DNS_PREFIX}-ops-manager:~$ . /tmp/debug.sh"
  echo ""
  echo "# PAS WEB ACCESS CREDENTIALS - APPS MANAGER"
  echo "https://apps.sys.${DNS_PREFIX}.${DNS_SUFFIX} - ($PAS_ADMIN_USER/$PAS_ADMIN_PASS)"
  echo "# PAS CONSOLE ACCESS CREDENTIALS"

  TLS_CUSTOMER_CERT=$(echo | openssl s_client -connect api.sys.${DNS_PREFIX}.${DNS_SUFFIX}:443 2> /dev/null | \
     grep "Verify return code:" | grep -c "self signed")

  if [ "${TLS_CUSTOMER_CERT}" -eq 0 ]; then
    echo "cf login --skip-ssl-validation -a api.sys.${DNS_PREFIX}.${DNS_SUFFIX} -u admin -p $sec -s system"
    echo "cf login --skip-ssl-validation -a api.sys.${DNS_PREFIX}.${DNS_SUFFIX} -u $PAS_ADMIN_USER -p $PAS_ADMIN_PASS"
    echo "cf target -o pivotal -s demo"
    echo ""
  else
    echo "cf login -a api.sys.${DNS_PREFIX}.${DNS_SUFFIX} -u admin -p $sec -s system"
    echo "cf login -a api.sys.${DNS_PREFIX}.${DNS_SUFFIX} -u $PAS_ADMIN_USER -p $PAS_ADMIN_PASS"
    echo "cf target -o pivotal -s demo"
  fi
fi

if [ "${PCFCONFIG_BASE}" == "pcfconfig-pks-debug" ]; then
  checkEnvironment
  ERRAFORM_VARS=terraform.tfvars
  TERRAFORM_TFSTATE=terraform.tfstate

  ##############################################################################################
  ######################################## DEBUG INFOS #########################################
  ##############################################################################################
  TMP_OPSMAN="$(pwd)/opsman.pem"
  #API_HOST_NAME=api.pks.${DNS_PREFIX}.${DNS_SUFFIX}

  echo "-----------------------------------------------------------------------------------------------------------"
  echo "# OPSMANAGER ACCESS WITH DEBUG ENVIRONMENT"
  echo "ssh -qi $TMP_OPSMAN ubuntu@${OPS_MANAGER_DNS} "
  echo "ubuntu@${DNS_PREFIX}-ops-manager:~$ . /tmp/debug.sh"
  echo ""
  echo "# PKS ACCESS CREDENTIALS"
  echo "pks login -u ${PKS_ADMIN_USER} -p ${PKS_ADMIN_PASS} -a ${API_HOST_NAME} --skip-ssl-validation"
  echo ""

  i=1
  while [ $i -lt 10 ]; do
    pks login -u ${PKS_ADMIN_USER} -p ${PKS_ADMIN_PASS} -a ${API_HOST_NAME} --skip-ssl-validation > /dev/null 2>&1
    if [ $? -eq 0 ]; then break; fi
    let i=i+1; sleep 10
  done

  for cluster in $PKS_CLUSTER_1_NAME $PKS_CLUSTER_2_NAME $PKS_CLUSTER_3_NAME; do
    pks get-credentials $cluster > /dev/null 2>&1
    userid=$(kubectl config view -o jsonpath="{.contexts[?(@.name == \"$cluster\")].context.user}")
    token=$(kubectl describe secret $(kubectl get secret | grep $userid | awk '{print $1}') | grep "token:" | awk '{ print $2 }')

    kubectl config use-context $cluster > /dev/null 2>&1
    kubectl create clusterrolebinding add-on-cluster-admin --clusterrole=cluster-admin --serviceaccount=kube-system:default > /dev/null 2>&1

    cnt=$(kubectl get namespace | egrep -c "^ingress ")

    if [ $cnt -eq 0 ]; then
      HELM=$(which helm)
      if [ ! -x "$HELM" ]; then
        echo "ERROR: unable to find the helm utility"
        exit 1
      fi

      # --- INSTALLING HELM ---
      helm init --history-max 200 > /dev/null 2>&1
      helm repo update > /dev/null 2>&1
      kubectl apply -f $PCFCONFIG_PATH/demos/k8s-helm/rbac-config.yaml > /dev/null 2>&1
      helm init --service-account tiller > /dev/null 2>&1
      sleep 30
      helm install stable/nginx-ingress \
  	--name nginx \
  	--set rbac.create=true \
  	--namespace ingress \
  	--set controller.config.proxy-buffer-size=16k > /dev/null 2>&1
      if [ $? -ne 0 ]; then 
        echo "ERROR: failed to deploy ingress controller with helm"
        echo "       => helm install stable/nginx-ingress --name nginx --set rbac.create=true \\"
        echo "          --namespace ingress --set controller.config.proxy-buffer-size=16k"
        exit 1
      fi
    fi

    DNSLB="pending"
    while [ "${DNSLB}" == "pending" -o "${DNSLB}" == "<pending>" ]; do
      sleep 10
      DNSLB=$(kubectl get svc -n ingress | grep nginx-nginx-ingress-controller | awk '{ print $4 }')
    done

    if [ "${DNSLB}" == "" ]; then
      echo "ERROR: optaining name/ip of Ingress Controller"
      echo "       => kubectl get svc -n ingress | grep nginx-nginx-ingress-controller"
      exit 1
    fi

    if [ "${PCF_CLOUD_NAME}" == "aws" ]; then
      AWS_ID=$(echo $DNSLB | awk -F '-' '{ print $1 }')
      AWS_LB="k8s-master-$cluster"
      AWS_SG=$(aws elb --region $AWS_REGION describe-load-balancers --load-balancer-names $AWS_ID | \
               jq -r '.LoadBalancerDescriptions[].SecurityGroups[]') 
      AWS_VP=$(aws elb --region $AWS_REGION describe-load-balancers --load-balancer-names $AWS_ID | \
               jq -r '.LoadBalancerDescriptions[].VPCId') 

      cnt=$(echo "${AWS_SG}" | egrep -c "$AWS_SG_NEW") 
      if [ $cnt -eq 0 ]; then 
        a=1
      fi
    fi

    if [ "${PCF_CLOUD_NAME}" == "azure" ]; then
      DNS_NAME="*.apps-${cluster}"
      echo "Create DNS Entry for *.apps.${cluster}.${DNS_PREFIX}.${DNS_SUFFIX}:"

      az network dns record-set a show -g $DNS_PREFIX -z ${DNS_PREFIX}.${DNS_SUFFIX} -n $DNS_NAME > /dev/null 2>&1
      if [ $? -eq 0 ]; then
        az network dns record-set a remove-record -g $DNS_PREFIX -z ${DNS_PREFIX}.${DNS_SUFFIX} -n $DNS_NAME > /dev/null 2>&1
        if [ $? -ne 0 ]; then
          echo "ERROR: failed to delete DNS record-set for $DNS_NAME"
          echo "       => az network dns remove-set a add-record -g $DNS_PREFIX \\"
          echo "          -z ${DNS_PREFIX}.${DNS_SUFFIX} -n $DNS_NAME"
          exit 1
        fi
      fi

      az network dns record-set a add-record -g $DNS_PREFIX -z "${DNS_PREFIX}.${DNS_SUFFIX}" \
          -n "$DNS_NAME" --ipv4-address $DNSLB > /dev/null 2>&1
      if [ $? -ne 0 ]; then
        echo "ERROR: failed to create DNS record-set for $DNS_NAME"
        echo "       => az network dns record-set a add-record -g $DNS_PREFIX \\"
        echo "          -z ${DNS_PREFIX}.${DNS_SUFFIX} -n $DNS_NAME --ipv4-address $DNSLB"
        exit 1
      fi
    fi

    if [ "${ROUTE53_TOKEN}" != "" -a "${TF_DEPLOYMENT}" == "aws" ]; then
      echo "Create DNS Entry for *.apps-${cluster}.${DNS_PREFIX}.${DNS_SUFFIX}:"

      ZONE_ID=$(aws route53 list-hosted-zones-by-name --dns-name ${DNS_PREFIX}.${DNS_SUFFIX} | jq -r '.HostedZones[0].Id')
      ZONE_ID_STR=$(echo "${ZONE_ID}" | awk -F'/' '{ print $NF }')
      DNSLB=$(aws elb --region $AWS_REGION describe-load-balancers --load-balancer-names "$AWS_ID" | \
          jq -r '.LoadBalancerDescriptions[0].DNSName')
      DNSLB_ZONEID=$(aws elb --region $AWS_REGION describe-load-balancers --load-balancer-names "$AWS_ID" | \
          jq -r '.LoadBalancerDescriptions[0].CanonicalHostedZoneNameID')

      if [ "${ZONE_ID}" != "" ]; then
        ZONE="*.${cluster}.${DNS_PREFIX}.${DNS_SUFFIX}"
        ZONE="*.apps-${cluster}.${DNS_PREFIX}.${DNS_SUFFIX}"

    cat << EOF | sed -e "s/FQHN/${ZONE}/g" -e "s/AAAA/$DNSLB/g" -e "s/ZZID/$DNSLB_ZONEID/g" > /tmp/$$_zone_record
{
            "Comment": "CREATE/DELETE/UPSERT a record ",
            "Changes": [{
            "Action": "UPSERT",
                        "ResourceRecordSet": {
                                    "Name": "FQHN.",
                                    "Type": "A",
                                    "AliasTarget": {
                                                    "HostedZoneId": "ZZID",
                                                    "DNSName": "dualstack.AAAA.",
                                                    "EvaluateTargetHealth": true
                                                }
}}]
}
EOF


        aws route53 change-resource-record-sets --hosted-zone-id ${ZONE_ID} --change-batch file:///tmp/$$_zone_record > /dev/null 2>&1
        if [ $? -ne 0 ]; then 
          echo "ERROR: failed to add DNS for $ZONE"
          echo "       => aws route53 change-resource-record-sets --hosted-zone-id ${ZONE_ID} \\"
          echo "          --change-batch file:///tmp/$$_zone_record"
          exit 1
        fi

        cp /tmp/$$_zone_record /tmp/aws_zone_record
        rm -f /tmp/$$_zone_record
      fi
    fi

    #kubectl create namespace ingress


    #kubectl delete service/kubernetes-dashboard -n kube-system
    #kubectl expose deployment.apps/kubernetes-dashboard --type=LoadBalancer --port=8080 -n kube-system

    echo "--------------------------------------------------"
    echo "PKS CLUSTER ($cluster) ACCESS CREDENTIALS"
    echo "--------------------------------------------------"
    echo "pks get-credentials $cluster"
    echo "kubectl config use-context $cluster                    # Set kubernetes context to $cluster"
    echo "kubectl create clusterrolebinding add-on-cluster-admin \\    # Get ClusterAdmin Role"
    echo "        --clusterrole=cluster-admin \\"
    echo "        --serviceaccount=kube-system:default"               
    echo "kubectl cluster-info                                        # Kubernetes Cluster Infos"
    echo "kubectl proxy                                               # To start Kubernetes Dashboard"
    echo "  => WebURL.: http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/"
    echo "  => Token..: $token"
  done

  echo ""

  exit 0
fi

# pks cluster pks-cluster-1 --json

# CLEANUP

	#aws iam list-instance-profiles
        #aws iam delete-instance-profile --instance-profile-name ppp_ops_manager
	#aws kms list-aliases --region eu-central-1
	#aws kms delete-alias --alias-name alias/ppp --region eu-central-1
        #aws elbv2 describe-target-groups --region eu-central-1

#sudo om --skip-ssl-validation --target https://pcf.azpks.pcfsdu.com/setup --username admin --password pivotal download-product --pivnet-product-slug='harbor-container-registry' --product-version='1.8.3' --output-directory=/tmp --pivnet-file-glob harbor-container-registry-1.8.3-build.2.pivotal --pivnet-api-token "f8ea72c2e1ce4cc8b9254ee6d0f37c75-r"
#om --skip-ssl-validation --target https://pcf.azpks.pcfsdu.com/setup --username admin --password pivotal upload-product --product /tmp/harbor-container-registry-1.8.3-build.2.pivotal

# sudo om --skip-ssl-validation --target https://pcf.azpks.pcfsdu.com/setup --username admin --password pivotal download-product --output-directory=/tmp --pivnet-product-slug stemcells-ubuntu-xenial --pivnet-file-glob bosh-stemcell-250.25-azure-hyperv-ubuntu-xenial-go_agent.tgz --product-version 250.25 --pivnet-api-token "f8ea72c2e1ce4cc8b9254ee6d0f37c75-r"
# om --skip-ssl-validation --target https://pcf.azpks.pcfsdu.com/setup --username admin --password pivotal upload-stemcell --stemcell  /tmp/bosh-stemcell-250.25-azure-hyperv-ubuntu-xenial-go_agent.tgz


exit
