#!/bin/bash
# ############################################################################################
# File: ........: pcfconfig-terraform / pcfconfig-opsman / pcfconfig-pks
# Language .....: bash
# Author .......: Sacha Dubois, Pivotal
# Description ..: PCF OpsManager Configuration Utility
# ############################################################################################

NODE=""
USER=""
PASS=""
DCRY=""
DEBUG=0
USAGE=0
NO_APPLY=0
NO_DOWNLOAD=0
AWS_CLI_ENABLED=0
GCP_CLI_ENABLED=0
AZURE_CLI_ENABLED=0
MSG_SILENT=0
PIVNET_TOKEN=""
PCFCONFIG_PATH=$(dirname $0)
PCFCONFIG_BASE=$(basename $0)
ROUTE53_TOKEN=""
NOASK=0

# --- SOURCE FUNCTIONS---
. ${PCFCONFIG_PATH}/functions

# --- OPSMAN ---
OPSMAN_TEMPLATE=""

# --- PAS/PKS VARIABLES ---
OPS_UPLOAD=1
PAS_VERSION=""
PAS_SRT=0
PKS_VERSION=""
PKS_ADMIN_USER=""
PKS_ADMIN_PASS=""
PKS_ADMIN_MAIL=""
PKS_CLUSTER_1_NAME=""
PKS_CLUSTER_2_NAME=""
PKS_CLUSTER_3_NAME=""
PKS_CLUSTER_1_PLAN=""
PKS_CLUSTER_2_PLAN=""
PKS_CLUSTER_3_PLAN=""

TLS_CERTIFICATE=""
TLS_PRIVATE_KEY=""

# --- TERRAFORM ---
TERRAFORM_VARS=terraform.tfvars
TERRAFORM_TFSTATE=terraform.tfstate
TF_DEPLOYMENT=""
PCF_VERSION=""
TF_PKS_VARFILE=""
TF_PAS_VARFILE=""
TF_WORKDIR="~/workspace"
TF_PREFIX=pivotal-cf-terraforming
TF_DIR_MODE=""

echo "XXXXXXXX: $*"

##############################################################################################
############################### COMMAND-LINE ARGS PROCESSING  ################################
##############################################################################################

while [ "$1" != "" ]; do
  case $1 in
    --no-ask) NOASK=1;;
    --debug) DEBUG=1;;
    --usage) USAGE=1;;
    --noapply) NO_APPLY=1;;
    --nodownload) NO_DOWNLOAD=1;;
    -u) USER=$2; shift;;                            # PCFCONFIG-OPSMAN / PCFCONFIG-PKS/PAS
    -p) PASS=$2; shift;;                            # PCFCONFIG-OPSMAN / PCFCONFIG-PKS/PAS
    -dp) DCRY=$2; shift;;                           # PCFCONFIG-OPSMAN 
    -pt) PIVNET_TOKEN=$2; shift;;                   # PCFCONFIG-PKS
    --decryption-key) DCRY=$2; shift;;              # PCFCONFIG-OPSMAN
    --pivnet-token) PIVNET_TOKEN=$2; shift;;        # PCFCONFIG-PKS
    --pks-version) PKS_VERSION=$2; shift;;          # PCFCONFIG-PKS
    --pks-cluster-1-name) PKS_CLUSTER_1_NAME=$2; shift;; 
    --pks-cluster-1-plan) PKS_CLUSTER_1_PLAN=$2; shift;; 
    --pks-cluster-2-name) PKS_CLUSTER_2_NAME=$2; shift;; 
    --pks-cluster-2-plan) PKS_CLUSTER_2_PLAN=$2; shift;; 
    --pks-cluster-3-name) PKS_CLUSTER_3_NAME=$2; shift;; 
    --pks-cluster-3-plan) PKS_CLUSTER_3_PLAN=$2; shift;; 
    --pas-version) PAS_VERSION=$2; shift;;          # PCFCONFIG-PAS
    --pas-srt) PAS_SRT=1;;                          # PCFCONFIG-PAS
    --tls_cert) TLS_CERTIFICATE=$2; shift;;         # PCFCONFIG-PAS
    --tls_private_key) TLS_PRIVATE_KEY=$2; shift;;  # PCFCONFIG-PAS
    --pks-tfvars) TF_PKS_VARFILE=$2; shift;;        # TERRAFORM VARIABLE FILE
    --pks-admin-user) PKS_ADMIN_USER=$2; shift;;              # PCFCONFIG-PKS
    --pks-admin-pass) PKS_ADMIN_PASS=$2; shift;;                # PCFCONFIG-PKS
    --pks-admin-mail) PKS_ADMIN_MAIL=$2; shift;;                # PCFCONFIG-PKS
    --pas-tfvars) TF_PAS_VARFILE=$2; shift;;        # TERRAFORM VARIABLE FILE
    --aws-route53) ROUTE53_TOKEN=$2; shift;;        # TERRAFORM VARIABLE FILE
    --cf-version) PCF_VERSION=$2; shift;;           # PCF VERSION
    --deployment) TF_DEPLOYMENT=$2; shift;;         # TERRAFORM VARIABLE FILE
    --directory-prefix) TF_PREFIX=$2; shift;;       # DIRECTORY PREFIX
    --install-mode) TF_DIR_MODE=$2; shift;;       # DIRECTORY MODE (clean, preserve, delete)
    --opsman-template) OPSMAN_TEMPLATE=$2; shift;;  # OPSMAN TEMPLATE 
  esac
  shift
done

[ "$PKS_CLUSTER_1_NAME" == "-" ] && PKS_CLUSTER_1_NAME=""
[ "$PKS_CLUSTER_1_PLAN" == "-" ] && PKS_CLUSTER_1_PLAN=""
[ "$PKS_CLUSTER_2_NAME" == "-" ] && PKS_CLUSTER_2_NAME=""
[ "$PKS_CLUSTER_2_PLAN" == "-" ] && PKS_CLUSTER_2_PLAN=""
[ "$PKS_CLUSTER_3_NAME" == "-" ] && PKS_CLUSTER_3_NAME=""
[ "$PKS_CLUSTER_3_PLAN" == "-" ] && PKS_CLUSTER_3_PLAN=""

##############################################################################################
########################################## FUNCTIONS #########################################
##############################################################################################

echo ""
echo "PCF Configuration Utility ($PCFCONFIG_BASE)"
echo "by Sacha Dubois, Pivotal Inc,"
echo "-----------------------------------------------------------------------------------------------------------"

usage_pks_setup() {
  echo "USAGE: $PCFCONFIG_BASE [options]"
  echo "              OPTIONS: --pks-admin-user <user>          - PKS Administration User"
  echo "                       --pas-admin-pass <password>      - PKS Administration Password"
  echo "                       --pks-admin-mail <email>         - PKS Administration Email"
  echo "                       --pks-cluster-1-name <name>      - PKS Kubernetes Cluster 1 Name"
  echo "                       --pks-cluster-1-plan <name>      - PKS Kubernetes Cluster 1 Plan"
  echo "                       --pks-cluster-2-name <name>      - PKS Kubernetes Cluster 2 Name"
  echo "                       --pks-cluster-2-plan <name>      - PKS Kubernetes Cluster 2 Plan"
  echo "                       --pks-cluster-3-name <name>      - PKS Kubernetes Cluster 3 Name"
  echo "                       --pks-cluster-3-plan <name>      - PKS Kubernetes Cluster 3 Plan"
  echo "                       --debug                          - Debugging"
}

usage_terraform() {
  echo "USAGE: $PCFCONFIG_BASE [options]"
  echo "              OPTIONS: --pks-tfvars <terraform.tfvars>  - Terraform Variable File for PKS"
  echo "                       --pas-tfvars <terraform.tfvars>  - Terraform Variable File for PAS"
  echo "                       --pivnet-token <token>           - Pivnet API Token"
  echo "                       --workdir <directory>            - Working Directory (default: ~/workspace)"
  echo "                       --cf-version <version>           - PCF Version (ie. 2.4.6)"
  echo "                       --deployment <cloud-env>         - Deployment (awx, gcp or azure)"
  echo "                       --directory-prefix <prefix>      - Directory Prefix (default: pivotal-cf-terraforming)"
  echo "                       --install-mode <mode>            - Mode if Terraform target directory already exists"
  echo "                                                            => delete - remove old directory" 
  echo "                                                            => preserve - rename it to dir.YYYYMMDD"
  echo "                                                            => clean - clean from old terraform deployments"
  echo "                       --noapply                        - Do not Apply changes on OpsManager"
  echo "                       --debug                          - Debugging"
}

usage_opsman() {
  echo "USAGE: $PCFCONFIG_BASE [options]"
  echo "              OPTIONS: -u <admin>                       - OpsManager Admin User"
  echo "                       -p <admin>                       - OpsManager Admin Password"
  echo "                       --decryption-key <phrase>        - OpsManager Decryption Prhase"
  echo "                       --pivnet-token <token>           - Pivnet API Token"
  echo "                       --aws-route53 <token>            - AWS Route53 Token"
  echo "                       --opsman-template <file>         - Specify the OpsManager Template Name"
  echo "                       --terraform-directory <dir>      - Specify the Terraform Directory"
  echo "                       --terraform-mode <pks/pas>       - Specify the Terraform Mode"
  echo "                                                          => pas - Pivotal Application Platform (PAS)"
  echo "                                                          => pks - Pivotal Container Service (PKS)"
  echo "                       --debug                          - Debugging"
  echo "                       --noapply                        - Do not Apply changes on OpsManager"
}

usage_pks() {
  echo "USAGE: $PCFCONFIG_BASE [options]"
  echo "              OPTIONS: -u <admin>                 - OpsManager Amdin User"
  echo "                       -p <admin>                 - OpsManager Amdin Password"
  echo "                       --pivnet-token <token>     - Pivnet API Token"
  echo "                       --pks-version <version>    - PKS Version"
  echo "                       --aws-route53 <token>      - AWS Route53 Token"
  echo "                       --tls_cert <file>          - TLS Certificate (default self-generated)"
  echo "                       --tls_private_key <file>   - TLS Private Key (default self-generated)"
  echo "                       --debug                    - Debugging"
  echo "                       --noapply                  - Do not Apply changes on OpsManager"
  echo "                       --nodownload               - No software download from pivnet if copy local is available"
}

usage_pas() {
  echo "USAGE: $PCFCONFIG_BASE [options]"
  echo "              OPTIONS: -u <admin>                 - OpsManager Amdin User"
  echo "                       -p <admin>                 - OpsManager Amdin Password"
  echo "                       --pivnet-token <token>     - Pivnet API Token"
  echo "                       --pas-version <version>    - PAS Version"
  echo "                       --pas-srt                  - PAS Small Footprint"
  echo "                       --aws-route53 <token>      - AWS Route53 Token"
  echo "                       --debug                    - Debugging"
  echo "                       --noapply                  - Do not Apply changes on OpsManager"
  echo "                       --nodownload               - No software download from pivnet if copy local is available"
}

environmentCleanUp() {
  TFDIR="$1"

  if [ "${cloud}" == "AWS" -o "${TF_DEPLOYMENT}" == "aws" ]; then
    ENV_NAME=$(egrep "^env_name" $TFDIR/$TERRAFORM_VARS | awk '{ print $NF }' | sed 's/"//g')
    AWS_LOCATION=$(egrep "^region" $TFDIR/$TERRAFORM_VARS | awk '{ print $NF }' | sed 's/"//g')
    DNS_SUFFIX=$(egrep "^dns_suffix" $TFDIR/$TERRAFORM_VARS | awk '{ print $NF }' | sed 's/"//g')

    if [ "${ROUTE53_TOKEN}" != "" ]; then
      aws route53 list-hosted-zones-by-name --dns-name $DNS_SUFFIX --hosted-zone-id $ROUTE53_TOKEN > /dev/null 2>&1
      if [ $? -eq 0 ]; then
        ROUTE53_STAT="zone managed by route53"
      fi
    fi

    messagePrint "Cleaning up Leftover AWS Objects" "Environment: $ENV_NAME Location: $AWS_LOCATION"

    cleanRoute53
    cleanAWSenv
  fi

  if [ "${cloud}" == "GCP" -o "${TF_DEPLOYMENT}" == "gcp" ]; then
    ENV_NAME=$(egrep "^env_name" $TFDIR/$TERRAFORM_VARS | awk '{ print $NF }' | sed 's/"//g')
    GCP_REGION=$(egrep "^region" $TFDIR/$TERRAFORM_VARS | awk '{ print $NF }' | sed 's/"//g')

    messagePrint "Cleaning up Leftover GCP Objects" "Environment: $ENV_NAME Location: $GCP_REGION"
    cleanGCPenv
  fi
}

checkPKStools() {
  # --- CHECK FOR OPENSSL UTILITY ---
  OPENSSL=$(which openssl)
  if [ "${OPENSSL}" == "" ]; then
    echo ""
    echo "ERROR: please install the openssl utility"; exit 0
  else
    # --- TEST FOR WORKING OPENSSL UTILITY ---
    OPENSSL_VERSION=$($OPENSSL version 2>/dev/null); ret=$?
    if [ ${ret} -ne 0 -o "${OPENSSL_VERSION}" == "" ]; then
      echo ""
      echo "ERROR: the utility $(which openssl) does not seam to be correct"
      echo "       please install the openssl utility"; exit 0
    else
      messagePrint "checking for the openssl utility" "Installed - ${OPENSSL_VERSION}"
    fi
  fi
}

checkEnvironment() {
  # --- VERIFY TERRAFORM FILES ---
  TERRAFORM_VARS=terraform.tfvars
  TERRAFORM_TFSTATE=terraform.tfstate

  if [ -f main.tf -a -f variables.tf ]; then
    pks=$(egrep -c "module \"pks\"" main.tf)
    if [ ${pks} -gt 0 ]; then
      messagePrint "checking terraform product selection" "Pivotal Container Service (PKS)"
      product="Pivotal Container Service (PKS)"; productid=PKS
    fi

    pas=$(egrep -c "module \"pas\"" main.tf)
    if [ ${pas} -gt 0 ]; then
      messagePrint "checking terraform product selection" "Pivotal Application Service (PAS)"
      product="Pivotal Cloud Foundry"; productid=PCF
    fi

    # --- VERIFY PROVIDER ---
    CLOUD_PROVIDER=$(egrep "^provider" main.tf | head -1 | sed 's/"//g' | awk '{ print $2 }')
    case $CLOUD_PROVIDER in
      azurerm)
           messagePrint "checking terraform cloud provider" "Microsoft Azure (AZURE)"
           cloud="Azure"; PCF_CLOUD_NAME=azure
           ;;
      aws)
          messagePrint "checking terraform cloud provider" "Amazon WebServices (AWS)"
          cloud="AWS"; PCF_CLOUD_NAME=aws
          ;;
      google)
          messagePrint "checking terraform cloud provider" "Google Gloud Platform (GCP)"
          cloud="GCP"; PCF_CLOUD_NAME=gcp
          ;;
     *)
          messagePrint "checking terraform cloud provider" "Unknown Cloud Provider ($CLOUD_PROVIDER)"
          echo "ERROR: The cloud provider $CLOUD_PROVIDER is currently not supported"; exit 1
          ;;
    esac

    checkCloudCLI

    # --- TERRAFORM NOT CONFIGURED YET ---
    if [ ! -f $TERRAFORM_VARS -a ! -f $TERRAFORM_TFSTATE ]; then
      echo ""
      echo "ERROR: terraform vaiables file $TERRAFORM_VARS has not been created by now."
      echo "       Please refer to the $product documentation and follow the"
      echo "       instructions in the section: \"Installing $productid on $cloud using Terraform\""; exit 1
    fi

    # --- CHECK FO AN INITIAL RUN ---
    if [ -f $TERRAFORM_VARS -a ! -d .terraform ]; then
      echo ""
      echo "ERROR: terraform vaiables file $TERRAFORM_VARS has been created but terraform"
      echo "       has not yet been initialzed (terraform init)."
      echo "       Please refer to the $product documentation and follow the"
      echo "       instructions in the section: \"Installing $productid on $cloud using Terraform\""; exit 1
    fi

    # --- CHECK FO AN INITIAL RUN ---
    if [ -f $TERRAFORM_VARS -a -d .terraform -a ! -f plan ]; then
      echo ""
      echo "ERROR: Terraform has been initialized already but no plan has been created yet."
      echo "       Please run \"terraform plan -out=plan\" to create a plan or consult the "
      echo "       $product documentation and follow the"
      echo "       instructions in the section: \"Installing $productid on $cloud using Terraform\""; exit 1
    fi

    # --- TERRAFORM IS READY TO DEPLOY ---
    if [ -f $TERRAFORM_VARS -a -f plan -a ! -f $TERRAFORM_TFSTATE ]; then
      echo ""
      echo "ERROR: Terraform has been initialized and a plan has been deployed."
      echo "       Please run \"terraform apply 'plan'\" to deploy installation to $cloud."
      echo "       On questions please consult the $product documentation and follow the"
      echo "       instructions in the section: \"Installing $productid on $cloud using Terraform\""; exit 1
    fi

#    if [ -f $TERRAFORM_TFSTATE ]; then
#      cnt=$($JQ -r '.modules[0].outputs.ops_manager_ssh_public_key_name.value' $TERRAFORM_TFSTATE | grep -v "null" | wc -l | sed 's/ *//g')
#      if [ $cnt -eq 0 ]; then 
#        echo "ERROR: not entry found for 'ops_manager_ssh_public_key_name' in the $TERRAFORM_TFSTATE" 
#        echo "       something probably wrong with the terraform deployment"
#      fi
#    fi

    ver=`$JQ -r '.terraform_version' $TERRAFORM_TFSTATE 2>/dev/null`
    if [ "${ver}" == "" ]; then
      echo ""
      echo "ERROR: $0 $TERRAFORM_TFSTATES is not a terraform state file"; exit 1
    fi

    if [ "${cloud}" == "GCP" -a "${GCP_CLI_ENABLED}" -eq 1 ]; then
      OPSMAN_CONFIG="opsmen_gcp.yml"
      GCP_DNS_SUFFIX=$(egrep "^dns_suffix" $TERRAFORM_VARS | sed 's/"//g' | awk '{ print $NF }')
      GCP_DNS_PREFIX=$(egrep "^env_name" $TERRAFORM_VARS | sed 's/"//g' | awk '{ print $NF }')
      GCP_PROJECT_ID=$(egrep "^project" $TERRAFORM_VARS | sed 's/"//g' | awk '{ print $NF }')
      GCP_DNS_SUBDOMAIN="${GCP_DNS_PREFIX}.${GCP_DNS_SUFFIX}"
      GCP_REGION=$(egrep "^region" $TERRAFORM_VARS | sed 's/"//g' | awk '{ print $NF }')
      GCP_OPS_MANAGER_URL=$(egrep "^opsman_image_url" $TERRAFORM_VARS | sed 's/"//g' | awk '{ print $NF }')
      GCP_AVAILABILITY_ZONES=$(egrep "^zones" $TERRAFORM_VARS | \
        sed -e 's/^.*= //g' -e 's/"//g' -e 's/\[//g' -e 's/\]//g')
      OPSMAN_VERSION=$(egrep ",${GCP_OPS_MANAGER_URL}," $PCFCONFIG_PATH/files/opsman-release-notes.txt | \
        head -1 | awk -F',' '{ print $1}')
      OPSMAN_MINOR_VERSION=$(echo $OPSMAN_VERSION | awk -F'.' '{ printf("%d.%d\n", $1, $2)}')
      DNS_SUFFIX=$GCP_DNS_SUFFIX
      DNS_PREFIX=$GCP_DNS_PREFIX
      AVAILABILITY_ZONES="$(egrep "^zones" $TERRAFORM_VARS | sed -e 's/^.*\[//g' -e 's/"//g' -e 's/,//g' -e 's/\]//g')"
      AVAILABILITY_ZONE1=$(echo "${AVAILABILITY_ZONES}" | awk '{ print $1 }')
      AVAILABILITY_ZONE2=$(echo "${AVAILABILITY_ZONES}" | awk '{ print $2 }')
      AVAILABILITY_ZONE3=$(echo "${AVAILABILITY_ZONES}" | awk '{ print $3 }')

      # --- CHECK THE AVAILABILITY_ZONE ---
      for n in $AVAILABILITY_ZONE1 $AVAILABILITY_ZONE2 $AVAILABILITY_ZONE3; do
        cnt=$($GCLOUD compute zones list | grep "${GCP_REGION}" | grep -c "${n}")
        if [ $cnt -eq 0 ]; then 
          echo "ERROR: GCP Availability Region: ${GCP_REGION} does not have a Availability Zone: $n"
          echo "       => gcloud compute zones list"
          echo ""
          $GCLOUD compute zones list | egrep "NAME|$GCP_REGION" | sed 's/^/       /g'
          echo ""
          exit 1
        fi
      done

      GCP_SVC_NAME=$(sed -n '/^service_account_key/,/^SERVICE_ACCOUNT_KEY/p' $TERRAFORM_VARS | grep "client_email" | \
         sed -e 's/"//g' -e 's/,//g' | awk '{ print $NF }')
      GCP_SVC_PRJID=$(sed -n '/^service_account_key/,/^SERVICE_ACCOUNT_KEY/p' $TERRAFORM_VARS | grep "project_id" | \
         sed -e 's/"//g' -e 's/,//g' | awk '{ print $NF }')

      if [ "${GCP_PROJECT_ID}" != "${GCP_SVC_PRJID}" ]; then 
        echo "ERROR: GCP ProjectID ($GCP_PROJECT_ID) in $TERRAFORM_VARS does not match the Project ID ($GCP_SVC_PRJID)"
        echo "       in the Service Account definition"; exit 1
      fi

      echo "Verify $cloud configuration:"
      messagePrint " - GCP ServiceAccount" "$GCP_SVC_NAME"
      messagePrint " - GCP ServiceAccount ProjectID" "$GCP_SVC_PRJID"
      messagePrint " - GCP Region" "$GCP_REGION"
      messagePrint " - GCP Availability Zone" "$GCP_AVAILABILITY_ZONES"
      messagePrint " - DNS Domain Suffix" "$GCP_DNS_SUFFIX"
      messagePrint " - DNS Domain Prefix" "$GCP_DNS_PREFIX"
      messagePrint " - DNS SubDomain" "$GCP_DNS_SUBDOMAIN"
      messagePrint " - OPS Manager AMI" "$GCP_OPS_MANAGER_URL - $OPSMAN_VERSION"

      # --- TEST ACCESS TO AWS ---
      gcloud projects list > /dev/null 2>&1
      if [ $? -ne 0 ]; then
        echo "ERROR: Accessing GCP with the gcloud utility has been failed"
        exit
      fi

      echo "Verify $cloud Ops Manager instance"
      $TF output > /dev/null 2>&1; ret=$?
      if [ $ret -eq 0 ]; then
        OPS_MANAGER_DNS=$($TF output | egrep "^ops_manager_dns" | awk '{ print $NF }')
        OPS_MANAGER_PUBLIC_IP=$($TF output | egrep "^ops_manager_public_ip" | awk '{ print $NF }')
        OPS_MANAGER_PRIVATE_IP=$($TF output | egrep "ops_manager_private_ip" | awk '{ print $NF }')
        DNS_SERVERS=$(terraform output | sed -n '/^env_dns_zone_name_servers/,/]/p' | \
          sed -e 1d -e '$d' -e 's/,//g' -e 's/  *//g' -e 's/    //g' | paste -s -d " " - - - -)
        DNS1=$(echo $DNS_SERVERS | awk '{ print $1 }')
        DNS2=$(echo $DNS_SERVERS | awk '{ print $2 }')
        DNS3=$(echo $DNS_SERVERS | awk '{ print $3 }')
        DNS4=$(echo $DNS_SERVERS | awk '{ print $4 }')
      else
        OPS_MANAGER_DNS=$($JQ -r '.modules[].outputs.dns.value' $TERRAFORM_TFSTATE | grep -v null)
        OPS_MANAGER_PUBLIC_IP=$($JQ -r '.modules[].outputs.public_ip.value' $TERRAFORM_TFSTATE | grep -v null)
        OPS_MANAGER_PRIVATE_IP=$($JQ -r '.modules[].outputs.ops_manager_private_ip.value' $TERRAFORM_TFSTATE | grep -v null)
        DNS_SERVERS=$($JQ -r '.modules[].outputs.ops_manager_private_ip.value' $TERRAFORM_TFSTATE | grep -v null)

        DNS1=$($JQ -r '.modules[2].outputs.name_servers.value[0]' $TERRAFORM_TFSTATE)
        DNS2=$($JQ -r '.modules[2].outputs.name_servers.value[1]' $TERRAFORM_TFSTATE)
        DNS3=$($JQ -r '.modules[2].outputs.name_servers.value[2]' $TERRAFORM_TFSTATE)
        DNS4=$($JQ -r '.modules[2].outputs.name_servers.value[3]' $TERRAFORM_TFSTATE)
        DNS_SERVERS="${DNS1} ${DNS2} ${DNS3} ${DNS4}"
      fi

      #gcloud compute instances describe gcp-ops-manager --zone europe-west3-b
      instance_status=$(gcloud compute instances list --filter="name=('${GCP_DNS_PREFIX}-ops-manager')" | \
            grep "${GCP_DNS_PREFIX}-ops-manager" | awk '{ print $NF }')
      
      messagePrint " - Ops Manager VM Name" "${GCP_DNS_PREFIX}-ops-manager"
      messagePrint " - Ops Manager Instance" "$instance_status"
      messagePrint " - DNS Servers" "$DNS_SERVERS"
      messagePrint " - Ops Manager DNS Name" "$OPS_MANAGER_DNS"

      # --- DNS PRECHECK ---
      nslookup -timeout=10 $OPS_MANAGER_DNS 8.8.8.8 > /dev/null 2>&1; ret=$?
      if [ "${ROUTE53_TOKEN}" != "" -a $ret -ne 0 ]; then
        # --- CHECK IF ZONE RECORDS ARE AVAILABLE ---
echo "aws route53 list-hosted-zones-by-name --dns-name $DNS_SUFFIX --hosted-zone-id $ROUTE53_TOKEN"
echo gaga1
        aws route53 list-hosted-zones-by-name --dns-name $DNS_SUFFIX --hosted-zone-id $ROUTE53_TOKEN > /dev/null 2>&1
        if [ $? -eq 0 ]; then
          ROUTE53_STAT="zone managed by route53"
        else
          ROUTE53_STAT="no dns zone found"
          ROUTE53_ZONEID=""
        fi

        echo "Updating AWS Route53 DNS records:"
        messagePrint " - Validating AWS Route53 ZoneID" "$ROUTE53_TOKEN"
        messagePrint " - Validating AWS Route53 Zone: (${GCP_DNS_SUFFIX})" "$ROUTE53_STAT"
        messagePrint " - Define DNS Record for (${GCP_DNS_SUBDOMAIN})" ""
        sublen=$(echo $GCP_DNS_SUBDOMAIN | wc -c | sed 's/ *//g')

        printf "      %${sublen}s    NS     $DNS1\n" "$GCP_DNS_SUBDOMAIN"
        printf "      %${sublen}s           $DNS2\n" ""
        printf "      %${sublen}s           $DNS3\n" ""
        printf "      %${sublen}s           $DNS4\n" ""

        TMPROUTE53=/tmp/$$_tmp_route53.json
        echo "{"                                                   >  $TMPROUTE53
        echo "  \"Comment\": \"CREATE/DELETE/UPSERT a record \","  >> $TMPROUTE53
        echo "  \"Changes\": [{"                                   >> $TMPROUTE53
        echo "  \"Action\": \"UPSERT\","                           >> $TMPROUTE53
        echo "  \"ResourceRecordSet\": {"                          >> $TMPROUTE53
        echo "    \"Name\": \"${GCP_DNS_SUBDOMAIN}\","             >> $TMPROUTE53
        echo "    \"Type\": \"NS\","                               >> $TMPROUTE53
        echo "    \"TTL\": 300,"                                   >> $TMPROUTE53
        echo "    \"ResourceRecords\": [ "                         >> $TMPROUTE53
        echo "      { \"Value\": \"${DNS1}\" },"                   >> $TMPROUTE53
        echo "      { \"Value\": \"${DNS2}\" },"                   >> $TMPROUTE53
        echo "      { \"Value\": \"${DNS3}\" },"                   >> $TMPROUTE53
        echo "      { \"Value\": \"${DNS4}\" }"                    >> $TMPROUTE53
        echo "    ]"                                               >> $TMPROUTE53
        echo "}}]"                                                 >> $TMPROUTE53
        echo "}"                                                   >> $TMPROUTE53

        # --- GET AWS INSTANCE ---
        if [ $DEBUG -gt 0 ]; then
          echo "# -------------------------- DEBUGGING START -----------------------------"
          cat $TMPROUTE53
          echo "# -------------------------- DEBUGGING END -------------------------------"
        fi

        aws route53 change-resource-record-sets --hosted-zone-id $ROUTE53_TOKEN \
            --change-batch file://${TMPROUTE53} > /dev/null 2>&1
        if [ $? -eq 0 ]; then
          messagePrint " - Updating AWS Route53 Record for (${GCP_DNS_SUBDOMAIN})" "succeeded"
        else
          messagePrint " - Updating AWS Route53 Record for (${GCP_DNS_SUBDOMAIN})" "failed"
          echo "WARNING: Unable to update AWS Route53 record $GCP_DNS_SUBDOMAIN for zone $GCP_DNS_SUFFIX"
          echo "         please try manually"
        fi

echo "aws route53 change-resource-record-sets --hosted-zone-id $ROUTE53_TOKEN --change-batch file://${TMPROUTE53}"

        wait_loop 60 "Waiting for DNS records to be pushed"
      fi

      # --- CHEKING DNS ---
      echo "Validating OPS Manager DNS records ($OPS_MANAGER_DNS)"
      nslookup -timeout=10 $OPS_MANAGER_DNS 8.8.8.8 > /dev/null 2>&1; ret=$?
      if [ $ret -ne 0 ]; then 
        i=1; ret="failed"; dns_google_stat="failed"
         while [ $i -lt 10 -a ${ret} == "failed" ]; do
          sleep 10
          nslookup $OPS_MANAGER_DNS 8.8.8.8 > /dev/null 2>&1; ret=$?
          if [ $ret -eq 0 ]; then dns_google_stat="successful"; fi
          messagePrint "   => Verify DNS lookup Google (8.8.8.8)" "$dns_google_stat"
          let i=i+1
        done
      else
        messagePrint "   => Verify DNS lookup Google (8.8.8.8)" "successful"
      fi

      for n in $DNS_SERVERS; do
        nslookup $OPS_MANAGER_DNS $n > /dev/null 2>&1; ret=$?
        if [ $ret -eq 0 ]; then dns_stat="successful"; else dns_stat="failed"; fi
        messagePrint "   => Verify DNS lookup ($n)" "$dns_stat"
      done

      localdns=$(nslookup localhost | grep Server:  | awk '{ print $2 }')
      i=1; ret="failed"; dns_google_stat="failed"
       while [ $i -lt 30 -a ${ret} == "failed" ]; do
        sleep 10
        nslookup $OPS_MANAGER_DNS > /dev/null 2>&1; ret=$?
        if [ $ret -eq 0 ]; then dns_google_stat="successful"; fi
        messagePrint "   => Verify DNS lookup localhost ($localdns)" "$dns_google_stat"
        let i=i+1
      done

      messagePrint " - Ops Manager Public IP" "$OPS_MANAGER_PUBLIC_IP"
      messagePrint " - Ops Manager Private IP" "$OPS_MANAGER_PRIVATE_IP"

      if [ "${dns_google_stat}" == "failed" ]; then
        messagePrint "   Verify DNS lookup Google (8.8.8.8)" "$dns_stat"
        subdomain=$(echo $OPS_MANAGER_DNS | sed -e 's/\./<1>/' -e 's/^.*<1>//g')
        sublen=$(echo $subdomain | wc -c | sed 's/ *//g')

        echo ""
        echo "ERROR: DNS entry for $OPS_MANAGER_DNS external to AWS seams not to be working."
        echo "       Make sure you add a NS entry for your subdomain $subdomain on your DNS zone"
        echo "       for $AWS_DNS_SUFFIX."
        echo ""
        printf "      %${sublen}s    NS     $DNS1\n" "$subdomain"
        printf "      %${sublen}s           $DNS2\n" ""
        printf "      %${sublen}s           $DNS3\n" ""
        printf "      %${sublen}s           $DNS4\n" ""

        echo ""

        echo "OpsManager Name can not be resolved through DNS"
        exit 1
      else
        OPS_MANAGER=OPS_MANAGER_DNS
      fi
    fi

    if [ "${cloud}" == "AWS" -a "${AWS_CLI_ENABLED}" -eq 1 ]; then
      OPSMAN_CONFIG="opsmen_aws.yml"
      AWS_ACCESS_KEY=$(egrep "^access_key" $TERRAFORM_VARS | sed 's/"//g' | awk '{ print $NF }')
      AWS_SECRET_KEY=$(egrep "^secret_key" $TERRAFORM_VARS | sed 's/"//g' | awk '{ print $NF }')
      AWS_DNS_SUFFIX=$(egrep "^dns_suffix" $TERRAFORM_VARS | sed 's/"//g' | awk '{ print $NF }')
      AWS_DNS_PREFIX=$(egrep "^env_name" $TERRAFORM_VARS | sed 's/"//g' | awk '{ print $NF }')
      AWS_DNS_SUBDOMAIN="${AWS_DNS_PREFIX}.${AWS_DNS_SUFFIX}"
      AWS_REGION=$(egrep "^region" $TERRAFORM_VARS | sed 's/"//g' | awk '{ print $NF }')
      AWS_OPS_MANAGER_AMI=$(egrep "^ops_manager_ami" $TERRAFORM_VARS | sed 's/"//g' | awk '{ print $NF }')
      AWS_AVAILABILITY_ZONES=$(egrep "^availability_zones" $TERRAFORM_VARS | \
        sed -e 's/^.*= //g' -e 's/"//g' -e 's/\[//g' -e 's/\]//g')
      OPSMAN_VERSION=$(egrep ",${AWS_OPS_MANAGER_AMI}," $PCFCONFIG_PATH/files/opsman-release-notes.txt | \
        head -1 | awk -F',' '{ print $1}')
      OPSMAN_MINOR_VERSION=$(echo $OPSMAN_VERSION | awk -F'.' '{ printf("%d.%d\n", $1, $2)}')
      DNS_SUFFIX=$AWS_DNS_SUFFIX
      DNS_PREFIX=$AWS_DNS_PREFIX
      AVAILABILITY_ZONES="$(egrep "^availability_zones" $TERRAFORM_VARS | sed -e 's/^.*\[//g' -e 's/"//g' -e 's/,//g' -e 's/\]//g')"
      AVAILABILITY_ZONE1=$(echo "${AVAILABILITY_ZONES}" | awk '{ print $1 }') 
      AVAILABILITY_ZONE2=$(echo "${AVAILABILITY_ZONES}" | awk '{ print $2 }') 
      AVAILABILITY_ZONE3=$(echo "${AVAILABILITY_ZONES}" | awk '{ print $3 }') 

      echo "Verify $cloud configuration:"
      messagePrint " - AWS AccessKey" "$AWS_ACCESS_KEY"
      messagePrint " - AWS SecretKey" "$AWS_SECRET_KEY"
      messagePrint " - AWS Region" "$AWS_REGION"
      messagePrint " - AWS Availabilit Zone" "$AWS_AVAILABILITY_ZONES"
      messagePrint " - DNS Domain Suffix" "$AWS_DNS_SUFFIX"
      messagePrint " - DNS Domain Prefix" "$AWS_DNS_PREFIX"
      messagePrint " - DNS SubDomain" "$AWS_DNS_SUBDOMAIN"
      messagePrint " - OPS Manager AMI" "$AWS_OPS_MANAGER_AMI - $OPSMAN_VERSION"

      # --- TEST ACCESS TO AWS ---
      aws iam get-user > /dev/null 2>&1
      if [ $? -ne 0 ]; then
        echo "ERROR: Accessing AWS failed, please perform aws configure"
        exit
      fi

      echo "Verify $cloud Ops Manager instance"
      $TF output > /dev/null 2>&1; ret=$?
      if [ $ret -eq 0 ]; then 
        OPS_MANAGER_INSTANCE=$($TF output | egrep "^ops_manager_iam_instance_profile_name" | awk '{ print $NF }')
        OPS_MANAGER_DNS=$($TF output | egrep "^ops_manager_dns" | awk '{ print $NF }')
        OPS_MANAGER_PUBLIC_IP=$($TF output | egrep "^ops_manager_public_ip" | awk '{ print $NF }')
        OPS_MANAGER_PRIVATE_IP=$($TF output | egrep "ops_manager_private_ip" | awk '{ print $NF }')
        DNS_SERVERS=$(terraform output | sed -n '/^env_dns_zone_name_servers/,/]/p' | \
          sed -e 1d -e '$d' -e 's/,//g' -e 's/  *//g' -e 's/	//g' | paste -s -d " " - - - -)
        DNS1=$(echo $DNS_SERVERS | awk '{ print $1 }')
        DNS2=$(echo $DNS_SERVERS | awk '{ print $2 }')
        DNS3=$(echo $DNS_SERVERS | awk '{ print $3 }')
        DNS4=$(echo $DNS_SERVERS | awk '{ print $4 }')
      else
        OPS_MANAGER_INSTANCE=$($JQ -r '.modules[].outputs.ops_manager_iam_instance_profile_name.value' $TERRAFORM_TFSTATE | grep -v null)
        OPS_MANAGER_DNS=$($JQ -r '.modules[].outputs.dns.value' $TERRAFORM_TFSTATE | grep -v null)
        OPS_MANAGER_PUBLIC_IP=$($JQ -r '.modules[].outputs.public_ip.value' $TERRAFORM_TFSTATE | grep -v null)
        OPS_MANAGER_PRIVATE_IP=$($JQ -r '.modules[].outputs.ops_manager_private_ip.value' $TERRAFORM_TFSTATE | grep -v null)
        DNS_SERVERS=$($JQ -r '.modules[].outputs.ops_manager_private_ip.value' $TERRAFORM_TFSTATE | grep -v null)

        DNS1=$($JQ -r '.modules[2].outputs.name_servers.value[0]' $TERRAFORM_TFSTATE)
        DNS2=$($JQ -r '.modules[2].outputs.name_servers.value[1]' $TERRAFORM_TFSTATE)
        DNS3=$($JQ -r '.modules[2].outputs.name_servers.value[2]' $TERRAFORM_TFSTATE)
        DNS4=$($JQ -r '.modules[2].outputs.name_servers.value[3]' $TERRAFORM_TFSTATE)
        DNS_SERVERS="${DNS1} ${DNS2} ${DNS3} ${DNS4}"
      fi

      # --- GET AWS INSTANCE ---
      if [ $DEBUG -gt 0 ]; then
        echo "# -------------------------- DEBUGGING START -----------------------------"
        echo "aws ec2 --region $AWS_REGION describe-instances --filters 'Name=tag:Name,Values=${AWS_DNS_PREFIX}-ops-manager'"
        aws ec2 --region $AWS_REGION describe-instances --filters 'Name=tag:Name,Values=${AWS_DNS_PREFIX}-ops-manager'
        echo "# -------------------------- DEBUGGING END -------------------------------"
      fi

      OPS_MANAGER_ID=$($AWSCLI ec2 --region $AWS_REGION describe-instances \
         --filters "Name=tag:Name,Values=${AWS_DNS_PREFIX}-ops-manager" "Name=instance-state-name,Values=running"| \
         $JQ '.Reservations[0].Instances[0].InstanceId' | sed 's/"//g')

      INSTANCE_STATUS=$($AWSCLI ec2 --region $AWS_REGION describe-instance-status --instance-ids $OPS_MANAGER_ID | \
      $JQ '.InstanceStatuses[0].InstanceState.Name' | sed 's/"//g')

      messagePrint " - Ops Manager VM Name" "${AWS_DNS_PREFIX}-ops-manager"
      messagePrint " - Ops Manager Instance" "$OPS_MANAGER_ID - $INSTANCE_STATUS"
      messagePrint " - DNS Servers" "$DNS_SERVERS"
      messagePrint " - Ops Manager DNS Name" "$OPS_MANAGER_DNS"

      # --- DNS PRECHECK ---
      nslookup $OPS_MANAGER_DNS 8.8.8.8 > /dev/null 2>&1; ret=$?

      if [ "${ROUTE53_TOKEN}" != "" -a $ret -ne 0 ]; then 
        # --- CHECK IF ZONE RECORDS ARE AVAILABLE ---
        aws route53 list-hosted-zones-by-name --dns-name $AWS_DNS_SUFFIX --hosted-zone-id $ROUTE53_TOKEN > /dev/null 2>&1
        if [ $? -eq 0 ]; then 
          ROUTE53_STAT="zone managed by route53"
        else
          ROUTE53_STAT="no zone found"
          ROUTE53_ZONEID=""
        fi

        echo "Updating AWS Route53 DNS records:"
        messagePrint " - Validating AWS Route53 ZoneID" "$ROUTE53_TOKEN"
        messagePrint " - Validating AWS Route53 Zone: (${AWS_DNS_SUFFIX})" "$ROUTE53_STAT"
        messagePrint " - Define DNS Record for (${AWS_DNS_SUBDOMAIN})" ""
        sublen=$(echo $AWS_DNS_SUBDOMAIN | wc -c | sed 's/ *//g')

        printf "      %${sublen}s    NS     $DNS1\n" "$AWS_DNS_SUBDOMAIN"
        printf "      %${sublen}s           $DNS2\n" ""
        printf "      %${sublen}s           $DNS3\n" ""
        printf "      %${sublen}s           $DNS4\n" ""

        TMPROUTE53=/tmp/$$_tmp_route53.json

        echo "{"                                                   >  $TMPROUTE53
        echo "  \"Comment\": \"CREATE/DELETE/UPSERT a record \","  >> $TMPROUTE53
        echo "  \"Changes\": [{"                                   >> $TMPROUTE53
        echo "  \"Action\": \"UPSERT\","                           >> $TMPROUTE53
        echo "  \"ResourceRecordSet\": {"                          >> $TMPROUTE53
        echo "    \"Name\": \"${AWS_DNS_SUBDOMAIN}\","             >> $TMPROUTE53
        echo "    \"Type\": \"NS\","                               >> $TMPROUTE53
        echo "    \"TTL\": 300,"                                   >> $TMPROUTE53
        echo "    \"ResourceRecords\": [ "                         >> $TMPROUTE53
        echo "      { \"Value\": \"${DNS1}\" },"                   >> $TMPROUTE53
        echo "      { \"Value\": \"${DNS2}\" },"                   >> $TMPROUTE53
        echo "      { \"Value\": \"${DNS3}\" },"                   >> $TMPROUTE53
        echo "      { \"Value\": \"${DNS4}\" }"                    >> $TMPROUTE53
        echo "    ]"                                               >> $TMPROUTE53
        echo "}}]"                                                 >> $TMPROUTE53
        echo "}"                                                   >> $TMPROUTE53

        # --- GET AWS INSTANCE ---
        if [ $DEBUG -gt 0 ]; then
          echo "# -------------------------- DEBUGGING START -----------------------------"
          cat $TMPROUTE53
          echo "# -------------------------- DEBUGGING END -------------------------------"
        fi

        aws route53 change-resource-record-sets --hosted-zone-id $ROUTE53_TOKEN \
            --change-batch file://${TMPROUTE53} > /dev/null 2>&1
        if [ $? -eq 0 ]; then 
          messagePrint " - Updating AWS Route53 Record for (${AWS_DNS_SUBDOMAIN})" "succeeded"
        else
          messagePrint " - Updating AWS Route53 Record for (${AWS_DNS_SUBDOMAIN})" "failed"
          echo "WARNING: Unable to update AWS Route53 record $AWS_DNS_SUBDOMAIN for zone $AWS_DNS_SUFFIX"
          echo "         please try manually"
        fi

        wait_loop 60 "Waiting for DNS records to be pushed"
      fi

      # --- CHEKING DNS ---
      echo "Validating OPS Manager DNS records ($OPS_MANAGER_DNS)"
      i=1; ret="failed"; dns_google_stat="failed"
       while [ $i -lt 10 -a ${ret} == "failed" ]; do
        sleep 10
        nslookup $OPS_MANAGER_DNS 8.8.8.8 > /dev/null 2>&1; ret=$?
        if [ $ret -eq 0 ]; then dns_google_stat="successful"; fi
        messagePrint "   Verify DNS lookup Google (8.8.8.8)" "$dns_google_stat"
        let i=i+1
      done

      for n in $DNS_SERVERS; do
        nslookup $OPS_MANAGER_DNS $n > /dev/null 2>&1; ret=$?
        if [ $ret -eq 0 ]; then dns_stat="successful"; else dns_stat="failed"; fi
        messagePrint "   => Verify DNS lookup ($n)" "$dns_stat"
      done

      localdns=$(nslookup localhost | grep Server:  | awk '{ print $2 }')
      i=1; ret="failed"; dns_google_stat="failed"
       while [ $i -lt 30 -a ${ret} == "failed" ]; do
        sleep 10
        nslookup $OPS_MANAGER_DNS > /dev/null 2>&1; ret=$?
        if [ $ret -eq 0 ]; then dns_google_stat="successful"; fi
        messagePrint "   => Verify DNS lookup localhost ($localdns)" "$dns_google_stat"
        let i=i+1
      done

      messagePrint " - Ops Manager Public IP" "$OPS_MANAGER_PUBLIC_IP"
      messagePrint " - Ops Manager Private IP" "$OPS_MANAGER_PRIVATE_IP"

      if [ "${dns_google_stat}" == "failed" ]; then
        messagePrint "   Verify DNS lookup Google (8.8.8.8)" "$dns_stat"
        subdomain=$(echo $OPS_MANAGER_DNS | sed -e 's/\./<1>/' -e 's/^.*<1>//g')
        sublen=$(echo $subdomain | wc -c | sed 's/ *//g')

        echo ""
        echo "ERROR: DNS entry for $OPS_MANAGER_DNS external to AWS seams not to be working."
        echo "       Make sure you add a NS entry for your subdomain $subdomain on your DNS zone"
        echo "       for $AWS_DNS_SUFFIX."
        echo ""
        printf "      %${sublen}s    NS     $DNS1\n" "$subdomain"
        printf "      %${sublen}s           $DNS2\n" ""
        printf "      %${sublen}s           $DNS3\n" ""
        printf "      %${sublen}s           $DNS4\n" ""

        echo ""

        echo "OpsManager Name can not be resolved through DNS"
        while [ 1 ]; do
          echo -e "Do you want to configure the OpsManager with its ip-address $OPS_MANAGER_PUBLIC_IP instead <y/n>: \c"; read x
          if [ "$x" == "y" -o "$x" == "n" ]; then break; fi
        done

        if [ $x == "y" ]; then
          OPS_MANAGER=$OPS_MANAGER_PUBLIC_IP
        else
          echo "$0 - Programm Ended"; exit 1
        fi
      else
        OPS_MANAGER=OPS_MANAGER_DNS
      fi

#NOT WORKING WITH TWO VM's NOE 'running' and one 'rerminated'
#      if [ "${INSTANCE_STATUS}" != "running" ]; then
#        echo ""
#        echo "ERROR: OpsManager Instance: $OPS_MANAGER_ID is not in status 'running'."
#        echo "       Please manually verify status on AWS Console and start it if necessary"; exit 0
#      fi
    fi

    if [ "${cloud}" == "Azure" -a "${AZURE_CLI_ENABLED}" -eq 1 ]; then
      OPSMAN_CONFIG="ops_Imen_aws.yml"
      AZURE_SUBSCRIPTION=$(egrep "^subscription_id" $TERRAFORM_VARS | sed 's/"//g' | awk '{ print $NF }')
      AZURE_TENNENT=$(egrep "^tenant_id" $TERRAFORM_VARS | sed 's/"//g' | awk '{ print $NF }')
      AZURE_CLIENT=$(egrep "^client_id" $TERRAFORM_VARS | sed 's/"//g' | awk '{ print $NF }')
      AZURE_SECRET=$(egrep "^client_secret" $TERRAFORM_VARS | sed 's/"//g' | awk '{ print $NF }')
      AZURE_DNS_SUFFIX=$(egrep "^dns_suffix" $TERRAFORM_VARS | sed 's/"//g' | awk '{ print $NF }')
      AZURE_DNS_PREFIX=$(egrep "^env_name" $TERRAFORM_VARS | sed 's/"//g' | awk '{ print $NF }')
      AZURE_DNS_SUBDOMAIN="${AZURE_DNS_PREFIX}.${AZURE_DNS_SUFFIX}"
      AZURE_REGION=$(egrep "^location" $TERRAFORM_VARS | sed 's/"//g' | awk '{ print $NF }')
      AZURE_OPS_MANAGER_IMAGE=$(egrep "^ops_manager_image_uri" $TERRAFORM_VARS | sed 's/"//g' | awk '{ print $NF }')
      DNS_SUFFIX=$AZURE_DNS_SUFFIX
      DNS_PREFIX=$AZURE_DNS_PREFIX

      echo "Verify $cloud configuration:"
      messagePrint " - Azure SubscriptionId" "$AZURE_SUBSCRIPTION"
      messagePrint " - Azure TennandId" "$AZURE_TENNENT"
      messagePrint " - Azure ClientId" "$AZURE_CLIENT"
      messagePrint " - Azure ClientSecret" "$AZURE_SECRET"
      messagePrint " - Azure Location" "$AZURE_REGION"
      messagePrint " - DNS Domain Suffix" "$AZURE_DNS_SUFFIX"
      messagePrint " - DNS Domain Prefix" "$AZURE_DNS_PREFIX"
      messagePrint " - DNS SubDomain" "$AZURE_DNS_SUBDOMAIN"
      messagePrint " - OPS Manager Image" "$AZURE_OPS_MANAGER_IMAGE"

      # --- TEST ACCESS TO AWS ---
      az group list > /dev/null 2>&1
      if [ $? -ne 0 ]; then
        echo "ERROR: Accessing Azure failed, please perform aws configure"
        exit
      fi

      echo "Verify $cloud Ops Manager instance"
      $TF output > /dev/null 2>&1; ret=$?
      if [ $ret -eq 0 ]; then 
        OPS_MANAGER_INSTANCE="${AZURE_DNS_PREFIX}-ops-manager-vm"
        OPS_MANAGER_DNS=$($TF output | egrep "^ops_manager_dns" | awk '{ print $NF }')
        OPS_MANAGER_PUBLIC_IP=$($TF output | egrep "^ops_manager_public_ip" | awk '{ print $NF }')
        OPS_MANAGER_PRIVATE_IP=$($TF output | egrep "ops_manager_private_ip" | awk '{ print $NF }')
        DNS_SERVERS=$(terraform output | sed -n '/^env_dns_zone_name_servers/,/]/p' | \
          sed -e 1d -e '$d' -e 's/,//g' -e 's/  *//g' -e 's/    //g' | paste -s -d " " - - - -)
        DNS1=$(echo $DNS_SERVERS | awk '{ print $1 }')
        DNS2=$(echo $DNS_SERVERS | awk '{ print $2 }')
        DNS3=$(echo $DNS_SERVERS | awk '{ print $3 }')
        DNS4=$(echo $DNS_SERVERS | awk '{ print $4 }')
      else
        OPS_MANAGER_INSTANCE="${AZURE_DNS_PREFIX}-ops-manager-vm"
        OPS_MANAGER_DNS=$($JQ -r '.modules[].outputs.ops_manager_dns.value' $TERRAFORM_TFSTATE | grep -v null | sort -u)
        OPS_MANAGER_PUBLIC_IP=$($JQ -r '.modules[].outputs.ops_manager_ip.value' $TERRAFORM_TFSTATE | grep -v null | sort -u)
        OPS_MANAGER_PRIVATE_IP=$($JQ -r '.modules[].outputs.ops_manager_private_ip.value' $TERRAFORM_TFSTATE | \
          grep -v null | sort -u)
        DNS1=$($JQ -r '.modules[].outputs.dns_zone_name_servers.value[0]' $TERRAFORM_TFSTATE | grep -v null)
        DNS2=$($JQ -r '.modules[].outputs.dns_zone_name_servers.value[1]' $TERRAFORM_TFSTATE | grep -v null)
        DNS3=$($JQ -r '.modules[].outputs.dns_zone_name_servers.value[2]' $TERRAFORM_TFSTATE | grep -v null)
        DNS4=$($JQ -r '.modules[].outputs.dns_zone_name_servers.value[3]' $TERRAFORM_TFSTATE | grep -v null)
        DNS_SERVERS="${DNS1} ${DNS2} ${DNS3} ${DNS4}"
      fi

      messagePrint " - Ops Manager VM Name" "${OPS_MANAGER_INSTANCE}"
      messagePrint " - AWS DNS Servers" "$DNS_SERVERS"
      messagePrint " - Ops Manager DNS Name" "$OPS_MANAGER_DNS"

      # --- DNS PRECHECK ---
      nslookup $OPS_MANAGER_DNS 8.8.8.8 > /dev/null 2>&1; ret=$?

      #az vm show --resource-group az --name az-ops-manager-vm

      if [ "${ROUTE53_TOKEN}" != "" -a $ret -ne 0 ]; then
        # --- CHECK IF ZONE RECORDS ARE AVAILABLE ---
        aws route53 list-hosted-zones-by-name --dns-name $AZURE_DNS_SUFFIX --hosted-zone-id $ROUTE53_TOKEN > /dev/null 2>&1
        if [ $? -eq 0 ]; then
          ROUTE53_STAT="zone managed by route53"
#          ROUTE53_ZONEID=$(aws route53 list-hosted-zones-by-name --dns-name $AZURE_DNS_SUFFIX \
#                           --hosted-zone-id $ROUTE53_TOKEN | jq -r '.HostedZoneId')
#
#          i=0
#          ROUTE53_ZONES=$(aws route53 list-hosted-zones-by-name --dns-name pcfsdu.com \
#            --hosted-zone-id Z1X9T7571BMHB5 | egrep  "/hostedzone/" | sed -e 's/"//g' -e 's/,//g' | awk '{ print $NF }')
#
#          for zone in $ROUTE53_ZONES; do
#            aws route53 get-hosted-zone --id "${zone}" > /tmp/$$_route53_zone
#            name=$(jq -r '.HostedZone.Name' /tmp/$$_route53_zone)
#            if [ "${name}" = "${AZURE_DNS_SUBDOMAIN}." ]; then
#              ROUTE53_DNS1=$($(jq -r '.DelegationSet.NameServers.[0]' /tmp/$$_route53_zone))
#            fi
#          done
        else
          ROUTE53_STAT="no zone found"
          ROUTE53_ZONEID=""
        fi

        echo "Updating AWS Route53 DNS records:"
        messagePrint " - Validating AWS Route53 ZoneID" "$ROUTE53_TOKEN"
        messagePrint " - Validating AWS Route53 Zone: (${AWS_DNS_SUFFIX})" "$ROUTE53_STAT"
        messagePrint " - Define DNS Record for (${AWS_DNS_SUBDOMAIN})" ""
        sublen=$(echo $AWS_DNS_SUBDOMAIN | wc -c | sed 's/ *//g')

        printf "      %${sublen}s    NS     $DNS1\n" "$AWS_DNS_SUBDOMAIN"
        printf "      %${sublen}s           $DNS2\n" ""
        printf "      %${sublen}s           $DNS3\n" ""
        printf "      %${sublen}s           $DNS4\n" ""

        TMPROUTE53=/tmp/$$_tmp_route53.json

        echo "{"                                                   >  $TMPROUTE53
        echo "  \"Comment\": \"CREATE/DELETE/UPSERT a record \","  >> $TMPROUTE53
        echo "  \"Changes\": [{"                                   >> $TMPROUTE53
        echo "  \"Action\": \"UPSERT\","                           >> $TMPROUTE53
        echo "  \"ResourceRecordSet\": {"                          >> $TMPROUTE53
        echo "    \"Name\": \"${AZURE_DNS_SUBDOMAIN}\","           >> $TMPROUTE53
        echo "    \"Type\": \"NS\","                               >> $TMPROUTE53
        echo "    \"TTL\": 300,"                                   >> $TMPROUTE53
        echo "    \"ResourceRecords\": [ "                         >> $TMPROUTE53
        echo "      { \"Value\": \"${DNS1}\" },"                   >> $TMPROUTE53
        echo "      { \"Value\": \"${DNS2}\" },"                   >> $TMPROUTE53
        echo "      { \"Value\": \"${DNS3}\" },"                   >> $TMPROUTE53
        echo "      { \"Value\": \"${DNS4}\" }"                    >> $TMPROUTE53
        echo "    ]"                                               >> $TMPROUTE53
        echo "}}]"                                                 >> $TMPROUTE53
        echo "}"                                                   >> $TMPROUTE53

        # --- GET AZURE INSTANCE ---
        if [ $DEBUG -gt 0 ]; then
          echo "# -------------------------- DEBUGGING START -----------------------------"
          cat $TMPROUTE53
          echo "# -------------------------- DEBUGGING END -------------------------------"
        fi

        aws route53 change-resource-record-sets --hosted-zone-id $ROUTE53_TOKEN \
            --change-batch file://${TMPROUTE53} > /dev/null 2>&1
        if [ $? -eq 0 ]; then
          messagePrint " - Updating AZURE Route53 Record for (${AZURE_DNS_SUBDOMAIN})" "succeeded"
        else
          messagePrint " - Updating AZURE Route53 Record for (${AZURE_DNS_SUBDOMAIN})" "failed"
          echo "WARNING: Unable to update AWS Route53 record $AWS_DNS_SUBDOMAIN for zone $AWS_DNS_SUFFIX"
          echo "         please try manually"
        fi

        wait_loop 60 "Waiting for DNS records to be pushed"
      fi

      # --- CHEKING DNS ---
      echo "Validating OPS Manager DNS records ($OPS_MANAGER_DNS)"
      i=1; ret="failed"
       while [ $i -lt 10 -a ${ret} == "failed" ]; do
        sleep 10
        nslookup $OPS_MANAGER_DNS 8.8.8.8 > /dev/null 2>&1; ret=$?
        if [ $ret -eq 0 ]; then dns_google_stat="successful"; fi
        messagePrint "   Verify DNS lookup Google (8.8.8.8)" "$dns_google_stat"
        let i=i+1
      done

      for n in $DNS_SERVERS; do
        nslookup $OPS_MANAGER_DNS $n > /dev/null 2>&1; ret=$?
        if [ $ret -eq 0 ]; then dns_stat="successful"; else dns_stat="failed"; fi
        messagePrint "   => Verify DNS lookup ($n)" "$dns_stat"
      done

      messagePrint " - Ops Manager Public IP" "$OPS_MANAGER_PUBLIC_IP"
      messagePrint " - Ops Manager Private IP" "$OPS_MANAGER_PRIVATE_IP"

      if [ "$dns_google_stat" == "failed" ]; then
        messagePrint "   Verify DNS lookup Google (8.8.8.8)" "$dns_stat"
        subdomain=$(echo $OPS_MANAGER_DNS | sed -e 's/\./<1>/' -e 's/^.*<1>//g')
        sublen=$(echo $subdomain | wc -c | sed 's/ *//g')

        echo ""
        echo "ERROR: DNS entry for $OPS_MANAGER_DNS external to AWS seams not to be working."
        echo "       Make sure you add a NS entry for your subdomain $subdomain on your DNS zone"
        echo "       for $AWS_DNS_SUFFIX."
        echo ""
        printf "      %${sublen}s    NS     $DNS1\n" "$subdomain"
        printf "      %${sublen}s           $DNS2\n" ""
        printf "      %${sublen}s           $DNS3\n" ""
        printf "      %${sublen}s           $DNS4\n" ""

        echo ""

        echo "OpsManager Name can not be resolved through DNS"
        while [ 1 ]; do
          echo -e "Do you want to configure the OpsManager with its ip-address $OPS_MANAGER_PUBLIC_IP instead <y/n>: \c"; read x
          if [ "$x" == "y" -o "$x" == "n" ]; then break; fi
        done

        if [ $x == "y" ]; then
          OPS_MANAGER=$OPS_MANAGER_PUBLIC_IP
        else
          echo "$0 - Programm Ended"; exit 1
        fi
      else
        OPS_MANAGER=OPS_MANAGER_DNS
      fi
    fi
  else
    echo "ERROR: Please chagnge to the CF_TERRAFORM/terraforming-pks or CF_TERRAFORM/terraforming-pks"
    echo "       directory to proceede with the installation"; exit 1
  fi
}

##############################################################################################
######################################## MAIN PROGRAMM #######################################
##############################################################################################

if [ "${PCFCONFIG_BASE}" == "pcfconfig-terraform" ]; then

  if [ "${PIVNET_TOKEN}" == "" -o "${TF_WORKDIR}" == "" -o \
       "${TF_DEPLOYMENT}" == "" -o "${PCF_VERSION}" == "" ]; then
    usage_terraform
    echo ""
    echo "ERROR: $PCFCONFIG_BASE requires the options --pivnet-token <token> --workdir <directory>"
    echo "       --pks-tfvars | --pas-tfvars <terraform.tfvars> --cf-version <version>"
    echo "       --deployment <aws|gcp|azure>"; exit 1
  else
    if [ "${TF_PKS_VARFILE}" == "" -a "${TF_PAS_VARFILE}" == "" ]; then
      echo "ERROR: ether --pks-tfvars or --pas-tfvars needs to be set"; exit 1
    fi
  fi

  if [ "${TF_DIR_MODE}" != "" ]; then
    if [ "${TF_DIR_MODE}" != "delete" -a "${TF_DIR_MODE}" != "preserve" -a "${TF_DIR_MODE}" != "clean" ]; then
      echo "ERROR: --install-mode has arguments (delete or preserve or clean)"; exit 1
    fi
  fi
fi

if [ "${PCFCONFIG_BASE}" == "pcfconfig-opsman" ]; then
  if [ "${USER}" == "" -o "${PASS}" == "" -o "${DCRY}" == "" -o "${DCRY}" == "" ]; then
    usage_opsman
    echo ""
    echo "ERROR: $PCFCONFIG_BASE requires the options -u <admin> -p <admin> --decryption-key) <phrase>"; exit 1
  fi
fi

if [ "${PCFCONFIG_BASE}" == "pcfconfig-pks-setup" ]; then
  if [ "${PKS_ADMIN_USER}" == "" -o "${PKS_ADMIN_PASS}" == "" -o "${PKS_ADMIN_MAIL}" == "" ]; then
    usage_pks_setup
    echo ""
    echo "ERROR: $PCFCONFIG_BASE requires the options --pks-admin-user <user> --pks-admin-pass <pass> --pks-admin-mail <mail>"; exit 1
  fi
fi

if [ "${PCFCONFIG_BASE}" == "pcfconfig-pks" ]; then
  if [ "${USER}" == "" -o "${PASS}" == "" -o "${PIVNET_TOKEN}" == "" -o "${PKS_VERSION}" == "" ]; then
    usage_pks
    echo ""
    echo "ERROR: $PCFCONFIG_BASE requires the options -u <admin> -p <admin> --pivnet-token <token> --pks-version <version>"; exit 1
  fi
fi

checkOpsMantools
checkPKStools

if [ "${PCFCONFIG_BASE}" == "pcfconfig-terraform" ]; then
  checkCloudCLI

  OM_LOGIN="--skip-ssl-validation --target ${OPS_MANAGER_URL}"

  echo "-----------------------------------------------------------------------------------------------------------"
  echo "             PCF Version  Terraform Templates               Released    End od Support"
  echo "             ----------------------------------------------------------------------------------------------"
  for n in $(egrep -v "^#" ${PCFCONFIG_PATH}/files/terraform-release-notes.txt | \
           awk -F: '{ print $2 }' | awk -F'.' '{ printf("%s.%s\n",$1,$2) }' | sort -ur); do

    egrep ":${n}\." ${PCFCONFIG_PATH}/files/terraform-release-notes.txt | grep ":${TF_DEPLOYMENT}:" | head -3 | \
    awk -F: '{ printf("%-12s PCF-%-7s  %-33s %s  %s\n",a,$2,$4,$6,$7 ); a=""}' a="PCF ${n}"
    echo "-----------------------------------------------------------------------------------------------------------"
  done

  cnt=$(grep -c ":${PCF_VERSION}:" ${PCFCONFIG_PATH}/files/terraform-release-notes.txt)
  if [ $cnt -eq 0 ]; then
    echo "ERROR: The PCF Version (${PCF_VERSION}) is not known. Please specify one from the list above"
    exit 1
  fi

  TF_TEMPLATE_VERSION=$(egrep ":${PCF_VERSION}:${TF_DEPLOYMENT}:" ${PCFCONFIG_PATH}/files/terraform-release-notes.txt | \
    awk -F: '{ print $4 }' | awk '{ print $NF }')

  # --- DOWNLOAD TERRAFORM ---
  echo "Download Terraform Configuration"
  messagePrint " - PCF Version" "$PCF_VERSION"
  messagePrint " - Terraform Template Version" "$TF_TEMPLATE_VERSION"
  messagePrint " - Deployment Environment" "$TF_DEPLOYMENT"
  messagePrint " - Terraform Directory Prefix" "$TF_PREFIX"
  messagePrint " - Terraform Instalation Directory" "$TF_WORKDIR/${TF_PREFIX}-${TF_DEPLOYMENT}"

  if [ "$TF_PKS_VARFILE" != "" -a -f "$TF_PKS_VARFILE" ]; then
    TERRAFORM_VARS_ORIG=$TF_PKS_VARFILE
  else
    TERRAFORM_VARS_ORIG=$TF_PAS_VARFILE
  fi

  # --- CHECK OPSMANAGER VERSION ---
  opsman=$(egrep "^(ops_manager_image_uri|ops_manager_ami|opsman_image_url)" $TERRAFORM_VARS_ORIG | awk '{ print $NF }' | sed 's/"//g')
  region=$(egrep "^(region|location)" $TERRAFORM_VARS_ORIG | awk '{ print $NF }' | sed 's/"//g')
  opsmanver=$(grep "${opsman}" $PCFCONFIG_PATH/files/opsman-release-notes.txt | head -1 | awk -F',' '{ print $1 }') 
  PCF_REGION=$region

  # --- REGION FIX ---
  if [ "${TF_DEPLOYMENT}" == "gcp" ]; then
    cnt=$(echo "$region" | grep -c "europe")
    if [ $cnt -gt 0 ]; then PCF_REGION="eu"; fi
    cnt=$(echo "$region" | grep -c "asia")
    if [ $cnt -gt 0 ]; then PCF_REGION="asia"; fi
    cnt=$(echo "$region" | egrep -c "northamerica|us")
    if [ $cnt -gt 0 ]; then PCF_REGION="us"; fi
  fi

  # --- HACK FOR PIVOTAL NAMES THE AZURE LOCATIONS DIFFEREN ---
  if [ "${TF_DEPLOYMENT}" == "azure" ]; then
    case $region in
      eastus) PCF_REGION="east_us";;
      westus) PCF_REGION="west_us";;
      westeurope) PCF_REGION="west_europe";;
      southeastasia) PCF_REGION="wsoutheast_asia";;
    esac
  fi

  echo "-----------------------------------------------------------------------------------------------------------"
  echo "             OpsManager (Version/Build)  Ops-Manager Install Image          Released    End od Support"
  echo "             ----------------------------------------------------------------------------------------------"
  for n in $(egrep -v "^#" ${PCFCONFIG_PATH}/files/opsman-release-notes.txt | \
           awk -F',' '{ print $1 }' | awk -F'.' '{ printf("%s.%s\n",$1,$2) }' | sort -ur); do

    egrep "${n}\." ${PCFCONFIG_PATH}/files/opsman-release-notes.txt | egrep ",${TF_DEPLOYMENT},$PCF_REGION," | \
    head -3 | sed 's/http.*images\///g' | \
    awk -F',' '{ printf("%-12s %-7s %-18s  %-34s %s  %s\n",a,$1,$2,$5,$6,$7 ); a=""}' a="PCF ${n}"
    echo "-----------------------------------------------------------------------------------------------------------"
  done

  echo "OpsManager Information (terraform.tfvars)"
  messagePrint " - Terraform Variable File (Source)" "$TERRAFORM_VARS_ORIG"
  messagePrint " - Terraform Variable File (Local)" "$TERRAFORM_VARS"
  messagePrint " - OpsManager Image" "$opsman"
  messagePrint " - OpsManager Version" "$opsmanver"
  messagePrint " - PCF Cloud" "$TF_DEPLOYMENT"
  messagePrint " - PCF Region" "$region"

#  if [ "${TF_DEPLOYMENT}" == "azure" ]; then
#    cnt=$(echo "${opsman}" | grep -c "${region}")
#    if [ "${cnt}" -eq 0 ]; then
#      echo "WARNING: OpsManager Image will be downloaded from another location as your currect"
#      echo "         Installation region: ${region}"
#    fi
#  fi

  TF_HOME=$(eval echo "$TF_WORKDIR/${TF_PREFIX}-${TF_DEPLOYMENT}")
  idx=$(egrep ":${PCF_VERSION}:" ${PCFCONFIG_PATH}/files/terraform-release-notes.txt | \
        egrep "\-${TF_DEPLOYMENT}-" | head -1 | awk -F: '{ print $1 }')
  dat=$(egrep ":${PCF_VERSION}:" ${PCFCONFIG_PATH}/files/terraform-release-notes.txt | \
        egrep "\-${TF_DEPLOYMENT}-" | head -1 | awk -F: '{ print $5 }')

  if [ "${TF_DIR_MODE}" == "clean" -a -f $TF_HOME/RELEASE_INFO ]; then
     pcf=$(egrep "^pcf:" $TF_HOME/RELEASE_INFO | awk -F: '{ print $2 }')
     tft=$(egrep "^terraform_template:" $TF_HOME/RELEASE_INFO | awk -F: '{ print $2 }')

     if [ "${tft}" != "${TF_TEMPLATE_VERSION}" ]; then 
       echo ""
       echo "ERROR: `basename $0` --install-mode clean can not be used as different terraform templates"
       echo "       will be used (current: $TF_TEMPLATE_VERSION new: ${tft}. Use option 'preserve'"
       echo "       or 'delete' instead"; exit 1
     fi
  fi

  if [ -d $TF_HOME ]; then
    if [ $NOASK -eq 0 ]; then
      echo ""
      echo "WARNING: `basename $0` is going to overwrite the ${TF_HOME} directory"
      echo "         Be sure you have executed 'terraform destroy' first"
      while [ 1 ]; do
        echo -e "  => Do you want to proceede ? <y/n>: \c"; read x
        if [ "$x" == "y" -o "$x" == "n" ]; then break; fi
      done
  
      # --- EXIT BEFORE SOMETHIN BREAKES ---
      if [ $x == "n" ]; then
        exit 0
      fi
    fi
  fi

  # --- CHECK IF THERE IS AN EXISTING RESSOURCE GROUP ---
  if [ "${TF_DEPLOYMENT}" == "azure" ]; then
    TF_DEPLOYMENT=1
  fi

  if [ -d "${TF_HOME}" ]; then 
    if [ "${TF_DIR_MODE}" != "" ]; then 
      if [ "${TF_DIR_MODE}" == "delete" ]; then 
        messagePrint " - Deleting existing instalation Directory" "$TF_WORKDIR/${TF_PREFIX}-${TF_DEPLOYMENT}"
        rm -rf "${TF_HOME}"
      fi

      if [ "${TF_DIR_MODE}" == "preserve" ]; then 
        PRESERVE=$(date "+%Y%m%d")
        if [ -d ${TF_HOME}-${PRESERVE} ]; then 
          PRESERVE=$(date "+%Y%m%d%M%S")
        fi
        messagePrint " - Preserving old Instalation Directory" "$TF_WORKDIR/${TF_PREFIX}-${TF_DEPLOYMENT}-${PRESERVE}"
        mv "${TF_HOME}" "${TF_HOME}-${PRESERVE}"
      fi

      if [ "${TF_DIR_MODE}" == "clean" ]; then 
        messagePrint " - Target directory already exists" "Cleaning up terraform files from las run"
        for n in terraforming-pas terraforming-pks; do
          if [ -d ${TF_HOME}/${n} ]; then 
            rm -rf ${TF_HOME}/${n}/.terraform
            rm -f ${TF_HOME}/${n}/terraform.tfstate
            rm -f ${TF_HOME}/${n}/terraform.tfstate.backup
            rm -f ${TF_HOME}/${n}/plan
            rm -f ${TF_HOME}/${n}/outputs.tf
          fi
        done
      fi
    else
      echo "ERROR: Directory $TF_HOME does already exist, remove or rename it first"; exit 1  
    fi
  else
    # Directory does not exist, clean does not help here, change to delete
    TF_DIR_MODE=delete
  fi

  if [ "${TF_DIR_MODE}" != "clean" ]; then 
    rm -f /tmp/$dat
    $OM --skip-ssl-validation download-product --output-directory=/tmp --pivnet-file-glob ${dat} \
        --pivnet-product-slug "elastic-runtime" --pivnet-api-token "${PIVNET_TOKEN}" \
        --product-version "${PCF_VERSION}" > /dev/null 2>&1; ret=$?
  
    if [ $ret -ne 0 ]; then 
      $OM --skip-ssl-validation download-product --output-directory=/tmp --pivnet-file-glob ${dat} \
          --pivnet-product-slug "elastic-runtime" --pivnet-api-token "${PIVNET_TOKEN}" \
          --product-version "${PCF_VERSION}" 
      echo "ERROR: download of file: $dat has been failed"; exit 1
    else
      tmpname=$(zipinfo /tmp/${dat} | grep pivotal-cf-terraforming | head -1 | awk '{ print $NF }' | awk -F'/' '{ print $1 }')
      if [ "${tmpname}" != "" ]; then
        unzip -oq /tmp/$dat -d /tmp 
        mkdir -p $TF_HOME
        cd /tmp/${tmpname}; tar -cf - . | (cd $TF_HOME; tar -xpf -)
      else
        echo "ERROR: can not determain unzip directory from file $dat"; exit 1
      fi
    fi
  fi

  # --- PLACE RELEASE INFORMATION IN TERRAFORM DIRECTORY ---  
  echo "pcf:$PCF_VERSION"                         > $TF_HOME/RELEASE_INFO
  echo "terraform_template:$TF_TEMPLATE_VERSION" >> $TF_HOME/RELEASE_INFO
  echo "deployment:$TF_DEPLOYMENT"               >> $TF_HOME/RELEASE_INFO

  # --- VERIFY TERRAFORM FILES ---
  if [ "$TF_PKS_VARFILE" != "" ]; then
    if [ -f "$TF_PKS_VARFILE" ]; then 
      TERRAFORM_VARS=terraform.tfvars
      TERRAFORM_VARS_ORIG=$TF_PKS_VARFILE
      cp $TF_PKS_VARFILE $TF_HOME/terraforming-pks/$TERRAFORM_VARS
      messagePrint " - Placing Terraform Variable file" "$TF_HOME/terraforming-pks/$TERRAFORM_VARS"
    else
      echo "ERROR: Terraform variable file $TF_PKS_VARFILE not found"; exit 1
    fi
  fi

  # --- VERIFY TERRAFORM FILES ---
  if [ "$TF_PAS_VARFILE" != "" ]; then
    if [ -f "$TF_PAS_VARFILE" ]; then   
      TERRAFORM_VARS=terraform.tfvars
      TERRAFORM_VARS_ORIG=$TF_PKS_VARFILE
      cp $TF_PAS_VARFILE $TF_HOME/terraforming-pas/$TERRAFORM_VARS
      messagePrint " - Placing Terraform Variable file" "$TF_HOME/terraforming-pas/$TERRAFORM_VARS"
    else
      echo "ERROR: Terraform variable file $TF_PAS_VARFILE not found"; exit 1
    fi
  fi

  ##############################################################################################
  ########################################## CLEAN-UP ##########################################
  ##############################################################################################

  echo "-----------------------------------------------------------------------------------------------------------"
  if [ "$TF_PKS_VARFILE" != "" -a -f "$TF_PKS_VARFILE" ]; then
    environmentCleanUp $TF_HOME/terraforming-pks

    echo "Terraform configuration completed. Change to the terraform directory:"
    echo "=> $TF_HOME/terraforming-pks for PKS and proceed with pcfconfig-opsman" 
  else
    environmentCleanUp $TF_HOME/terraforming-pas

    echo "Terraform configuration completed. Change to the terraform directory:"
    echo "=> $TF_HOME/terraforming-pas for PAS and proceed with pcfconfig-opsman"
  fi

  exit 0
fi

# --- CHECK FOR TEMPLATE ---
if [ "${PCFCONFIG_BASE}" == "pcfconfig-opsman" ]; then

  if [ -f ./main.tf ]; then 
    cnt=$(egrep -c "module \"pas\"" ./main.tf) 
    if [ $cnt -eq 1 ]; then 
      OPSMAN_MODE=pas
    else
      OPSMAN_MODE=pks
    fi
  fi

  checkEnvironment
  if [ "$OPSMAN_TEMPLATE" != "" ]; then
    dn=$(dirname $OPSMAN_TEMPLATE)
    bn=$(basename $OPSMAN_TEMPLATE)
    cc=$(echo "$OPSMAN_TEMPLATE" | grep -c "/")

    if [ ${cc} -gt 0 ]; then
      echo "ERROR: Please copy $OPSMAN_TEMPLATE into the pcfconfig template directory"
      echo "       $PCFCONFIG_PATH/templates/${bn} and provide meta information into VERSION_OPSMAN"
      echo "       the --opsman-template should not contain any path, only the template file name"
      exit 1
    fi

    if [ -f "$PCFCONFIG_PATH/templates/${bn}" ]; then
      cnt=$(egrep -c "^${bn}:" $PCFCONFIG_PATH/templates/VERSION_OPSMAN) 
      if [ $cnt -gt 0 ]; then 
        OPSMAN_CONFIG=$PCFCONFIG_PATH/templates/${bn}
      else
        echo "ERROR: Please create for $bn an entry in the VERSION_OPSMAN file and"
        echo "       specify the meta information"
      fi
    else
      echo "ERROR: $OPSMAN_TEMPLATE needs to be placed in the $PCFCONFIG_PATH/templates directory"
      echo "       and an entry in the VERSION_OPSMAN to be created for the metadata"; exit 1
    fi
  else
    # --- DEFAULT TEMPLATE ---
    OPSMAN_TEMPLATE="opsman_${PCF_CLOUD_NAME}_${OPSMAN_MODE}.yml"
    OPSMAN_CONFIG=$PCFCONFIG_PATH/templates/opsman_${PCF_CLOUD_NAME}_${OPSMAN_MODE}.yml
    bn=$(basename $OPSMAN_TEMPLATE)
  fi

  # --- VALIDATE OPSMAN-TEMPLATE ---
  cnt=$(egrep -c "director_configuration:" $OPSMAN_CONFIG)
  if [ ${cnt} -eq 0 ]; then
    echo "ERROR: $OPSMAN_CONFIG is not a valid OpsManager configuration file"; exit 1
  fi

  # --- COLLECT METADATA ---
  cnt=$(egrep -c "director_configuration:" $OPSMAN_CONFIG)
  if [ ${cnt} -eq 0 ]; then
    echo "ERROR: $OPSMAN_CONFIG is not a valid BOSH Director configuration file"
    exit 1
  fi

  cld=$(egrep "^${bn}:" $PCFCONFIG_PATH/templates/VERSION_OPSMAN | head -1 | awk -F: '{ print $2 }') 
  ver=$(egrep "^${bn}:" $PCFCONFIG_PATH/templates/VERSION_OPSMAN | head -1 | awk -F: '{ print $3 }') 
  st1=$(egrep "^${bn}:" $PCFCONFIG_PATH/templates/VERSION_OPSMAN | head -1 | awk -F: '{ print $4 }') 
  tby=$(egrep "^${bn}:" $PCFCONFIG_PATH/templates/VERSION_OPSMAN | head -1 | awk -F: '{ print $5 }') 
  twn=$(egrep "^${bn}:" $PCFCONFIG_PATH/templates/VERSION_OPSMAN | head -1 | awk -F: '{ print $6 }') 
  des=$(egrep "^${bn}:" $PCFCONFIG_PATH/templates/VERSION_OPSMAN | head -1 | awk -F: '{ print $7 }') 

  # --- CHECK OPSMANAGER VERSION ---
  opsman=$(egrep "^(ops_manager_image_uri|ops_manager_ami|opsman_image_url)" $TERRAFORM_VARS | awk '{ print $NF }' | sed 's/"//g')
  region=$(egrep "^(region|location)" $TERRAFORM_VARS | awk '{ print $NF }' | sed 's/"//g')

  if [ "${PCF_CLOUD_NAME}" = "azure" ]; then
    #bld=$(echo "${opsman}" | sed -e 's/^.*ops-manager-//g' -e 's/\.vhd//g')
    bld=$(egrep ",${opsman}," $PCFCONFIG_PATH/files/opsman-release-notes.txt | head -1 | awk -F',' '{ print $2 }')
    ver=$(egrep ",${opsman}," $PCFCONFIG_PATH/files/opsman-release-notes.txt | head -1 | awk -F',' '{ print $1 }')
  fi

  if [ "${PCF_CLOUD_NAME}" = "gcp" ]; then
    bld=$(egrep ",${opsman}," $PCFCONFIG_PATH/files/opsman-release-notes.txt | head -1 | awk -F',' '{ print $2 }')
    ver=$(egrep ",${opsman}," $PCFCONFIG_PATH/files/opsman-release-notes.txt | head -1 | awk -F',' '{ print $1 }')
  fi

  if [ "${PCF_CLOUD_NAME}" = "aws" ]; then
    bld=$(egrep ",${opsman}," $PCFCONFIG_PATH/files/opsman-release-notes.txt | head -1 | awk -F',' '{ print $2 }')
    ver=$(egrep ",${opsman}," $PCFCONFIG_PATH/files/opsman-release-notes.txt | head -1 | awk -F',' '{ print $1 }')
  fi

  if [ "${cld}" != "${PCF_CLOUD_NAME}" ]; then
    echo "ERROR: $OPSMAN_CONFIG is according its metadata in VERSION_OPSMAN for the $cld cloud"
    echo "and not for $PCF_CLOUD_NAME"; exit 1
  fi

  echo "OpsManager Configuration Definitions ($bn)"
  messagePrint " - OpsManager Version:  " "$ver"
  messagePrint " - OpsManager Build:  " "$bld"
  messagePrint " - Template File:  " "$OPSMAN_CONFIG"
  messagePrint " - Template Status:  " "$st1"
  messagePrint " - Template Maintained by:  " "$tby"
  messagePrint " - Template Tested:  " "$twn"
  messagePrint " - Template Description:  " "$des"

  # --- COPY JQ FILES FROM THE TEMPLATES ---
  JQ_FILTER=$PCFCONFIG_PATH/filter/opsman_${PCF_CLOUD_NAME}_${OPSMAN_MODE}.jq

  if [ ! -f $JQ_FILTER ]; then 
    echo "ERROR: Filter JQ Script: $JQ_FILTER does not exist"; exit 1
  fi

  # --- GET AWS INSTANCE ---
  if [ $DEBUG -gt 0 ]; then
    echo "# -------------------------- DEBUGGING START -----------------------------"
    $JQ -e -f $JQ_FILTER $TERRAFORM_TFSTATE | sed -e 's/^"//g' -e 's/"$//g' -e 's/<1>/"/g' -e '/: $/d' -e '/""/d' | sort -u
    echo "# -------------------------- DEBUGGING END -------------------------------"
  fi

  VARFILE=./opsman_vars.yml
  echo "# GENERATED BY $0 - $(date)" > $VARFILE
  if [ "${PCF_CLOUD_NAME}" = "gcp" ]; then
    cid_inf=$($JQ -r '.modules[].outputs.infrastructure_subnet_cidr.value' $TERRAFORM_TFSTATE | \
            sed -e '/: $/d' | grep -v null | sort -u | sed -e 's/\// /g' -e 's/\./ /g')
    rng_inf=$(echo "$cid_inf" | awk '{ printf("%d.%d.%d.%d-%d.%d.%d.%s\n",$1,$2,$3,$4,$1,$2,$3,$4+4)}')
    cid_pks=$($JQ -r '.modules[].outputs.pks_subnet_cidr.value' $TERRAFORM_TFSTATE | \
            sed -e '/: $/d' | grep -v null | sort -u | sed -e 's/\// /g' -e 's/\./ /g')
    rng_pks=$(echo "$cid_pks" | awk '{ printf("%d.%d.%d.%d-%d.%d.%d.%s\n",$1,$2,$3,$4,$1,$2,$3,$4+4)}')
    cid_svc=$($JQ -r '.modules[].outputs.services_subnet_cidr.value' $TERRAFORM_TFSTATE | \
            sed -e '/: $/d' | grep -v null | sort -u | sed -e 's/\// /g' -e 's/\./ /g')
    rng_svc=$(echo "$cid_svc" | awk '{ printf("%d.%d.%d.%d-%d.%d.%d.%s\n",$1,$2,$3,$4,$1,$2,$3,$4+4)}')

    echo "infrastructure_subnet_range: ${rng_inf}"      >> $VARFILE
    echo "pks_subnet_range: ${rng_pks}"                 >> $VARFILE
    echo "services_subnet_range: ${rng_svc}"            >> $VARFILE

    # HANDLED NY THE FILTER SCRIPT
    #echo "project: $GCP_SVC_PRJID"                     >> $VARFILE
    echo "default_deployment_tag: $DNS_PREFIX"          >> $VARFILE
    echo "region: ${GCP_REGION}"                        >> $VARFILE
    
    
    sed -n '/SERVICE_ACCOUNT_KEY/,/SERVICE_ACCOUNT_KEY/p' terraform.tfvars | sed -e '1d' -e '$d' | \
    jq 'tostring' | sed 's/^/pcfconfig_service_account: /g' >> $VARFILE

    sva=$(sed -n '/SERVICE_ACCOUNT_KEY/,/SERVICE_ACCOUNT_KEY/p' terraform.tfvars | sed -e '1d' -e '$d')
    cem=$(echo $sva | jq -r '.client_email')
    echo "associated_service_account: ${cem}" >> $VARFILE
  fi

  if [ "${PCF_CLOUD_NAME}" = "aws" ]; then
    echo "access_key_id: $AWS_ACCESS_KEY"               >> $VARFILE
    echo "secret_access_key: $AWS_SECRET_KEY"           >> $VARFILE
    echo "aws-region: ${AWS_REGION}" >> $VARFILE
  fi

  if [ "${PCF_CLOUD_NAME}" = "azure" ]; then
    cid_inf=$($JQ -r '.modules[].outputs.infrastructure_subnet_cidr.value' $TERRAFORM_TFSTATE | \
            sed -e '/: $/d' | grep -v null | sort -u | sed -e 's/\// /g' -e 's/\./ /g')
    rng_inf=$(echo "$cid_inf" | awk '{ printf("%d.%d.%d.%d-%d.%d.%d.%s\n",$1,$2,$3,$4,$1,$2,$3,$4+4)}')
    cid_pks=$($JQ -r '.modules[].outputs.pks_subnet_cidr.value' $TERRAFORM_TFSTATE | \
            sed -e '/: $/d' | grep -v null | sort -u | sed -e 's/\// /g' -e 's/\./ /g')
    rng_pks=$(echo "$cid_pks" | awk '{ printf("%d.%d.%d.%d-%d.%d.%d.%s\n",$1,$2,$3,$4,$1,$2,$3,$4+4)}')
    cid_svc=$($JQ -r '.modules[].outputs.services_subnet_cidr.value' $TERRAFORM_TFSTATE | \
            sed -e '/: $/d' | grep -v null | sort -u | sed -e 's/\// /g' -e 's/\./ /g')
    rng_svc=$(echo "$cid_svc" | awk '{ printf("%d.%d.%d.%d-%d.%d.%d.%s\n",$1,$2,$3,$4,$1,$2,$3,$4+4)}')

    echo "infrastructure_subnet_range: ${rng_inf}"      >> $VARFILE
    echo "pks_subnet_range: ${rng_pks}"                 >> $VARFILE
    echo "services_subnet_range: ${rng_svc}"            >> $VARFILE

    echo "subscription_id: $AZURE_SUBSCRIPTION"         >> $VARFILE
    echo "tenant_id: $AZURE_TENNENT"                    >> $VARFILE
    echo "client_id: $AZURE_CLIENT"                     >> $VARFILE
    echo "client_secret: $AZURE_SECRET"                 >> $VARFILE
  fi

  #$JQ -e -f $JQ_FILTER $TERRAFORM_TFSTATE | sed -e 's/^"//g' -e 's/"$//g' -e 's/<1>/"/g' >> $VARFILE
  $JQ -e -f $JQ_FILTER $TERRAFORM_TFSTATE | sed -e 's/^"//g' -e 's/"$//g' -e 's/<1>/"/g' -e '/: $/d' -e '/""/d' | \
      sort -u >> $VARFILE

  # --- CONFIGURE AUTHENTICFICATION ---
  echo "Configure OpsManager Authentification"
  messagePrint " - OpsManager URL" "http://$OPS_MANAGER_DNS"
  messagePrint " - OpsManager Admin User" "$USER"
  messagePrint " - OpsManager Admin Password" "$PASS"
  messagePrint " - OpsManager Decryption Passphrase" "$PASS"

  OPS_MANAGER_URL=https://${OPS_MANAGER_DNS}/setup
  OM_LOGIN="--skip-ssl-validation --target ${OPS_MANAGER_URL}"

  echo "-----------------------------------------------------------------------------------------------------------"
  while [ 1 ]; do
    $OM $OM_LOGIN configure-authentication --username $USER --password $PASS --decryption-passphrase $PASS; ret=$?
    if [ $ret -ne 0 ]; then 
      echo "ERROR: OpsManager configure-authentication failled, try again in 60sec"
      sleep 60
    else
      break
    fi
  done
  echo "-----------------------------------------------------------------------------------------------------------"

  # --- CONFIGURE AUTHENTICFICATION ---
  echo "Configure OpsManager Parameters"
  messagePrint " - OpsManager URL" "http://$OPS_MANAGER_DNS"
  messagePrint " - OpsManager Template" "$OPSMAN_CONFIG"
  messagePrint " - OpsManager Variable File" "$VARFILE"

  # --- DO FIRST ONLY IAAS-CONFIGURATION (TWO-STEPS-REQUIRED) --
  OM_LOGIN="--skip-ssl-validation --target ${OPS_MANAGER_URL} --username admin --password pivotal"
  sed -n '1,/^#END-STAGE-1/p' $OPSMAN_CONFIG | sed '$d' > /tmp/$$_tmpcfg.yml

  pending=$($OM $OM_LOGIN pending-changes | grep "p-bosh" | awk '{ print $4 }')
  if [ "${pending}" != "unchanged" -a "${pending}" != "install" ]; then
    echo "WARNING: Your have pending changes '${pending}' for the OpsManager:"
    $OM $OM_LOGIN pending-changes

    echo ""
    echo "Applying Changes to OpsManager"
    if [ $DEBUG -gt 0 ]; then
      echo "-----------------------------------------------------------------------------------------------------------"
      $OM $OM_LOGIN apply-changes
      if [ $? -ne 0 ]; then 
        echo "ERROR: OpsManager apply changes failed, please try again"; exit 1
      fi
      echo "-----------------------------------------------------------------------------------------------------------"
    else
      $OM $OM_LOGIN apply-changes > /dev/null 2>&1
      if [ $? -ne 0 ]; then 
        echo "ERROR: OpsManager apply changes failed, please try again"; exit 1
      fi
    fi
  else
    echo "--------------------------------- CONFIGURING OPSMANAGER STAGE-1 ------------------------------------------"
    $OM $OM_LOGIN configure-director --ignore-verifier-warnings --config /tmp/$$_tmpcfg.yml --vars-file $VARFILE
    #$OM $OM_LOGIN configure-director --config /tmp/$$_tmpcfg.yml --vars-file $VARFILE
    if [ $? -ne 0 ]; then 
      echo "ERROR: OpsManager configure-direcotr failed, please try again"; exit 1
    fi

    echo "--------------------------------- CONFIGURING OPSMANAGER STAGE-2 ------------------------------------------"
echo "$OM $OM_LOGIN configure-director --ignore-verifier-warnings --config $OPSMAN_CONFIG --vars-file $VARFILE"
    $OM $OM_LOGIN configure-director --ignore-verifier-warnings --config $OPSMAN_CONFIG --vars-file $VARFILE; ret=$?
    #$OM $OM_LOGIN configure-director --config $OPSMAN_CONFIG --vars-file $VARFILE; ret=$?
    if [ $? -ne 0 ]; then 
      echo "ERROR: OpsManager configure-direcotr failed, please try again"; exit 1
    fi
    echo "-----------------------------------------------------------------------------------------------------------"

    # --- CLEANUP ---
    rm -f /tmp/$$_tmpcfg.yml

    if [ $ret -ne 0 ]; then
      echo "ERROR: Updating OpsManager via API failed"; exit 1
    fi
  
#XXX gcloud projects add-iam-policy-binding  pa-sadubois-4ecf9e2c --member=serviceAccount:pcfconfig@pa-sadubois-4ecf9e2c.iam.gserviceaccount.com --role=roles/browser

    if [ $NO_APPLY -eq 0 ]; then
      echo "Applying Changes to OpsManager"
      i=1; ret=1; 
      while [ $i -le 3 -a $ret -ne 0 ]; do
        if [ $DEBUG -gt 0 ]; then
          $OM $OM_LOGIN apply-changes; ret=$?
        else
          $OM $OM_LOGIN apply-changes > /dev/null 2>&1; ret=$?
        fi
  
        let i=i+1
      done

      if [ $ret -ne 0 ]; then 
        echo "ERROR: Applying Changes failed, try manual"
        echo "       => $OM $OM_LOGIN apply-changes "
        exit 1
      fi
    fi
  fi

  echo ""
  echo "Configuration of the OpsManager completed. You may proceede with pcfconfig-pks / pcfconfig-pas"
  exit 0
fi

if [ "${PCFCONFIG_BASE}" == "pcfconfig-pks" -o "${PCFCONFIG_BASE}" == "pcfconfig-pas" ]; then
  checkEnvironment

  OPS_MANAGER_URL=https://${OPS_MANAGER_DNS}/setup
  OM_LOGIN="--skip-ssl-validation --target ${OPS_MANAGER_URL} --username admin --password pivotal"

#  pending=$($OM $OM_LOGIN pending-changes | grep "p-bosh" | awk '{ print $4 }')
#  if [ "${pending}" != "unchanged" ]; then
#     echo "WARNING: Your have pending changes '${pending}' for the OpsManager:"
#     $OM $OM_LOGIN pending-changes
#     echo "Please run 'Apply Changes' in the OpsManager Web Interface or run pcfconfig-opsman"
#     echo "without the -noapply option"; exit 0
#  fi

  if [ "${PCF_CLOUD_NAME}" = "gcp" ]; then
    GCP_INSTANCE_OPSMAN=$(gcloud compute instances list --filter="name:${GCP_DNS_SUFFIX}-ops-manager" 2>/dev/null | \
       grep -v "NAME" | awk '{ print $NF }')
    GCP_INSTANCE_BOSH0=$(gcloud compute instances list --filter="labels:bosh-0" 2>/dev/null | \
       grep -v "NAME" | awk '{ print $1 }')
    GCP_BOSH0_INSTANCE_STATE=$(gcloud compute instances list --filter="labels:bosh-0" 2>/dev/null | \
       grep -v "NAME" | awk '{ print $NF }')
    GCP_BOSH0_INSTANCE_ZONE=$(gcloud compute instances list --filter="labels:bosh-0" 2>/dev/null | \
       grep -v "NAME" | awk '{ print $2 }')

    echo "Verify Bosh/0 Instance"
    messagePrint " - BOSH Director (Bosh/0) InstanceID" "$GCP_INSTANCE_BOSH0"
    messagePrint " - BOSH Director (Bosh/0) Zone" "$GCP_BOSH0_INSTANCE_ZONE"
    messagePrint " - BOSH Director (Bosh/0) Instance State" "$GCP_BOSH0_INSTANCE_STATE"
  fi

  if [ "${PCF_CLOUD_NAME}" = "aws" ]; then
    AWS_INSTANCE_OPSMAN=$(aws ec2 --region $AWS_REGION  describe-instances \
       --query 'Reservations[].Instances[].{id: InstanceId, tagvalue: Tags[*][?Key==`Name`].Value}' \
       --filters "Name=tag:Name,Values=${AWS_DNS_PREFIX}-ops-manager" --output text)
    AWS_INSTANCE_BOSH0=$(aws ec2 --region $AWS_REGION  describe-instances \
       --query 'Reservations[].Instances[].{id: InstanceId, tagvalue: Tags[*][?Key==`Name`].Value}' \
       --filters "Name=tag:Name,Values=bosh/0" --output text)

    AWS_BOSH0_INSTANCE_STATE=$(aws ec2 --region $AWS_REGION describe-instance-status --instance-ids $AWS_INSTANCE_BOSH0 | \
      jq -r '.InstanceStatuses[0].InstanceState.Name')
    AWS_BOSH0_SYSTEM_STATUS=$(aws ec2 --region $AWS_REGION describe-instance-status --instance-ids $AWS_INSTANCE_BOSH0 | \
      jq -r '.InstanceStatuses[0].SystemStatus.Details[0].Status')
    AWS_BOSH0_INSTANCE_STATUS=$(aws ec2 --region $AWS_REGION describe-instance-status --instance-ids $AWS_INSTANCE_BOSH0 | \
      jq -r '.InstanceStatuses[0].InstanceStatus.Details[0].Status')

    echo "Verify Bosh/0 Instance"
    messagePrint " - BOSH Director (Bosh/0) InstanceID" "$AWS_INSTANCE_BOSH0"
    messagePrint " - BOSH Director (Bosh/0) Instance State" "$AWS_BOSH0_INSTANCE_STATE"
    messagePrint " - BOSH Director (Bosh/0) Instance Status" "$AWS_BOSH0_INSTANCE_STATUS"
    messagePrint " - BOSH Director (Bosh/0) System Status" "$AWS_BOSH0_SYSTEM_STATUS"
  fi

  # --- USE OPS-MANAGER AS JUMPHOST ---
  if [ $OPS_UPLOAD -eq 1 ]; then 
    TMP_OPSMAN=/tmp/$$_opsman; TMP_OPSMAN_PUB=/tmp/$$_opsman.pub; TMP_SCRIPT=/tmp/$$_opsman.sh
    $JQ -r '.modules[].outputs.ssh_private_key.value' $TERRAFORM_TFSTATE | grep -v null >> $TMP_OPSMAN
    $JQ -r '.modules[].outputs.ops_manager_ssh_private_key.value' $TERRAFORM_TFSTATE | grep -v null >> $TMP_OPSMAN
    touch $TMP_SCRIPT
echo "XXXX TMP_OPSMAN:$TMP_OPSMAN"
    [ "$TMP_OPSMAN" != "" ] && chmod 600 $TMP_OPSMAN
    [ "$TMP_SCRIPT" != "" ] && chmod 777 $TMP_SCRIPT

#cd /usr/local/bin && wget -q -O om \
#    "$(curl -s https://api.github.com/repos/pivotal-cf/om/releases/latest \
#    |jq --raw-output '.assets[] | .browser_download_url' | grep linux)" && chmod +x om 

    echo "#!/bin/bash"                                                                                                                 >  $TMP_SCRIPT
    echo "wget -q -O - https://raw.githubusercontent.com/starkandwayne/homebrew-cf/master/public.key | apt-key add - > /dev/null 2>&1" >> $TMP_SCRIPT
    echo "echo "deb http://apt.starkandwayne.com stable main" > /etc/apt/sources.list.d/starkandwayne.list"                            >> $TMP_SCRIPT
    echo "apt-get -qq update > /dev/null 2>&1"                                                                                         >> $TMP_SCRIPT
    echo "apt-get -qq install om > /dev/null 2>&1"                                                                                     >> $TMP_SCRIPT

    # --- CLEANUP OLD ENTRIES FROM KNOWN_HOSTS FILE ---
    if [ -f ~/.ssh/known_hosts ]; then 
      sed -in "/$OPS_MANAGER_DNS/d" ~/.ssh/known_hosts 
    fi
    scp -o StrictHostKeyChecking=no -qi $TMP_OPSMAN $TMP_SCRIPT ubuntu@${OPS_MANAGER_DNS}:/tmp/om-install.sh; ret=$?
    if [ ${ret} -ne 0 ]; then 
      echo "ERROR: Copying script /tmp/om-install.sh to ubuntu@${OPS_MANAGER_DNS} has been failed"
      echo "       Please try manually:"
      echo "       => scp -o StrictHostKeyChecking=no -i $TMP_OPSMAN $TMP_SCRIPT ubuntu@${OPS_MANAGER_DNS}:/tmp/om-install.sh"
      exit 1
    fi

    ssh -qi $TMP_OPSMAN ubuntu@${OPS_MANAGER_DNS} -n "sudo /tmp/om-install.sh"; ret=$?
    if [ ${ret} -ne 0 ]; then 
      echo "ERROR: executing remote-script: /tmp/om-install.sh on ubuntu@${OPS_MANAGER_DNS} has been failed"
      echo "       Please try manually:"
      echo "       => ssh -i $TMP_OPSMAN ubuntu@${OPS_MANAGER_DNS} -n \"sudo /tmp/om-install.sh\""
      exit 1
    fi
  fi

  if [ "${PCFCONFIG_BASE}" == "pcfconfig-pks" ]; then
    echo "Looking for PKS Product Image ($PKS_VERSION)"
    PIVNET_GLOB=$(egrep ":${PKS_VERSION}" $PCFCONFIG_PATH/files/pks-release-notes.txt | egrep -v "RC|beta" | head -1 | awk -F: '{ print $NF }')
    if [ "${PIVNET_GLOB}" == "" ]; then PIVNET_GLOB="no product file found"; fi
    PIVNET_SLUG=pivotal-container-service

    # --- LOOK ID FILE IS ALREADY DOWNLOADED ---
    messagePrint " - PKS Product Version requested" "$PKS_VERSION"
    messagePrint " - PIVNET Product SLAG" "$PIVNET_SLUG"
    messagePrint " - PIVNET Product GLOB" "$PIVNET_GLOB"

    cnt=$(egrep -c ":${PKS_VERSION}:" $PCFCONFIG_PATH/files/pks-release-notes.txt)
    if [ "${cnt}" -eq 0 ]; then 
      echo ""
      echo "ERROR: The PKS Version (${PKS_VERSION}) is not known. Please choose one from the list:"
      cat $PCFCONFIG_PATH/files/pks-release-notes.txt | awk -F: '{ printf("         PKS-%-7s\n",$2)}' | sed 1d
      exit 1
    fi

    PXS_VERSION=$PKS_VERSION
  else
    if [ "${PCF_CLOUD_NAME}" == "aws" ]; then
      max_instances=$(aws ec2 describe-account-attributes --region $AWS_REGION --attribute-names max-instances | \
          jq -r '.AccountAttributes[0].AttributeValues[0].AttributeValue')
      echo "max_instances:$max_instances"

    fi

    echo "Looking for PAS Product Image ($PAS_VERSION)"
    if [ "$PAS_SRT" -eq 1 ]; then
      PAS_RELEASE_NOTES="$PCFCONFIG_PATH/files/pas-srt-release-notes.txt"
      PIVNET_SLUG=elastic-runtime
      PIVNET_SLUG_SHORT=srt
      PIVNET_SLUG_NAME="Small Footprint PAS"
    else
      PAS_RELEASE_NOTES="$PCFCONFIG_PATH/files/pas-release-notes.txt"
      PIVNET_SLUG=elastic-runtime
      PIVNET_SLUG_SHORT=cf
      PIVNET_SLUG_NAME="Pivotal Application Service"
    fi

    PIVNET_GLOB=$(egrep ":${PAS_VERSION}" $PAS_RELEASE_NOTES | awk -F: '{ print $NF }')
    if [ "${PIVNET_GLOB}" == "" ]; then PIVNET_GLOB="no product file found"; fi

    # --- LOOK ID FILE IS ALREADY DOWNLOADED ---
    messagePrint " - PAS Product Version requested" "$PAS_VERSION"
    messagePrint " - PIVNET Product Name" "$PIVNET_SLUG_NAME"
    messagePrint " - PIVNET Product GLOB" "$PIVNET_GLOB"
    messagePrint " - PIVNET Product GLOB" "$PIVNET_GLOB"

    cnt=$(egrep -c ":${PAS_VERSION}:" $PAS_RELEASE_NOTES)
    if [ "${cnt}" -eq 0 ]; then 
      echo ""
      echo "ERROR: The PAS Version (${PAS_VERSION}) is not known. Please choose one from the list:"
      cat $PAS_RELEASE_NOTES | awk -F: '{ printf("         PAS-%-7s\n",$2)}' | sed 1d
      exit 1
    fi

    PXS_VERSION=$PAS_VERSION
  fi

  # --- VERIFY IF PKS PRODUCT TILE HAS BEEN UPDLOADED ALREADY --- 
  OM_LOGIN="--skip-ssl-validation --target ${OPS_MANAGER_URL} --username admin --password pivotal"
  OPSMAN_AVAILABLE_PRODUCT=$($OM $OM_LOGIN available-products | grep "$PIVNET_SLUG" | awk '{ print $4 }')

  if [ "$OPSMAN_AVAILABLE_PRODUCT" == "" ]; then 
    if [ $OPS_UPLOAD -eq 0 ]; then 
      if [ -f "/tmp/$PIVNET_GLOB" ]; then
        messagePrint " - Verify download and caching options" "local-cache"
      else
        messagePrint " - Verify download and caching options" "download-from-pivnet"
        echo "-----------------------------------------------------------------------------------------------------------"
        $OM $OM_LOGIN download-product --output-directory=/tmp --pivnet-file-glob $PIVNET_GLOB \
          --pivnet-product-slug $PIVNET_SLUG --pivnet-api-token "${PIVNET_TOKEN}" --product-version "${PXS_VERSION}"; ret=$?
        echo "-----------------------------------------------------------------------------------------------------------"
        if [ $ret -ne 0 ]; then
          echo "ERROR: Download Product $PIVNET_GLOB failed"; exit 1 
        fi
      fi

      echo "Uploading Product Image ($PXS_VERSION)"
      messagePrint " - Product Image" "/tmp/$PIVNET_GLOB"
      ver=$($OM $OM_LOGIN available-products | grep "$PIVNET_SLUG" | awk '{ print $4 }')
      if [ "${ver}" != "" ]; then PXS_UPLOAD="${ver}"; else PXS_UPLOAD="not uploaded"; fi
      messagePrint " - Product Uplodad Status" "$PXS_UPLOAD"
    else
      messagePrint " - Verify download and caching options" "ops-manager"
      echo "if [ -f /tmp/$PIVNET_GLOB ]; then"                                                                  >  $TMP_SCRIPT
      echo "  zipinfo /tmp/$PIVNET_GLOB > /dev/null 2>&1"                                                       >> $TMP_SCRIPT
      echo "  if [ \$? -ne 0 ]; then"                                                                           >> $TMP_SCRIPT
      echo "    echo \"validation of /tmp/$PIVNET_GLOB failed\""                                                >> $TMP_SCRIPT
      echo "    rm -f /tmp/$PIVNET_GLOB"                                                                        >> $TMP_SCRIPT
      echo "  fi"                                                                                               >> $TMP_SCRIPT
      echo "fi"                                                                                                 >> $TMP_SCRIPT
      echo ""                                                                                                   >> $TMP_SCRIPT
      echo "if [ ! -f /tmp/$PIVNET_GLOB ]; then"                                                                >> $TMP_SCRIPT
      echo "  while [ 1 ]; do"                                                                                  >> $TMP_SCRIPT
      echo "    om --request-timeout=60 --skip-ssl-validation --target ${OPS_MANAGER_URL} \\"                   >> $TMP_SCRIPT
      echo "       --username admin --password pivotal \\"                                                      >> $TMP_SCRIPT
      echo "       download-product --output-directory=/tmp --pivnet-file-glob $PIVNET_GLOB \\"                 >> $TMP_SCRIPT
      echo "       --pivnet-product-slug $PIVNET_SLUG --pivnet-api-token '${PIVNET_TOKEN}' \\"                  >> $TMP_SCRIPT
      echo "       --product-version \"${PXS_VERSION}\" "                                                       >> $TMP_SCRIPT
      echo ""                                                                                                   >> $TMP_SCRIPT
      echo "    if [ \$? -eq 0 ]; then"                                                                         >> $TMP_SCRIPT
      echo "      if [ -f /tmp/$PIVNET_GLOB ]; then"                                                            >> $TMP_SCRIPT
      echo "        zipinfo /tmp/$PIVNET_GLOB > /dev/null 2>&1"                                                 >> $TMP_SCRIPT
      echo "        if [ \$? -eq 0 ]; then break; fi"                                                           >> $TMP_SCRIPT
      echo "      fi"                                                                                           >> $TMP_SCRIPT
      echo "    fi"                                                                                             >> $TMP_SCRIPT
      echo ""                                                                                                   >> $TMP_SCRIPT
      echo "  echo \"download failed, retrying\""                                                               >> $TMP_SCRIPT
      echo "  sleep 10"                                                                                         >> $TMP_SCRIPT
      echo "  done"                                                                                             >> $TMP_SCRIPT
      echo "fi"                                                                                                 >> $TMP_SCRIPT
      echo ""                                                                                                   >> $TMP_SCRIPT
      echo "om --skip-ssl-validation --target ${OPS_MANAGER_URL} --username admin --password pivotal \\"        >> $TMP_SCRIPT
      echo "   upload-product --product /tmp/$PIVNET_GLOB"                                                      >> $TMP_SCRIPT

      scp -o StrictHostKeyChecking=no -qi $TMP_OPSMAN $TMP_SCRIPT ubuntu@${OPS_MANAGER_DNS}:/tmp/om-install.sh; ret=$?
      if [ ${ret} -ne 0 ]; then
        echo "ERROR: Copying script /tmp/om-install.sh to ubuntu@${OPS_MANAGER_DNS} has been failed"
        echo "       Please try manually:"
        echo "       => scp -o StrictHostKeyChecking=no -i $TMP_OPSMAN $TMP_SCRIPT ubuntu@${OPS_MANAGER_DNS}:/tmp/om-install.sh"
        exit 1
      fi

      echo "-----------------------------------------------------------------------------------------------------------"
      ssh -qi $TMP_OPSMAN ubuntu@${OPS_MANAGER_DNS} -n "sudo /tmp/om-install.sh"; ret=$?
      echo "-----------------------------------------------------------------------------------------------------------"
      if [ ${ret} -ne 0 ]; then
        echo "ERROR: executing remote-script: /tmp/om-install.sh on ubuntu@${OPS_MANAGER_DNS} has been failed"
        echo "       Please try manually:"
        echo "       => ssh -i $TMP_OPSMAN ubuntu@${OPS_MANAGER_DNS} -n \"sudo /tmp/om-install.sh\""
        exit 1
      fi
    fi
  fi

  if [ "${PCFCONFIG_BASE}" == "pcfconfig-pas" ]; then
    VARFILE=./pas_vars.yml; rm -rf $VARFILE; touch $VARFILE
    if [ "$PAS_SRT" -eq 1 ]; then PAS_PRODUCT="pas-srt"; else PAS_PRODUCT="pas"; fi

    # --- COPY JQ FILES FROM THE TEMPLATES ---
    PAS_MINOR_VERSION=$(echo $PAS_VERSION | awk -F'.' '{ printf("%d.%d\n", $1, $2)}')
    if [ -f $PCFCONFIG_PATH/templates/${PAS_PRODUCT}_${PCF_CLOUD_NAME}_${PAS_VERSION}.yml ]; then
      PAS_TEMPLATE=${PAS_PRODUCT}_${PCF_CLOUD_NAME}_${PAS_VERSION}.yml
    else
      PAS_TEMPLATE=${PAS_PRODUCT}_${PCF_CLOUD_NAME}_${PAS_MINOR_VERSION}.yml
    fi

    echo "Configuring PAS Tile (${PAS_VERSION})"
    messagePrint " - PAS YAML Configuration Template" "\$PCFCONFIG_PATH/templates/${PAS_TEMPLATE}"

    if [ "${TLS_CERTIFICATE}" == "" -a "${TLS_PRIVATE_KEY}" == "" ]; then
      TLS_HOST_NAME=*.pas.${DNS_PREFIX}.${DNS_SUFFIX}
      TLS_HOST_NAME="*.sys.${DNS_PREFIX}.${DNS_SUFFIX}.,*.apps.${DNS_PREFIX}.${DNS_SUFFIX}.,*.${DNS_SUFFIX}.,${DNS_SUFFIX}.,${DNS_PREFIX}.${DNS_SUFFIX}"
      TLS_HOST_NAME="*.sys.${DNS_PREFIX}.${DNS_SUFFIX},*.apps.${DNS_PREFIX}.${DNS_SUFFIX},*.${DNS_SUFFIX},${DNS_SUFFIX},${DNS_PREFIX}.${DNS_SUFFIX}"

      messagePrint " - Generating Customer TLS Certificate" "${TLS_HOST_NAME}"

      TLS_TEMP_CERT=/tmp/$$_cert
      OM_LOGIN="--skip-ssl-validation --target ${OPS_MANAGER_URL} --username admin --password pivotal"
      $OM $OM_LOGIN generate-certificate --domains $TLS_HOST_NAME > $TLS_TEMP_CERT
      if [ $? -ne 0 ]; then
        echo "ERROR: Generating Certificate for $TLS_HOST_NAME failed"; exit 1 
      fi

      TLS_CERTIFICATE=$(jq '.certificate' $TLS_TEMP_CERT)
      TLS_PRIVATE_KEY=$(jq '.key' $TLS_TEMP_CERT)
    fi

    echo "container_service_pas_tls_cert_pem: $TLS_CERTIFICATE" >> $VARFILE
    echo "container_service_pas_tls_private_key_pem: $TLS_PRIVATE_KEY" >> $VARFILE

    if [ "${PCF_CLOUD_NAME}" == "aws" ]; then
      tg1=$($JQ -r '.modules[].outputs.web_target_groups.value[0]' $TERRAFORM_TFSTATE | grep -v null | sort -u)
      tg2=$($JQ -r '.modules[].outputs.web_target_groups.value[1]' $TERRAFORM_TFSTATE | grep -v null | sort -u)
      tg3=$($JQ -r '.modules[].outputs.ssh_target_groups.value[0]' $TERRAFORM_TFSTATE | grep -v null | sort -u)
      #PAS FIX-alb LoadBalancer not working
      echo "pas_api_lb: alb:${tg1},alb:${tg2}" >> $VARFILE
      #echo "pas_api_lb: "tcp:elb-api-lb"" >> $VARFILE
      echo "web_target_group_80: alb:${tg1}" >> $VARFILE
      echo "web_target_group_443: alb:${tg2}" >> $VARFILE
      echo "ssh_target_group: alb:${tg3}" >> $VARFILE
      echo "apps_domain: apps.${DNS_PREFIX}.${DNS_SUFFIX}" >> $VARFILE
      echo "system_domain: sys.${DNS_PREFIX}.${DNS_SUFFIX}" >> $VARFILE
      echo "availability_zone_1: $AVAILABILITY_ZONE1" >> $VARFILE
      echo "availability_zone_2: $AVAILABILITY_ZONE2" >> $VARFILE
      echo "availability_zone_3: $AVAILABILITY_ZONE3" >> $VARFILE
    fi

    messagePrint " - OpsManager URL" "http://$OPS_MANAGER_DNS"
    messagePrint " - PAS Variable File" "$VARFILE"

    OPSMAN_STAGED_PRODUCT=$($OM $OM_LOGIN staged-products | grep "cf" | awk '{ print $4 }')
    if [ "${OPSMAN_STAGED_PRODUCT}" == "" ]; then
      wait_loop 10 "Waiting product to be ready to stage"

      # --- CHEKING DNS ---
      i=1; ret=1
       while [ $i -lt 10 -a ${ret} -ne 0 ]; do
        sleep 10
        OPSMAN_AVAILABLE_PRODUCT=$($OM $OM_LOGIN available-products | grep "cf" | awk '{ print $4 }')
        if [ "${OPSMAN_AVAILABLE_PRODUCT}" != "" ]; then ret=0; fi
        let i=i+1
      done

      if [ "${OPSMAN_AVAILABLE_PRODUCT}" != "" ]; then
        echo "Staging PAS Product Tile"
        messagePrint " - Staging PAS Tile:" "$OPSMAN_AVAILABLE_PRODUCT"
        echo "-----------------------------------------------------------------------------------------------------------"
        #$OM $OM_LOGIN stage-product --product-name elastic-runtime --product-version ${OPSMAN_AVAILABLE_PRODUCT}
        $OM $OM_LOGIN stage-product --product-name cf --product-version ${OPSMAN_AVAILABLE_PRODUCT}
        if [ $? -ne 0 ]; then
          echo "ERROR: Staging Product: cf-$TLS_HOST_NAME failed"; exit 1 
        fi
      else
        echo "ERROR: No product to stage found"; exit 0
      fi
    fi

    OPSMAN_STAGED_PRODUCT=$($OM $OM_LOGIN staged-products | grep "cf" | awk '{ print $4 }')
    if [ "${OPSMAN_STAGED_PRODUCT}" == "" ]; then
      echo "ERROR: Product cf could not be staged"; exit 0
    fi

#echo "$OM $OM_LOGIN configure-product --config $PCFCONFIG_PATH/templates/${PAS_TEMPLATE} --vars-file $VARFILE"
    echo "-----------------------------------------------------------------------------------------------------------"
    $OM $OM_LOGIN configure-product --config $PCFCONFIG_PATH/templates/${PAS_TEMPLATE} --vars-file $VARFILE
    if [ $? -ne 0 ]; then
      echo "ERROR: Configuring Product with --config $PCFCONFIG_PATH/templates/${PAS_TEMPLATE} --vars-file $VARFILE failed"; exit 1 
    fi
    echo "-----------------------------------------------------------------------------------------------------------"

#gaga PAS
    if [ "${PCF_CLOUD_NAME}" == "aws1" ]; then
      # --- CREATE ELB LOADBALANCER ---
      SUB1=$($JQ -r '.modules[].outputs.public_subnet_ids.value[0]' $TERRAFORM_TFSTATE | grep -v null | sed '/: $/d' | sort -u)
      SUB2=$($JQ -r '.modules[].outputs.public_subnet_ids.value[1]' $TERRAFORM_TFSTATE | grep -v null | sed '/: $/d' | sort -u)
      SUB3=$($JQ -r '.modules[].outputs.public_subnet_ids.value[2]' $TERRAFORM_TFSTATE | grep -v null | sed '/: $/d' | sort -u)
      SECG=$($JQ -r '.modules[].resources."aws_security_group.pks_api_lb_security_group".primary.id' $TERRAFORM_TFSTATE | \
         grep -v null | sed '/: $/d' | sort -u)

      echo "Creating ELB Loadbalancer (elb-api-lb)"
      messagePrint " - Subnet-1:" "$SUB1"
      messagePrint " - Subnet-2:" "$SUB2"
      messagePrint " - Subnet-3:" "$SUB3"
      messagePrint " - Security Group:" "$SECG"

      aws elb --region $AWS_REGION describe-load-balancers --load-balancer-names "elb-api-lb" > /dev/null 2>&1; ret=$?
      if [ ${ret} -gt 0 ]; then
        aws elb create-load-balancer --region $AWS_REGION  --load-balancer-name "elb-api-lb" \
        --listeners "Protocol=TCP,LoadBalancerPort=8443,InstanceProtocol=TCP,InstancePort=8443" \
                    "Protocol=TCP,LoadBalancerPort=9021,InstanceProtocol=TCP,InstancePort=9021" \
        --subnet $SUB1 $SUB2 $SUB3 --security-groups $SECG
      fi

      ELBDNS=$(aws elb --region $AWS_REGION describe-load-balancers --load-balancer-names "elb-api-lb" | \
          $JQ -r '.LoadBalancerDescriptions[0].DNSName')
      messagePrint " - DNS Name:" "$ELBDNS"

      #aws route53 list-hosted-zones-by-name --dns-name aws.pcfsdu.com
      #aws route53 list-resource-record-sets --hosted-zone-id "/hostedzone/Z13IRYE50CCEFL"

      # --- ROUTE53 TOKEN SPECIDIED ---
      if [ "${ROUTE53_TOKEN}" != "" ]; then 
        DNSLB=$(aws elb --region $AWS_REGION describe-load-balancers --load-balancer-names "elb-api-lb" | \
          jq -r '.LoadBalancerDescriptions[0].DNSName')
        DNSLB_ZONEID=$(aws elb --region $AWS_REGION describe-load-balancers --load-balancer-names "elb-api-lb" | \
          jq -r '.LoadBalancerDescriptions[0].CanonicalHostedZoneNameID')

        #aws route53 list-resource-record-sets --hosted-zone-id "/hostedzone/Z13IRYE50CCEFL" --query "ResourceRecordSets[?Name == 'api.pks.aws.pcfsdu.com.']" | jq -r '.[].AliasTarget.HostedZoneId'


        ZONE_ID=$(aws route53 list-hosted-zones-by-name --dns-name ${AWS_DNS_PREFIX}.${AWS_DNS_SUFFIX} | jq -r '.HostedZones[0].Id')
        ZONE_ID_STR=$(echo "${ZONE_ID}" | awk -F'/' '{ print $NF }')
        #RECORD_ID=$(aws route53 list-resource-record-sets --hosted-zone-id "${ZONE_ID}" \
        #    --query "ResourceRecordSets[?Name == '${TLS_HOST_NAME}.']" | jq -r '.[].AliasTarget.HostedZoneId')
        messagePrint " - DNS Zone (${AWS_DNS_PREFIX}.${AWS_DNS_SUFFIX}:" "zone managed by route53"
        messagePrint " - Updating Zone Record:" "$TLS_HOST_NAME" 

        if [ "${ZONE_ID}" != "" ]; then 
          list=$(echo $TLS_HOST_NAME | sed 's/,/ /g')

          for n in $list; do
    cat << EOF | sed -e "s/FQHN/$n/g" -e "s/AAAA/$DNSLB/g" -e "s/ZZID/$ZONEID/g" > /tmp/$$_zone_record
{
            "Comment": "CREATE/DELETE/UPSERT a record ",
            "Changes": [{
            "Action": "UPSERT",
                        "ResourceRecordSet": {
                                    "Name": "FQHN.",
                                    "Type": "A",
                                    "AliasTarget": {
                                                    "HostedZoneId": "ZZID",
                                                    "DNSName": "dualstack.AAAA.",
                                                    "EvaluateTargetHealth": true
                                                }
}}]
}
EOF

            echo "-----------------------------------------------------------------------------------------------------------"
            aws route53 change-resource-record-sets --hosted-zone-id "${ZONE_ID}" --change-batch file:///tmp/$$_zone_record
            echo "-----------------------------------------------------------------------------------------------------------"

            cp /tmp/$$_zone_record /tmp/aws_zone_record
            rm -f /tmp/$$_zone_record
          done
        fi

      fi
#    else
#      echo "INFO: Pleae set an alias in the DNS Record of your domain ${DNS_PREFIX}.${DNS_SUFFIX} in the record"
#      echo "      of the $TLS_HOST_NAME with ALIAS: $DNSLB"
    fi

    echo "Uploading Stemcell for PAS"
    scv=$(grep ":${PCF_CLOUD_NAME}:" $PCFCONFIG_PATH/files/stemcell-release-notes.txt | sort -t: -n -k2,2 | \
        tail -1 | awk -F: '{ print $2 }')
    scf=$(grep ":${PCF_CLOUD_NAME}:" $PCFCONFIG_PATH/files/stemcell-release-notes.txt | sort -t: -n -k2,2 | \
        tail -1 | awk -F: '{ print $5 }')
    messagePrint " - Staging Stemcel Version:" "$scv"
    messagePrint " - Staging Stemcel:" "$scf"

    echo "-----------------------------------------------------------------------------------------------------------"
    $OM $OM_LOGIN download-product --output-directory=/tmp --pivnet-product-slug stemcells-ubuntu-xenial \
      --pivnet-file-glob ${scf} --pivnet-api-token  "$PIVNET_TOKEN" --product-version ${scv}
    echo "-----------------------------------------------------------------------------------------------------------"
    $OM $OM_LOGIN upload-stemcell --stemcell /tmp/${scf}
    echo "-----------------------------------------------------------------------------------------------------------"


    if [ $NO_APPLY -eq 0 ]; then
      echo ""
      echo "Applying Changes to PAS"
      if [ $DEBUG -gt 0 ]; then
        echo "-----------------------------------------------------------------------------------------------------------"
        $OM $OM_LOGIN --request-timeout=60 apply-changes
        if [ $? -ne 0 ]; then
          echo "ERROR: Applying changes failed"; exit 1 
        fi
        echo "-----------------------------------------------------------------------------------------------------------"
      else
        $OM $OM_LOGIN --request-timeout=60 apply-changes > /dev/null 2>&1
        if [ $? -ne 0 ]; then
          echo "ERROR: Applying changes failed"; exit 1 
        fi
      fi
    fi

    echo ""
    echo "Configuration of the PAS Tile is completed."
    exit 0
  else
    VARFILE=./pks_vars.yml; rm -rf $VARFILE; touch $VARFILE

    # --- COPY JQ FILES FROM THE TEMPLATES ---
    PKS_MINOR_VERSION=$(echo $PKS_VERSION | awk -F'.' '{ printf("%d.%d\n", $1, $2)}')
    if [ -f $PCFCONFIG_PATH/templates/pks${PKS_VERSION}.jq ]; then
      PKS_TEMPLATE=pks_${PCF_CLOUD_NAME}_${PKS_VERSION}.yml
    else
      PKS_TEMPLATE=pks_${PCF_CLOUD_NAME}_${PKS_MINOR_VERSION}.yml
    fi

    echo "Configuring PKS Tile (${PKS_VERSION})"
    messagePrint " - PKS YAML Configuration Template" "\$PCFCONFIG_PATH/templates/${PKS_TEMPLATE}"

    if [ "${TLS_CERTIFICATE}" == "" -a "${TLS_PRIVATE_KEY}" == "" ]; then 
      TLS_HOST_NAME=*.pks.${DNS_PREFIX}.${DNS_SUFFIX}
      TLS_HOST_NAME=api.pks.${DNS_PREFIX}.${DNS_SUFFIX}
      messagePrint " - Generating Customer TLS Certificate" "${TLS_HOST_NAME}"

      TLS_TEMP_CERT=/tmp/$$_cert
      OM_LOGIN="--skip-ssl-validation --target ${OPS_MANAGER_URL} --username admin --password pivotal"
      $OM $OM_LOGIN generate-certificate --domains $TLS_HOST_NAME > $TLS_TEMP_CERT
      if [ $? -ne 0 ]; then
        echo "ERROR: Generating Certificate for $TLS_HOST_NAME failed"; exit 1 
      fi

      TLS_CERTIFICATE=$(jq '.certificate' $TLS_TEMP_CERT)
      TLS_PRIVATE_KEY=$(jq '.key' $TLS_TEMP_CERT)
    fi

    echo "container_service_pks_tls_cert_pem: $TLS_CERTIFICATE" >> $VARFILE
    echo "container_service_pks_tls_private_key_pem: $TLS_PRIVATE_KEY" >> $VARFILE

    $JQ -r '"pks_api_hostname: " + .modules[].outputs.domain.value' \
    $TERRAFORM_TFSTATE | sed '/: $/d' | sort -u >> $VARFILE
    $JQ -r '"pks_master_iam_instance_profile_name: " + .modules[].outputs.pks_master_iam_instance_profile_name.value' \
    $TERRAFORM_TFSTATE | sed '/: $/d' | sort -u >> $VARFILE
    $JQ -r '"pks_worker_iam_instance_profile_name: " + .modules[].outputs.pks_worker_iam_instance_profile_name.value' \
    $TERRAFORM_TFSTATE | sed '/: $/d' | sort -u >> $VARFILE
 
    if [ "${PCF_CLOUD_NAME}" == "aws" ]; then
      tg1=$($JQ -r '.modules[].outputs.pks_api_target_groups.value[0]' $TERRAFORM_TFSTATE | grep -v null | sort -u)
      tg2=$($JQ -r '.modules[].outputs.pks_api_target_groups.value[1]' $TERRAFORM_TFSTATE | grep -v null | sort -u)
      #PKS FIX-alb LoadBalancer not working
      #echo "pks_api_lb: alb:${tg1},alb:${tg2}" >> $VARFILE
      echo "pks_api_lb: "elb-api-lb"" >> $VARFILE
      echo "availability_zone_1: $AVAILABILITY_ZONE1" >> $VARFILE
      echo "availability_zone_2: $AVAILABILITY_ZONE2" >> $VARFILE
      echo "availability_zone_3: $AVAILABILITY_ZONE3" >> $VARFILE
    fi

    if [ "${PCF_CLOUD_NAME}" == "azure" ]; then
      #echo "pks_api_lb: az-pks-lb" >> $VARFILE
      echo "pks_api_lb: ${DNS_PREFIX}-pks-lb" >> $VARFILE
      #echo "pks_api_hostname: api.pks.az.pcfsdu.com/#@pivotalio.onmicrosoft.com/res" >> $VARFILE
      echo "pks_api_hostname:  api.pks.${DNS_PREFIX}.${DNS_SUFFIX}" >> $VARFILE
      echo "location: $AZURE_REGION" >> $VARFILE
      echo "resource_group_name: $DNS_PREFIX" >> $VARFILE
      $JQ -r '"network_name: " + .modules[].outputs.network_name.value' $TERRAFORM_TFSTATE | \
         sed '/: $/d' | grep -v null | sort -u >> $VARFILE
      $JQ -r '"vms_security_group: " + .modules[].outputs.bosh_deployed_vms_security_group_name.value' $TERRAFORM_TFSTATE | \
         sed '/: $/d' | grep -v null | sort -u >> $VARFILE

      echo "subscription_id: $AZURE_SUBSCRIPTION" >> $VARFILE
      echo "tenant_id: $AZURE_TENNENT" >> $VARFILE
      echo "primary_availability_set: ${DNS_PREFIX}-pks-as" >> $VARFILE

      echo "Verify $cloud configuration:"
      messagePrint " - Azure SubscriptionId" "$AZURE_SUBSCRIPTION"
      messagePrint " - Azure TennandId" "$AZURE_TENNENT"
      messagePrint " - Azure ClientId" "$AZURE_CLIENT"
      messagePrint " - Azure ClientSecret" "$AZURE_SECRET"
      messagePrint " - Azure Location" "$AZURE_REGION"
      messagePrint " - DNS Domain Suffix" "$AZURE_DNS_SUFFIX"
      messagePrint " - DNS Domain Prefix" "$AZURE_DNS_PREFIX"
      messagePrint " - DNS SubDomain" "$AZURE_DNS_SUBDOMAIN"
      messagePrint " - OPS Manager Image" "$AZURE_OPS_MANAGER_IMAGE"
    fi

#ggggg

    if [ "${PCF_CLOUD_NAME}" == "gcp" ]; then
      $JQ -r '"worker_node_service_account: " + .modules[].resources."google_service_account.pks_worker_node_service_account".primary.attributes.email' \
      $TERRAFORM_TFSTATE | sed '/: $/d' | grep -v null | sort -u >> $VARFILE
      $JQ -r '"master_node_service_account: " + .modules[].resources."google_service_account.pks_master_node_service_account".primary.attributes.email' \
      $TERRAFORM_TFSTATE | sed '/: $/d' | grep -v null | sort -u >> $VARFILE

      $JQ -r '"pks_api_hostname: " + .modules[].outputs.pks_api_endpoint.value' $TERRAFORM_TFSTATE | \
          sed '/: $/d' | grep -v null | sort -u >> $VARFILE
      $JQ -r '"network_name: " + .modules[].outputs.network_name.value' $TERRAFORM_TFSTATE | \
          sed '/: $/d' | grep -v null | sort -u >> $VARFILE
      $JQ -r '"pks_api_lb: " + .modules[].outputs.pks_lb_backend_name.value' $TERRAFORM_TFSTATE | \
          sed '/: $/d' | grep -v null | sort -u >> $VARFILE
    
      #echo "pks_api_lb: tcp:pks-api" >> $VARFILE
      echo "zone-1: $AVAILABILITY_ZONE1" >> $VARFILE
      echo "zone-2: $AVAILABILITY_ZONE2" >> $VARFILE
      echo "zone-3: $AVAILABILITY_ZONE3" >> $VARFILE
      echo "master_service_account: $GCP_SVC_NAME" >> $VARFILE
      echo "project: $GCP_SVC_PRJID" >> $VARFILE
    fi

    messagePrint " - OpsManager URL" "http://$OPS_MANAGER_DNS"
    messagePrint " - PKS Variable File" "$VARFILE"

    OPSMAN_STAGED_PRODUCT=$($OM $OM_LOGIN staged-products | grep "pivotal-container-service" | awk '{ print $4 }')
    if [ "${OPSMAN_STAGED_PRODUCT}" == "" ]; then
      wait_loop 10 "Waiting product to be ready to stage"

      # --- CHEKING DNS ---
      i=1; ret=1
       while [ $i -lt 10 -a ${ret} -ne 0 ]; do
        sleep 10
        OPSMAN_AVAILABLE_PRODUCT=$($OM $OM_LOGIN available-products | grep "pivotal-container-service" | awk '{ print $4 }')
        if [ "${OPSMAN_AVAILABLE_PRODUCT}" != "" ]; then ret=0; fi
        let i=i+1
      done

      if [ "${OPSMAN_AVAILABLE_PRODUCT}" != "" ]; then
        echo "Staging PKS Product Tile"
        messagePrint " - Staging PKS Tile:" "$OPSMAN_AVAILABLE_PRODUCT"
        echo "-----------------------------------------------------------------------------------------------------------"
        $OM $OM_LOGIN stage-product --product-name pivotal-container-service --product-version ${OPSMAN_AVAILABLE_PRODUCT}
        if [ $? -ne 0 ]; then 
          echo "ERROR: Staging of pivotal-container-service has been failed, please retry"; exit 1
        fi
      else
        echo "ERROR: No product to stage found"; exit 0
      fi
    fi
  
    OPSMAN_STAGED_PRODUCT=$($OM $OM_LOGIN staged-products | grep "pivotal-container-service" | awk '{ print $4 }')
    if [ "${OPSMAN_STAGED_PRODUCT}" == "" ]; then
      echo "ERROR: Product pivotal-container-service could not be staged"; exit 1
    fi

    echo "-----------------------------------------------------------------------------------------------------------"
    $OM $OM_LOGIN configure-product --config $PCFCONFIG_PATH/templates/${PKS_TEMPLATE} --vars-file $VARFILE
    if [ $? -ne 0 ]; then 
      echo "ERROR: Configuring PKS tile has been failed, please retry"; exit 1
    fi
    echo "-----------------------------------------------------------------------------------------------------------"

    if [ "${PCF_CLOUD_NAME}" == "aws" ]; then
      # --- CREATE ELB LOADBALANCER ---
      SUB1=$($JQ -r '.modules[].outputs.public_subnet_ids.value[0]' $TERRAFORM_TFSTATE | grep -v null | sed '/: $/d' | sort -u)
      SUB2=$($JQ -r '.modules[].outputs.public_subnet_ids.value[1]' $TERRAFORM_TFSTATE | grep -v null | sed '/: $/d' | sort -u)
      SUB3=$($JQ -r '.modules[].outputs.public_subnet_ids.value[2]' $TERRAFORM_TFSTATE | grep -v null | sed '/: $/d' | sort -u)
      SECG=$($JQ -r '.modules[].resources."aws_security_group.pks_api_lb_security_group".primary.id' $TERRAFORM_TFSTATE | \
         grep -v null | sed '/: $/d' | sort -u)

      echo "Creating ELB Loadbalancer (elb-api-lb)"
      messagePrint " - Subnet-1:" "$SUB1"
      messagePrint " - Subnet-2:" "$SUB2"
      messagePrint " - Subnet-3:" "$SUB3"
      messagePrint " - Security Group:" "$SECG"

      aws elb --region $AWS_REGION describe-load-balancers --load-balancer-names "elb-api-lb" > /dev/null 2>&1; ret=$?
      if [ ${ret} -gt 0 ]; then
        aws elb create-load-balancer --region $AWS_REGION  --load-balancer-name "elb-api-lb" --tags "Key=Environment,Value=$AWS_DNS_PREFIX" \
        --listeners "Protocol=TCP,LoadBalancerPort=8443,InstanceProtocol=TCP,InstancePort=8443" \
                    "Protocol=TCP,LoadBalancerPort=9021,InstanceProtocol=TCP,InstancePort=9021" \
        --subnet $SUB1 $SUB2 $SUB3 --security-groups $SECG
      fi

      ELBDNS=$(aws elb --region $AWS_REGION describe-load-balancers --load-balancer-names "elb-api-lb" | \
          $JQ -r '.LoadBalancerDescriptions[0].DNSName')
      messagePrint " - DNS Name:" "$ELBDNS"

      #aws route53 list-hosted-zones-by-name --dns-name aws.pcfsdu.com
      #aws route53 list-resource-record-sets --hosted-zone-id "/hostedzone/Z13IRYE50CCEFL"

      # --- ROUTE53 TOKEN SPECIDIED ---
      if [ "${ROUTE53_TOKEN}" != "" ]; then 
        DNSLB=$(aws elb --region $AWS_REGION describe-load-balancers --load-balancer-names "elb-api-lb" | \
          jq -r '.LoadBalancerDescriptions[0].DNSName')
        DNSLB_ZONEID=$(aws elb --region $AWS_REGION describe-load-balancers --load-balancer-names "elb-api-lb" | \
          jq -r '.LoadBalancerDescriptions[0].CanonicalHostedZoneNameID')

        #aws route53 list-resource-record-sets --hosted-zone-id "/hostedzone/Z13IRYE50CCEFL" --query "ResourceRecordSets[?Name == 'api.pks.aws.pcfsdu.com.']" | jq -r '.[].AliasTarget.HostedZoneId'


        ZONE_ID=$(aws route53 list-hosted-zones-by-name --dns-name ${AWS_DNS_PREFIX}.${AWS_DNS_SUFFIX} | jq -r '.HostedZones[0].Id')
        ZONE_ID_STR=$(echo "${ZONE_ID}" | awk -F'/' '{ print $NF }')
        #RECORD_ID=$(aws route53 list-resource-record-sets --hosted-zone-id "${ZONE_ID}" \
        #    --query "ResourceRecordSets[?Name == '${TLS_HOST_NAME}.']" | jq -r '.[].AliasTarget.HostedZoneId')
        messagePrint " - DNS Zone (${AWS_DNS_PREFIX}.${AWS_DNS_SUFFIX}:" "zone managed by route53"
        messagePrint " - Updating Zone Record:" "$TLS_HOST_NAME" 

#pppp
        if [ "${ZONE_ID}" != "" ]; then 
    cat << EOF | sed -e "s/FQHN/$TLS_HOST_NAME/g" -e "s/AAAA/$DNSLB/g" -e "s/ZZID/$DNSLB_ZONEID/g" > /tmp/$$_zone_record
{
            "Comment": "CREATE/DELETE/UPSERT a record ",
            "Changes": [{
            "Action": "UPSERT",
                        "ResourceRecordSet": {
                                    "Name": "FQHN.",
                                    "Type": "A",
                                    "AliasTarget": {
                                                    "HostedZoneId": "ZZID",
                                                    "DNSName": "dualstack.AAAA.",
                                                    "EvaluateTargetHealth": true
                                                }
}}]
}
EOF

          echo "-----------------------------------------------------------------------------------------------------------"
          aws route53 change-resource-record-sets --hosted-zone-id "${ZONE_ID}" --change-batch file:///tmp/$$_zone_record
          echo "-----------------------------------------------------------------------------------------------------------"

          cp /tmp/$$_zone_record /tmp/aws_zone_record
          rm -f /tmp/$$_zone_record
        fi

      fi
#    else
#      echo "INFO: Pleae set an alias in the DNS Record of your domain ${DNS_PREFIX}.${DNS_SUFFIX} in the record"
#      echo "      of the $TLS_HOST_NAME with ALIAS: $DNSLB"
    fi


    # --- GET STEMCEL-VERSION ---
    scv=$(egrep "^${PKS_VERSION}:${PCF_CLOUD_NAME}:" $PCFCONFIG_PATH/files/opsman-pks-release-notes.txt | \
        awk -F: '{ print $7 }') 

    echo "Uploading Stemcell for PKS"
    scf=$(grep "${scv}:${PCF_CLOUD_NAME}:" $PCFCONFIG_PATH/files/stemcell-release-notes.txt | sort -t: -n -k2,2 | \
        tail -1 | awk -F: '{ print $5 }')
    des=$(grep "${scv}:${PCF_CLOUD_NAME}:" $PCFCONFIG_PATH/files/stemcell-release-notes.txt | sort -t: -n -k2,2 | \
        tail -1 | awk -F: '{ print $4 }')
    messagePrint " - Staging Stemcel Version:" "$scv"
    messagePrint " - Staging Stemcel Description:" "$des"
    messagePrint " - Staging Stemcel Glob:" "$scf"

    # --- CHECK IF ALREADY THERE ---
    if [ -f /tmp/${scf} ]; then 
      gzip -l /tmp/${scf} > /dev/null 2>&1
      if [ $? -ne 0 ]; then rm -f /tmp/${scf}; fi
    fi
 
    i=0
    if [ ! -f /tmp/${scf} ]; then 
      while [ 1 ]; do
        echo "-----------------------------------------------------------------------------------------------------------"
        $OM $OM_LOGIN --request-timeout=60 download-product --output-directory=/tmp --pivnet-product-slug stemcells-ubuntu-xenial \
                      --pivnet-file-glob ${scf} --pivnet-api-token  "$PIVNET_TOKEN" --product-version ${scv}; ret=$?
        if [ $ret -eq 0 ]; then 
          gzip -l /tmp/${scf} > /dev/null 2>&1
          if [ $? -eq 0 ]; then 
            break
          else
            rm -f /tmp/${scf}
          fi
        fi
          
        if [ $i -ge 3 ]; then
          echo "ERROR: Downloading Product: ${scf} failed"; exit 1
        fi
        let i=i+1
      done
    fi

    echo "-----------------------------------------------------------------------------------------------------------"
    $OM $OM_LOGIN upload-stemcell --stemcell /tmp/${scf} 
    echo "-----------------------------------------------------------------------------------------------------------"

    if [ $NO_APPLY -eq 0 ]; then
      echo ""
      echo "Applying Changes to PKS"
      if [ $DEBUG -gt 0 ]; then
        echo "-----------------------------------------------------------------------------------------------------------"
        $OM $OM_LOGIN --request-timeout=60 apply-changes
        echo "-----------------------------------------------------------------------------------------------------------"
      else
        $OM $OM_LOGIN --request-timeout=60 apply-changes > /dev/null 2>&1
        if [ $? -ne 0 ]; then 
          echo "ERROR: Applying Changes has been failed, please try manual"
          echo "       $OM $OM_LOGIN apply-changes"; exit 1
        fi
      fi
    fi

    echo ""
    echo "Configuration of the PKS Tile is completed."
    exit 0
  fi
fi

if [ "${PCFCONFIG_BASE}" == "pcfconfig-pks-setup" ]; then
  checkEnvironment

  OPS_MANAGER_URL=https://${OPS_MANAGER_DNS}/setup
  OM_LOGIN="--skip-ssl-validation --target ${OPS_MANAGER_URL} --username admin --password pivotal"

  # GET CREDENTIALS
  TMP_JQ=/tmp/$$_jq; TMP_SEC=/tmp/$$_sec;
  $OM $OM_LOGIN curl --path /api/v0/deployed/products > $TMP_JQ 2>/dev/null; ret=$?
  if [ $ret -eq 0 ]; then 
    director_ip=$($OM $OM_LOGIN curl --path /api/v0/deployed/director/manifest 2>/dev/null | \
                  jq -r '.instance_groups[].properties.director.address')
    director_cd=$($OM $OM_LOGIN curl --path /api/v0/deployed/director/credentials/uaa_admin_user_credentials 2>/dev/null | \
                  jq -r '.credential.value.password')

    prd="xxx"; i=0
    while [ "${prd}" != "null" ]; do
      prd=$(jq -r ".[$i].type" $TMP_JQ)
      if [ "${prd}" == "pivotal-container-service" ]; then
        inm=$(jq -r ".[$i].installation_name" $TMP_JQ)
        str="/api/v0/deployed/products/${inm}/credentials/.properties.pks_uaa_management_admin_client"
        $OM $OM_LOGIN curl --path ${str} > $TMP_SEC 2>/dev/null; ret=$?
        if [ $ret -eq 0 ]; then 
          sec=$(jq -r '.credential.value.secret' $TMP_SEC) 
        else
          echo "ERROR: 1Can not connect to $OPS_MANAGER_URL"; exit 1
        fi

        # --- UAA-ADMIN-PASSWORD ---
        str="/api/v0/deployed/products/${inm}/credentials/.properties.uaa_admin_password"
        $OM $OM_LOGIN curl --path ${str} > $TMP_SEC 2>/dev/null; ret=$?
        if [ $ret -eq 0 ]; then
          admin_sec=$(jq -r '.credential.value.secret' $TMP_SEC)
        else
          echo "ERROR: 2Can not connect to $OPS_MANAGER_URL"; exit 1
        fi
      fi 

      let i=i+1
    done

    rm -f $$TMP_JQ
  else
    echo "ERROR: Can not connect to $OPS_MANAGER_URL"; exit 1
  fi

  TLS_HOST_NAME=api.pks.${DNS_PREFIX}.${DNS_SUFFIX}
  TMP_OPSMAN=/tmp/$$_opsman; TMP_OPSMAN_PUB=/tmp/$$_opsman.pub; TMP_SCRIPT=/tmp/$$_opsman.sh
  $JQ -r '.modules[].outputs.ssh_private_key.value' $TERRAFORM_TFSTATE | grep -v null >> $TMP_OPSMAN
  $JQ -r '.modules[].outputs.ops_manager_ssh_private_key.value' $TERRAFORM_TFSTATE | grep -v null >> $TMP_OPSMAN
  touch $TMP_SCRIPT
echo "XXXX TMP_OPSMAN:$TMP_OPSMAN"
  [ "$TMP_OPSMAN" != "" ] && chmod 600 $TMP_OPSMAN
  [ "$TMP_SCRIPT" != "" ] && chmod 777 $TMP_SCRIPT

  # --- CHEKING DNS ---
  echo "Validating API GATEWAY DNS record ($TLS_HOST_NAME)"
  nslookup -timeout=10 $TLS_HOST_NAME 8.8.8.8 > /dev/null 2>&1; ret=$?
  if [ $ret -ne 0 ]; then
    i=1; ret="failed"; dns_google_stat="failed"
     while [ $i -lt 10 -a ${ret} == "failed" ]; do
      sleep 10
      nslookup $TLS_HOST_NAME 8.8.8.8 > /dev/null 2>&1; ret=$?
      if [ $ret -eq 0 ]; then dns_google_stat="successful"; fi
      messagePrint "   => Verify DNS lookup Google (8.8.8.8)" "$dns_google_stat"
      let i=i+1
    done
  else
    messagePrint "   => Verify DNS lookup Google (8.8.8.8)" "successful"
  fi

  localdns=$(nslookup localhost | grep Server:  | awk '{ print $2 }')
  i=1; ret="failed"; dns_google_stat="failed"
   while [ $i -lt 30 -a ${ret} == "failed" ]; do
    sleep 10
    nslookup $TLS_HOST_NAME > /dev/null 2>&1; ret=$?
    if [ $ret -eq 0 ]; then dns_google_stat="successful"; fi
    messagePrint "   => Verify DNS lookup localhost ($localdns)" "$dns_google_stat"
    let i=i+1
  done

#xxxx

  nslookup $TLS_HOST_NAME 8.8.8.8 > /dev/null 2>&1; ret=$?
  if [ $ret -eq 0 ]; then 
    ##############################################################################################
    ############################### CONFIGURE PKS AUTHENTIFICATION ###############################
    ##############################################################################################

    # --- CHECK IF AUTHENTIFICATION HAS ALREADY BEEN CONFIGURED ---
    pks login -u ${PKS_ADMIN_USER} -p ${PKS_ADMIN_PASS} -a ${TLS_HOST_NAME} --skip-ssl-validation > /dev/null 2>&1; ret=$?
    if [ $ret -ne 0 ]; then 
      echo "Creating PKS Authentification"
      messagePrint " - PKS Administration User:" "$PKS_ADMIN_USER"
      messagePrint " - PKS Administration Password:" "$PKS_ADMIN_PASS"
      messagePrint " - PKS Administration Email:" "$PKS_ADMIN_MAIL"
      messagePrint " - PKS Administration Role:" "pks.clusters.admin"

      # SLEEP AS CRACE PERIOD 
      sleep 240

      # --- UAAC LOGIN SCRIPT ---
      TMP_SCRIPT=/tmp/tmp_script_$$; rm -f $TMP_SCRIPT
      echo "echo '# Connecting to ${TLS_HOST_NAME}'"                                                          >  $TMP_SCRIPT
      #echo "uaac target ${TLS_HOST_NAME}:8443 --ca-cert /var/tempest/workspaces/default/root_ca_certificate" >> $TMP_SCRIPT
      echo "uaac target ${TLS_HOST_NAME}:8443 --skip-ssl-validation 2>/dev/null"                              >> $TMP_SCRIPT
      echo "if [ \$? -ne 0 ]; then"                                                                           >> $TMP_SCRIPT
      echo "  exit 1"                                                                                         >> $TMP_SCRIPT
      echo "fi"                                                                                               >> $TMP_SCRIPT
      echo "echo '# Grant Enterprise PKS Access to a User'"                                                   >> $TMP_SCRIPT
      echo "uaac token client get admin -s ${sec} 2>/dev/null"                                                >> $TMP_SCRIPT
      echo "echo '# Add User: ${PKS_ADMIN_USER} / ${PKS_ADMIN_MAIL}'"                                         >> $TMP_SCRIPT
      echo "sudo uaac user get ${PKS_ADMIN_USER} 2>/dev/null"                                                 >> $TMP_SCRIPT
      echo "if [ \$? -ne 0 ]; then"                                                                           >> $TMP_SCRIPT
      echo "  uaac user add ${PKS_ADMIN_USER} --emails ${PKS_ADMIN_MAIL} -p ${PKS_ADMIN_PASS} 2>/dev/null"    >> $TMP_SCRIPT
      echo "  uaac member add pks.clusters.admin ${PKS_ADMIN_USER} 2>/dev/null"                               >> $TMP_SCRIPT
      echo "fi"                                                                                               >> $TMP_SCRIPT

      cp $TMP_OPSMAN ~/opsman.pem
      echo "ssh -qi ~/opsman.pem ubuntu@${OPS_MANAGER_DNS}" > ~/ssh-opsman.sh
  
echo gaga1
      scp -o StrictHostKeyChecking=no -qi $TMP_OPSMAN $TMP_SCRIPT ubuntu@${OPS_MANAGER_DNS}:/tmp/om-install.sh; ret=$?
      if [ ${ret} -ne 0 ]; then
        echo "ERROR: Copying script /tmp/om-install.sh to ubuntu@${OPS_MANAGER_DNS} has been failed"
        echo "       Please try manually:"
        echo "       => scp -o StrictHostKeyChecking=no -i $TMP_OPSMAN $TMP_SCRIPT ubuntu@${OPS_MANAGER_DNS}:/tmp/om-install.sh"
        exit 1
      fi

echo gaga2
      echo "-----------------------------------------------------------------------------------------------------------"
      (ssh -qi $TMP_OPSMAN ubuntu@${OPS_MANAGER_DNS} -n "sudo /tmp/om-install.sh"; ret=$?) | sed '/^$/d'
      echo "-----------------------------------------------------------------------------------------------------------"
      if [ ${ret} -ne 0 ]; then
        echo "ERROR: executing remote-script: /tmp/om-install.sh on ubuntu@${OPS_MANAGER_DNS} has been failed"
        echo "       Please try manually:"
        echo "       => ssh -i $TMP_OPSMAN ubuntu@${OPS_MANAGER_DNS} -n \"sudo /tmp/om-install.sh\""
        exit 1
      fi

echo "pks login -u ${PKS_ADMIN_USER} -p ${PKS_ADMIN_PASS} -a ${TLS_HOST_NAME} --skip-ssl-validation"
      pks login -u ${PKS_ADMIN_USER} -p ${PKS_ADMIN_PASS} -a ${TLS_HOST_NAME} --skip-ssl-validation > /dev/null 2>&1; ret=$?
      if [ $ret -ne 0 ]; then
        echo "ERROR: Accessing API gateway $OPS_MANAGER_DNS failed"; exit 1
      fi
    fi

    ##############################################################################################
    ################################ CONFIGURE PKS LOADBALANCERS #################################
    ##############################################################################################

    if [ "${PCF_CLOUD_NAME}" == "gcp" ]; then
      for n in $PKS_CLUSTER_1_NAME $PKS_CLUSTER_2_NAME $PKS_CLUSTER_3_NAME; do
echo "gaga N:$n ${GCP_DNS_PREFIX}-${n}"
echo "gcloud compute forwarding-rules describe ${GCP_DNS_PREFIX}-${n} --region=$GCP_REGION"
        gcloud compute target-pools describe ${GCP_DNS_PREFIX}-${n} --region=$GCP_REGION > /dev/null 2>&1; ret=$?
        if [ ${ret} -gt 0 ]; then
          # --- CREATE TARGET POOL ---
          echo "Creating Target Pool (${GCP_DNS_PREFIX}-$n)"
          gcloud compute target-pools create ${GCP_DNS_PREFIX}-${n} --region=$GCP_REGION > /dev/null 2>&1; ret=$?
          if [ ${ret} -ne 0 ]; then
            echo "ERROR: Creating target-pools (${GCP_DNS_PREFIX}-$n)"
            echo "gcloud compute target-pools create ${GCP_DNS_PREFIX}-${n} --region=$GCP_REGION"
            exit 1
          fi
        fi

echo "gagaga xx"

echo "gcloud compute forwarding-rules describe ${GCP_DNS_PREFIX}-${n} --region=$GCP_REGION"
        gcloud compute forwarding-rules describe ${GCP_DNS_PREFIX}-${n} --region=$GCP_REGION > /dev/null 2>&1; ret=$?
        if [ ${ret} -gt 0 ]; then
          # --- CREATE LOAD BALANCER ---
          echo "Creating LoadBalancer (${GCP_DNS_PREFIX}-$n) for cluster: $n"
	  gcloud compute forwarding-rules create ${GCP_DNS_PREFIX}-${n} --ports 8443 \
            --target-pool ${GCP_DNS_PREFIX}-${n} --region=$GCP_REGION > /dev/null 2>&1; ret=$?
echo "gcloud compute forwarding-rules create ${GCP_DNS_PREFIX}-${n} --ports 8443 --target-pool ${GCP_DNS_PREFIX}-${n} --region=$GCP_REGION"
          if [ ${ret} -ne 0 ]; then
            echo "ERROR: Creating forwarding-rules (${GCP_DNS_PREFIX}-$n)"
            echo "gcloud compute target-pools create ${GCP_DNS_PREFIX}-${n} --region=$GCP_REGION"
            exit 1
          fi
        fi

        cnt=$(gcloud dns record-sets list -z ${GCP_DNS_PREFIX}-zone --name "${n}.${GCP_DNS_PREFIX}.${GCP_DNS_SUFFIX}." \
                --type=A 2> /dev/null | wc -l | sed 's/ //g')
echo "gcloud dns record-sets list -z ${GCP_DNS_PREFIX}-zone --name ${n}.${GCP_DNS_PREFIX}.${GCP_DNS_SUFFIX}. --type=A 2> /dev/null | wc -l | sed 's/ //g'"
echo "CNT:$cnt"
        if [ ${cnt} -eq 0 ]; then
          echo "Creating DNS Entry ${n}.${GCP_DNS_PREFIX}.${GCP_DNS_SUFFIX}. for (${GCP_DNS_PREFIX}-zone)"
echo "gaga"
echo "gcloud compute forwarding-rules describe ${GCP_DNS_PREFIX}-${n} --region=$GCP_REGION"
          ipa=$(gcloud compute forwarding-rules describe ${GCP_DNS_PREFIX}-${n} --region=$GCP_REGION | \
              grep IPAddress | awk '{ print $NF }')
echo "IPA:$ipa"
echo "gcloud dns record-sets transaction start -z ${GCP_DNS_PREFIX}-zone"
          gcloud dns record-sets transaction start -z ${GCP_DNS_PREFIX}-zone
echo "gcloud dns record-sets transaction add $ipa --name ${n}.${GCP_DNS_PREFIX}.${GCP_DNS_SUFFIX}. --type A -z ${GCP_DNS_PREFIX}-zone --ttl=300"
          gcloud dns record-sets transaction add "$ipa" --name ${n}.${GCP_DNS_PREFIX}.${GCP_DNS_SUFFIX}. \
             --type A -z ${GCP_DNS_PREFIX}-zone --ttl=300
echo "gcloud dns record-sets transaction execute -z ${GCP_DNS_PREFIX}-zone"
          gcloud dns record-sets transaction execute -z ${GCP_DNS_PREFIX}-zone > /dev/null 2>&1; ret=$?
          if [ ${ret} -ne 0 ]; then
            echo "ERROR: Creating DNS record-sets for zone (${GCP_DNS_PREFIX}-zone)"
            exit 1
          fi
        fi
      done
    fi

    if [ "${PCF_CLOUD_NAME}" == "aws" ]; then
      # --- CREATE ELB LOADBALANCER ---
      SUB1=$($JQ -r '.modules[].outputs.public_subnet_ids.value[0]' $TERRAFORM_TFSTATE | grep -v null | sed '/: $/d' | sort -u)
      SUB2=$($JQ -r '.modules[].outputs.public_subnet_ids.value[1]' $TERRAFORM_TFSTATE | grep -v null | sed '/: $/d' | sort -u)
      SUB3=$($JQ -r '.modules[].outputs.public_subnet_ids.value[2]' $TERRAFORM_TFSTATE | grep -v null | sed '/: $/d' | sort -u)
      SECG=$($JQ -r '.modules[].resources."aws_security_group.pks_api_lb_security_group".primary.id' $TERRAFORM_TFSTATE | \
         grep -v null | sed '/: $/d' | sort -u)

      echo "Creating ELB Loadbalancer (k8s-master-$n)"
      messagePrint " - Subnet-1:" "$SUB1"
      messagePrint " - Subnet-2:" "$SUB2"
      messagePrint " - Subnet-3:" "$SUB3"
      messagePrint " - Security Group:" "$SECG"

      #echo "       => scp -o StrictHostKeyChecking=no -i $TMP_OPSMAN $TMP_SCRIPT ubuntu@${OPS_MANAGER_DNS}:/tmp/om-install.sh"
      #echo "       => ssh -i $TMP_OPSMAN ubuntu@${OPS_MANAGER_DNS} -n \"sudo /tmp/om-install.sh\""

      for n in $PKS_CLUSTER_1_NAME $PKS_CLUSTER_2_NAME $PKS_CLUSTER_3_NAME; do
        aws elb --region $AWS_REGION describe-load-balancers --load-balancer-names "k8s-master-$n" > /dev/null 2>&1; ret=$?
        if [ ${ret} -gt 0 ]; then
          echo "Creating LoadBalancer (k8s-master-$n) for cluster: $n"

          aws elb create-load-balancer --region $AWS_REGION  --load-balancer-name "k8s-master-$n" \
             --tags "Key=Environment,Value=$AWS_DNS_PREFIX" \
             --listeners "Protocol=TCP,LoadBalancerPort=8443,InstanceProtocol=TCP,InstancePort=8443" \
             --subnet $SUB1 $SUB2 $SUB3 --security-groups $SECG > /dev/null 2>&1; ret=$?
          if [ ${ret} -ne 0 ]; then
            echo "ERROR: Creating LoadBalancer"
            echo "aws elb create-load-balancer --region $AWS_REGION  --load-balancer-name \"k8s-master-$n\" \\"
            echo "  --tags \"Key=Environment,Value=$AWS_DNS_PREFIX\" \\"
            echo "  --listeners \"Protocol=TCP,LoadBalancerPort=8443,InstanceProtocol=TCP,InstancePort=8443\" \\"
            echo "  --subnet $SUB1 $SUB2 $SUB3 --security-groups $SECG"
            exit 1
          fi

          aws elb configure-health-check --region $AWS_REGION --load-balancer-name k8s-master-$n \
             --health-check "Target=TCP:8443,Interval=30,UnhealthyThreshold=2,HealthyThreshold=2,Timeout=3" > /dev/null 2>&1; ret=$?
          if [ ${ret} -ne 0 ]; then
            echo "ERROR: Configure Healhcheck"
            echo "aws elb configure-health-check --region $AWS_REGION --load-balancer-name k8s-master-$n \\"
            echo "  --health-check \"Target=TCP:8443,Interval=30,UnhealthyThreshold=2,HealthyThreshold=2,Timeout=3\""
            exit 1
          fi
        fi

        if [ "${ROUTE53_TOKEN}" != "" ]; then
          DNSLB=$(aws elb --region $AWS_REGION describe-load-balancers --load-balancer-names "k8s-master-$n" | \
            jq -r '.LoadBalancerDescriptions[0].DNSName')
          DNSLB_ZONEID=$(aws elb --region $AWS_REGION describe-load-balancers --load-balancer-names "k8s-master-$n" | \
            jq -r '.LoadBalancerDescriptions[0].CanonicalHostedZoneNameID')

          ZONE_ID=$(aws route53 list-hosted-zones-by-name --dns-name ${AWS_DNS_PREFIX}.${AWS_DNS_SUFFIX} | jq -r '.HostedZones[0].Id')
          ZONE_ID_STR=$(echo "${ZONE_ID}" | awk -F'/' '{ print $NF }')

#ppppp
          if [ "${ZONE_ID}" != "" ]; then
            ZONE="${n}.${AWS_DNS_PREFIX}.${AWS_DNS_SUFFIX}"

    cat << EOF | sed -e "s/FQHN/${ZONE}/g" -e "s/AAAA/$DNSLB/g" -e "s/ZZID/$DNSLB_ZONEID/g" > /tmp/$$_zone_record
{
            "Comment": "CREATE/DELETE/UPSERT a record ",
            "Changes": [{
            "Action": "UPSERT",
                        "ResourceRecordSet": {
                                    "Name": "FQHN.",
                                    "Type": "A",
                                    "AliasTarget": {
                                                    "HostedZoneId": "ZZID",
                                                    "DNSName": "dualstack.AAAA.",
                                                    "EvaluateTargetHealth": true
                                                }
}}]
}
EOF


            echo "-----------------------------------------------------------------------------------------------------------"
            aws route53 change-resource-record-sets --hosted-zone-id ${ZONE_ID} --change-batch file:///tmp/$$_zone_record
            echo "-----------------------------------------------------------------------------------------------------------"

            cp /tmp/$$_zone_record /tmp/aws_zone_record
            rm -f /tmp/$$_zone_record
          fi
        fi
      done
    fi

    ##############################################################################################
    #################################### CREATE PKS CLUSTERS #####################################
    ##############################################################################################

echo "ssh -qi $TMP_OPSMAN ubuntu@${OPS_MANAGER_DNS} "
echo "pks login -u ${PKS_ADMIN_USER} -p ${PKS_ADMIN_PASS} -a ${TLS_HOST_NAME} --skip-ssl-validation"
echo "pks login -u admin -p ${admin_sec} -a ${TLS_HOST_NAME} --skip-ssl-validation"

    if [ "${PKS_CLUSTER_1_NAME}" != "" -o "${PKS_CLUSTER_2_NAME}" != "" -o "${PKS_CLUSTER_3_NAME}" != "" ]; then 
      pks login -u ${PKS_ADMIN_USER} -p ${PKS_ADMIN_PASS} -a ${TLS_HOST_NAME} --skip-ssl-validation > /dev/null 2>&1
      if [ $? -ne 0 ]; then
        echo "ERROR: login to pks failled"; exit 1
      fi
  
      if [ "${PKS_CLUSTER_1_NAME}" != "" ]; then 
        pks cluster $PKS_CLUSTER_1_NAME > /dev/null 2>&1
        if [ $? -ne 0 ]; then 
          messagePrint "PKS Cluster 1: $PKS_CLUSTER_1_NAME" "creating"
          messagePrint " - External Hostnama:" "$PKS_CLUSTER_1_NAME.${DNS_PREFIX}.${DNS_SUFFIX}"
          messagePrint " - Plan:" "$PKS_CLUSTER_1_PLAN"
          pks create-cluster $PKS_CLUSTER_1_NAME \
             --external-hostname $PKS_CLUSTER_1_NAME.${DNS_PREFIX}.${DNS_SUFFIX} \
             --plan $PKS_CLUSTER_1_PLAN --wait 
          echo "-----------------------------------------------------------------------------------------------------------"
          if [ $? -ne 0 ]; then 
            echo "ERROR: Creating PKS Cluster $PKS_CLUSTER_1_NAME failed"
            echo "       => pks create-cluster $PKS_CLUSTER_1_NAME --external-hostname ${lbdns} --plan $PKS_CLUSTER_1_PLAN  --wait"
            exit 1
          fi

          stt=$(pks cluster $PKS_CLUSTER_1_NAME | egrep "Last Action State:" | awk '{ print $NF }')
          messagePrint "PKS Cluster 1: $PKS_CLUSTER_1_NAME ($PKS_CLUSTER_1_PLAN)" "$stt"
          if [ "$stt" != "succeeded" ]; then
            echo "ERROR: PKS Cluster ($PKS_CLUSTER_1_NAME) creation failed"; exit 1
          fi
        else
          stt=$(pks cluster $PKS_CLUSTER_1_NAME | egrep "Last Action State:" | awk '{ print $NF }')
          messagePrint "PKS Cluster 1: $PKS_CLUSTER_1_NAME ($PKS_CLUSTER_1_PLAN)" "$stt"

          if [ "$stt" == "failed" ]; then
            echo "ERROR: PKS Cluster ($PKS_CLUSTER_1_NAME) is in failed state, please delete cluster and restart"
            echo "       => pks delete-cluster $PKS_CLUSTER_1_NAME"
            #exit 1
          fi
        fi
      fi

      if [ "${PKS_CLUSTER_2_NAME}" != "" ]; then
        pks cluster $PKS_CLUSTER_2_NAME > /dev/null 2>&1
        if [ $? -ne 0 ]; then
          messagePrint "PKS Cluster 2: $PKS_CLUSTER_1_NAME" "creating"
          messagePrint " - External Hostnama:" "$PKS_CLUSTER_2_NAME.${DNS_PREFIX}.${DNS_SUFFIX}"
          messagePrint " - Plan:" "$PKS_CLUSTER_2_PLAN"
          pks create-cluster $PKS_CLUSTER_2_NAME \
             --external-hostname $PKS_CLUSTER_2_NAME.${DNS_PREFIX}.${DNS_SUFFIX} \
             --plan $PKS_CLUSTER_2_PLAN --wait
          echo "-----------------------------------------------------------------------------------------------------------"
          if [ $? -ne 0 ]; then
            echo "ERROR: Creating PKS Cluster $PKS_CLUSTER_2_NAME failed"
            echo "       => pks create-cluster $PKS_CLUSTER_2_NAME --external-hostname ${lbdns} --plan $PKS_CLUSTER_2_PLAN  --wait"
            #exit 1
          fi

          stt=$(pks cluster $PKS_CLUSTER_2_NAME | egrep "Last Action State:" | awk '{ print $NF }')
          messagePrint "PKS Cluster 2: $PKS_CLUSTER_2_NAME ($PKS_CLUSTER_2_PLAN)" "$stt"
          if [ "$stt" != "succeeded" ]; then
            echo "ERROR: PKS Cluster ($PKS_CLUSTER_2_NAME) creation failed"; #exit 1
          fi
        else
          stt=$(pks cluster $PKS_CLUSTER_2_NAME | egrep "Last Action State:" | awk '{ print $NF }')
          messagePrint "PKS Cluster 2: $PKS_CLUSTER_2_NAME ($PKS_CLUSTER_2_PLAN)" "$stt"

          if [ "$stt" == "failed" ]; then
            echo "ERROR: PKS Cluster ($PKS_CLUSTER_2_NAME) is in failed state, please delete cluster and restart"
            echo "       => pks delete-cluster $PKS_CLUSTER_2_NAME"
            #exit 1
          fi
        fi
      fi
    fi

    TMP_LBSCRIPT=/tmp/tmp_lb_script_$$; rm -f $TMP_LBSCRIPT

echo "xxxxxxxxxxxx director_ip: $director_ip"
    ##############################################################################################
    ######################## SET VLAN TAGS AND INSTANCES OF MASTERNODES ##########################
    ##############################################################################################

    if [ "${PCF_CLOUD_NAME}" == "gcp" ]; then

        ##############################################################################################
        ############################## GET CLUSTER INSTANCES GET INSTANCES ###########################
        ##############################################################################################

        echo "cert=/var/tempest/workspaces/default/root_ca_certificate"                                          >  $TMP_LBSCRIPT
        echo "bosh alias-env $DNS_PREFIX -e $director_ip --ca-cert \$cert >/dev/null 2>&1"                       >> $TMP_LBSCRIPT
        echo "[ \$? -ne 0 ] && exit 1"                                                                           >> $TMP_LBSCRIPT
        echo "echo -e \"admin\n${director_cd}\" | bosh -e $DNS_PREFIX login >/dev/null 2>&1"                     >> $TMP_LBSCRIPT
        echo "[ \$? -ne 0 ] && exit 1"                                                                           >> $TMP_LBSCRIPT
        echo "bosh -e $DNS_PREFIX -d service-instance_$uid vms | egrep \"^master/\" | awk '{ print \$(NF-2) }'"  >> $TMP_LBSCRIPT

        scp -o StrictHostKeyChecking=no -qi $TMP_OPSMAN $TMP_LBSCRIPT ubuntu@${OPS_MANAGER_DNS}:/tmp/masters.sh; ret=$?
        if [ ${ret} -ne 0 ]; then
          echo "ERROR: Copying script /tmp/masters.sh to ubuntu@${OPS_MANAGER_DNS} has been failed"
          echo "       Please try manually:"
          echo "       => scp -o StrictHostKeyChecking=no -i $TMP_OPSMAN $TMP_LBSCRIPT ubuntu@${OPS_MANAGER_DNS}:/tmp/masters.sh"
          exit 1
        fi

        ssh -qi $TMP_OPSMAN ubuntu@${OPS_MANAGER_DNS} -n "bash /tmp/masters.sh" >/dev/null 2>&1; ret=$?
        if [ ${ret} -ne 0 ]; then
          echo "ERROR: executing remote-script: /tmp/masters.sh on ubuntu@${OPS_MANAGER_DNS} has been failed"
          echo "       Please try manually:"
          echo "       => ssh -i $TMP_OPSMAN ubuntu@${OPS_MANAGER_DNS} -n \"bash /tmp/masters.sh\""
          exit 1
        else
          mst=$(ssh -qi $TMP_OPSMAN ubuntu@${OPS_MANAGER_DNS} -n "bash /tmp/masters.sh" 2>/dev/null)
        fi



    fi
exit 1

    if [ "${PCF_CLOUD_NAME}" == "aws" ]; then
      for n in $PKS_CLUSTER_1_NAME $PKS_CLUSTER_2_NAME $PKS_CLUSTER_3_NAME; do
        uid=$(pks cluster $n | egrep "UUID:" | awk '{ print $NF }')

        # --- ADD CLUSTER UUID TO AWS SUBNETS AT TAG ---
        for net in $(aws ec2 --region=$AWS_REGION describe-subnets | jq -r '.Subnets[].SubnetId'); do
          cnt=$(aws ec2 --region=$AWS_REGION describe-subnets --subnet-id $net | jq -r '.Subnets[].Tags[].Value' 2>/dev/null | \
              egrep -c "^${DNS_PREFIX}-public-subnet")
          if [ $cnt -gt 0 ]; then
            aws ec2 --region=$AWS_REGION create-tags --resources $net \
                --tags Key="kubernetes.io/cluster/service-instance_$uid",Value=""
          fi
        done

        ##############################################################################################
        ############################## GET CLUSTER INSTANCES GET INSTANCES ###########################
        ##############################################################################################

        echo "cert=/var/tempest/workspaces/default/root_ca_certificate"                                          >  $TMP_LBSCRIPT
        echo "bosh alias-env $DNS_PREFIX -e $director_ip --ca-cert \$cert >/dev/null 2>&1"                       >> $TMP_LBSCRIPT
        echo "[ \$? -ne 0 ] && exit 1"                                                                           >> $TMP_LBSCRIPT
        echo "echo -e \"admin\n${director_cd}\" | bosh -e $DNS_PREFIX login >/dev/null 2>&1"                     >> $TMP_LBSCRIPT
        echo "[ \$? -ne 0 ] && exit 1"                                                                           >> $TMP_LBSCRIPT
        echo "bosh -e $DNS_PREFIX -d service-instance_$uid vms | egrep \"^master/\" | awk '{ print \$(NF-2) }'"  >> $TMP_LBSCRIPT

        scp -o StrictHostKeyChecking=no -qi $TMP_OPSMAN $TMP_LBSCRIPT ubuntu@${OPS_MANAGER_DNS}:/tmp/masters.sh; ret=$?
        if [ ${ret} -ne 0 ]; then
          echo "ERROR: Copying script /tmp/masters.sh to ubuntu@${OPS_MANAGER_DNS} has been failed"
          echo "       Please try manually:"
          echo "       => scp -o StrictHostKeyChecking=no -i $TMP_OPSMAN $TMP_LBSCRIPT ubuntu@${OPS_MANAGER_DNS}:/tmp/masters.sh"
          exit 1
        fi

        ssh -qi $TMP_OPSMAN ubuntu@${OPS_MANAGER_DNS} -n "bash /tmp/masters.sh" >/dev/null 2>&1; ret=$?
        if [ ${ret} -ne 0 ]; then
          echo "ERROR: executing remote-script: /tmp/masters.sh on ubuntu@${OPS_MANAGER_DNS} has been failed"
          echo "       Please try manually:"
          echo "       => ssh -i $TMP_OPSMAN ubuntu@${OPS_MANAGER_DNS} -n \"bash /tmp/masters.sh\""
          exit 1
        else
          mst=$(ssh -qi $TMP_OPSMAN ubuntu@${OPS_MANAGER_DNS} -n "bash /tmp/masters.sh" 2>/dev/null)
        fi

        ##############################################################################################
        ########################## ADD MASTER INSTANCES TO THE PKS CLUSTER ###########################
        ##############################################################################################

        aws elb --region $AWS_REGION describe-load-balancers --load-balancer-names "k8s-master-$n" > /dev/null 2>&1; ret=$?
        if [ ${ret} -eq 0 ]; then
          for ins in $mst; do
            aws elb --region $AWS_REGION register-instances-with-load-balancer \
               --load-balancer-name k8s-master-$n --instances "${ins}" > /dev/null 2>&1; ret=$?
            if [ ${ret} -ne 0 ]; then
              echo "ERROR: Register Instances"
              echo "aws elb --region $AWS_REGION register-instances-with-load-balancer \\"
              echo "  --load-balancer-name k8s-master-$n --instances $ins"
              exit 1
            fi
          done
        fi
      done
    fi

    echo ""
    echo "Configuration of the PKS Swtup Completed is completed. Please login to PKS:"
    echo "pks login -u ${PKS_ADMIN_USER} -p ${PKS_ADMIN_PASS} -a ${TLS_HOST_NAME} --skip-ssl-validation"
    echo "pks login -u admin -p ${admin_sec} -a ${TLS_HOST_NAME} --skip-ssl-validation" 
    echo "pks get-credentials $PKS_CLUSTER_1_NAME"
    echo ""
    echo "Setup Kubernetes:"
    echo "kubectl config use-context $PKS_CLUSTER_1_NAME"
    echo "kubectl cluster-info"

  else
    echo ""
    echo "ERROR: API Host: $TLS_HOST_NAME can not be resolved by DNS"; exit 1
  fi
fi

# pks cluster pks-cluster-1 --json

# CLEANUP

	#aws iam list-instance-profiles
        #aws iam delete-instance-profile --instance-profile-name ppp_ops_manager
	#aws kms list-aliases --region eu-central-1
	#aws kms delete-alias --alias-name alias/ppp --region eu-central-1
        #aws elbv2 describe-target-groups --region eu-central-1

echo "################################ EOF ################################"
date +%s 

exit
